[{"path":"index.html","id":"about","chapter":"About","heading":"About","text":"documentation \nComplexHeatmap package. Examples book\ngenerated version 2.13.1.can get stable Bioconductor version \nhttp://bioconductor.org/packages/release/bioc/html/ComplexHeatmap.html, \n--date version always Github can install :development branch Bioconductor \nbasically synchronized Github repository.ComplexHeatmap package inspired pheatmap package. can find many arguments ComplexHeatmap names pheatmap. Also \ncan find old package tried develop modifying pheatmap.Please note, documentation completely compatible older versions (< 1.99.0, \nOct, 2018), major functionality keeps .use ComplexHeatmap publications, appreciated can cite:Gu, Z. (2016) Complex heatmaps reveal patterns correlations multidimensional genomic data.\nDOI: 10.1093/bioinformatics/btw313Session info:","code":"\nlibrary(devtools)\ninstall_github(\"jokergoo/ComplexHeatmap\")\nsessionInfo()## R version 4.2.0 (2022-04-22)\n## Platform: x86_64-apple-darwin17.0 (64-bit)\n## Running under: macOS Big Sur/Monterey 10.16\n## \n## Matrix products: default\n## BLAS:   /Library/Frameworks/R.framework/Versions/4.2/Resources/lib/libRblas.0.dylib\n## LAPACK: /Library/Frameworks/R.framework/Versions/4.2/Resources/lib/libRlapack.dylib\n## \n## locale:\n## [1] C/UTF-8/C/C/C/C\n## \n## attached base packages:\n## [1] grid      stats     graphics  grDevices utils     datasets  methods  \n## [8] base     \n## \n## other attached packages:\n## [1] dendsort_0.3.4        dendextend_1.15.2     circlize_0.4.16      \n## [4] ComplexHeatmap_2.13.1 colorout_1.2-2       \n## \n## loaded via a namespace (and not attached):\n##  [1] png_0.1-7           assertthat_0.2.1    digest_0.6.29      \n##  [4] foreach_1.5.2       utf8_1.2.2          R6_2.5.1           \n##  [7] stats4_4.2.0        evaluate_0.15       ggplot2_3.3.6      \n## [10] pillar_1.7.0        GlobalOptions_0.1.2 rlang_1.0.2        \n## [13] jquerylib_0.1.4     S4Vectors_0.34.0    GetoptLong_1.0.5   \n## [16] rmarkdown_2.14      stringr_1.4.0       munsell_0.5.0      \n## [19] compiler_4.2.0      xfun_0.31           pkgconfig_2.0.3    \n## [22] BiocGenerics_0.42.0 shape_1.4.6         htmltools_0.5.2    \n## [25] downlit_0.4.0       tidyselect_1.1.2    tibble_3.1.7       \n## [28] gridExtra_2.3       bookdown_0.27       IRanges_2.30.0     \n## [31] codetools_0.2-18    matrixStats_0.62.0  fansi_1.0.3        \n## [34] viridisLite_0.4.0   crayon_1.5.1        dplyr_1.0.9        \n## [37] jsonlite_1.8.0      gtable_0.3.0        lifecycle_1.0.1    \n## [40] DBI_1.1.2           magrittr_2.0.3      scales_1.2.0       \n## [43] stringi_1.7.6       cli_3.3.0           cachem_1.0.6       \n## [46] viridis_0.6.2       fs_1.5.2            doParallel_1.0.17  \n## [49] xml2_1.3.3          bslib_0.3.1         ellipsis_0.3.2     \n## [52] generics_0.1.2      vctrs_0.4.1         rjson_0.2.21       \n## [55] RColorBrewer_1.1-3  iterators_1.0.14    tools_4.2.0        \n## [58] glue_1.6.2          purrr_0.3.4         parallel_4.2.0     \n## [61] fastmap_1.1.0       yaml_2.3.5          clue_0.3-61        \n## [64] colorspace_2.0-3    cluster_2.1.3       memoise_2.0.1      \n## [67] knitr_1.39          sass_0.4.1"},{"path":"introduction.html","id":"introduction","chapter":"1 Introduction","heading":"1 Introduction","text":"Complex heatmaps efficient visualize associations different\nsources data sets reveal potential patterns. \nComplexHeatmap package provides highly flexible way arrange multiple\nheatmaps supports self-defined annotation graphics.","code":""},{"path":"introduction.html","id":"general-design","chapter":"1 Introduction","heading":"1.1 General design","text":"single heatmap composed heatmap body heatmap components.\nheatmap body can split rows columns. heatmap components \ntitles, dendrograms, row/column names/labels heatmap annotations, put \nfour sides heamap body. heatmap components reordered \nsplit according heatmap body.heatmap list concatenation list heatmaps heatmap annotations.\nSurrounding heatmap list, global-level titles legends.One important thing heatmap list rows heatmaps \nannotations adjusted row heatmaps \nannotations corresponds feature.heatmaps annotations (now column annotation) can also \narranged vertically.heatmap list can also split rows columns.ComplexHeatmap package implemented object-oriented way. \ndescribe heatmap list, following classes:Heatmap class: single heatmap containing heatmap body, row/column names,\ntitles, dendrograms row/column annotations.HeatmapList class: list heatmaps heatmap annotations.HeatmapAnnotation class: defines list row annotations column\nannotations. heatmap annotations can components heatmap, also \ncan independent heatmaps.also several internal classes:SingleAnnotation class: defines single row annotation column\nannotation. HeatmapAnnotation object contains list \nSingleAnnotation objects.ColorMapping class: mapping values colors. color mappings \nmain matrix annotations controlled ColorMapping class.AnnotationFunction class: constructs user-defined annotations. \nbase creating user-defined annotation graphics.ComplexHeatmap implemented grid system, users need know\nbasic grid functionality get full use package.","code":""},{"path":"introduction.html","id":"a-brief-description-of-following-chapters","chapter":"1 Introduction","heading":"1.2 A brief description of following chapters","text":"Single HeatmapThis chapter describes configurations single heatmap.Heatmap AnnotationsThis chapter describes concept heatmap annotation demonstrates\nmake simple annotations well complex annotations. Also, \nchapter explains difference column annotations row\nannotations.List HeatmapsThis chapter describes concatenate list heatmaps annotations\nadjustment applied keep correspondence heatmaps.LegendsThis chapter describes configurate heatmap legends annotation\nlegends, also create self-defined legends.Heatmap DecorationThis chapter describes methods add self-defined graphics \nheatmaps heatmaps generated.OncoPrintThis chapter describes make oncoPrints integrate \nfunctionalities ComplexHeatmap oncoPrints.UpSet plotThis chapter describes make enhanced UpSet plots.High-level PlotsThis chapter describes functions implemented ComplexHeatmap \nspecific use, e.g. visualizing distributions.Integrate packagesThis chapter describes packages integrated ComplexHeatmap. Currently,\ndemonstrate two packages gridtext pheatmap.Interactive heatmapThis chapter describes make heatmaps interactive.ExamplesMore simulated real-world examples demonstrated chapter.","code":""},{"path":"a-single-heatmap.html","id":"a-single-heatmap","chapter":"2 A Single Heatmap","heading":"2 A Single Heatmap","text":"single heatmap used approach visualizing data. Although\n“shining point” ComplexHeatmap package can visualize \nlist heatmaps parallel, however, basic unit heatmap list, \nstill important single heatmap well configured.First let’s generate random matrix three groups columns\nthree groups rows:Following command contains minimal argument Heatmap() function\nvisualizes matrix heatmap default settings. \nsimilar heatmap tools, draws dendrograms, row/column names\nheatmap legend. default color schema “blue-white-red” \nmapped minimal-mean-maximal values matrix. title \nlegend assigned internal index number.title legend taken “name” heatmap default.\nheatmap name like unique identifier heatmap \nimportant list heatmaps. later chapters, \nfind heatmap name used setting “main heatmap” used \ndecoration heatmaps. name assigned, internal name \nassigned heatmap form matrix_%d. following examples \nchapter, give name mat heatmap (see\nchange legend title next plot).put Heatmap() inside function //chunk, R script run command-line, \nwon’t see heatmap executing Heatmap(). case, need \nuse draw() function explicitly follows. explain point \ndetail Section 2.11.","code":"\nset.seed(123)\nnr1 = 4; nr2 = 8; nr3 = 6; nr = nr1 + nr2 + nr3\nnc1 = 6; nc2 = 8; nc3 = 10; nc = nc1 + nc2 + nc3\nmat = cbind(rbind(matrix(rnorm(nr1*nc1, mean = 1,   sd = 0.5), nr = nr1),\n          matrix(rnorm(nr2*nc1, mean = 0,   sd = 0.5), nr = nr2),\n          matrix(rnorm(nr3*nc1, mean = 0,   sd = 0.5), nr = nr3)),\n    rbind(matrix(rnorm(nr1*nc2, mean = 0,   sd = 0.5), nr = nr1),\n          matrix(rnorm(nr2*nc2, mean = 1,   sd = 0.5), nr = nr2),\n          matrix(rnorm(nr3*nc2, mean = 0,   sd = 0.5), nr = nr3)),\n    rbind(matrix(rnorm(nr1*nc3, mean = 0.5, sd = 0.5), nr = nr1),\n          matrix(rnorm(nr2*nc3, mean = 0.5, sd = 0.5), nr = nr2),\n          matrix(rnorm(nr3*nc3, mean = 1,   sd = 0.5), nr = nr3))\n   )\nmat = mat[sample(nr, nr), sample(nc, nc)] # random shuffle rows and columns\nrownames(mat) = paste0(\"row\", seq_len(nr))\ncolnames(mat) = paste0(\"column\", seq_len(nc))\nHeatmap(mat)for(...) {\n    ht = Heatmap(mat)\n    draw(ht)\n}"},{"path":"a-single-heatmap.html","id":"colors","chapter":"2 A Single Heatmap","heading":"2.1 Colors","text":"heatmap visualization, colors major representation data\nmatrix. cases, heatmap visualizes matrix continuous numeric\nvalues. case, users provide color mapping function. color\nmapping function accept vector values return vector \ncorresponding colors. Users always use circlize::colorRamp2()\nfunction generate color mapping function Heatmap(). \ntwo arguments colorRamp2() vector break values vector \ncorresponding colors. colorRamp2() linearly interpolates colors every\ninterval LAB color space. Also using colorRamp2() helps generate\nlegend proper tick marks.following example, values -2 2 linearly interpolated get\ncorresponding colors, values larger 2 mapped red values\nless -2 mapped green.can see, color mapping function exactly maps negative values \ngreen positive values red, even distribution negative\nvalues positive values centric zero. Also color mapping\nfunction affected outliers. following plot, clustering \nheavily affected outlier (see dendrogram) color mapping.importantly, colorRamp2() makes colors multiple heatmaps comparible\nset color mapping function. following three\nheatmaps, color always corresponds value.matrix continuous, can also simply provide vector colors\ncolors linearly interpolated. remember method \nrobust outliers mapping starts minimal value \nmatrix ends maximal value. Following color mapping setting \nidentical colorRamp2(seq(min(mat), max(mat), length = 10), rev(rainbow(10))).matrix contains discrete values (either numeric character), colors\nspecified named vector make possible mapping \ndiscrete values colors. name color vector, order \ncolors corresponds order unique(mat). Note now legend \ngenerated color mapping vector “discrete legend.”following example, set colors discrete numeric matrix. don’t need convert\ncharacter matrix, just set numbers “names” color vector.character matrix, straightforward.can see two examples , numeric matrix (matter \ncolor continuous mapping discrete mapping), default clustering \napplied dimensions, character matrix, clustering turned\n(can still cluster character matrix provide proper\ndistance metric two character vectors, see example Section\n2.3.1).NA allowed matrix. can control color NA na_col\nargument (default grey NA). matrix contains NA can\nclustered Heatmap() long NA distances \nrows columns respectively. Usually cases correspond \nsparse matrices (filled lot NA values), indicate \nunknown values predicted via methods first.Note NA value presented legend.Color space important interpolating colors. default, colors \nlinearly interpolated LAB color\nspace, can select \ncolor space colorRamp2() function. Compare following two plots. Can \nsee difference?following plots, corresponding values change evenly folded lines,\ncan see colors change different color spaces (top plots:\ngreen-black-red, bottom plots: blue-white-red. plot made \nHilbertCurve package).Last least, colors heatmap borders can set \nborder/border_gp rect_gp arguments. border/border_gp controls\nglobal border heatmap body rect_gp controls border \ngrids/cells heatmap.value border can logical (TRUE corresponds black) \ncharacter color (e.g. red). use border argument historical\nreason, can also set border_gp argument gpar object.rect_gp gpar object means can set \ngrid::gpar(). Since filled color already controlled heatmap\ncolor mapping, can set col/lwd/lty parameters gpar() control \nborder heatmap grids.col set, default color mapping Heatmap() designed \ntrying convinient meaningful possible. Following rules\ndefault color mapping (ComplexHeatmap:::default_col()):values characters, colors generated \ncirclize::rand_color().values heatmap annotation numeric, colors \nmapped white one random color linearly interpolating \nmininum maxinum.values matrix (let’s denote \\(M\\)):\nfraction positive values \\(M\\) 25% 75%, colors\nmapped blue, white red linearly interpolating \\(-q\\), 0\n\\(q\\), \\(q\\) maximum \\(|M|\\) number unique\nvalues less 100, \\(q\\) 99th percentile \\(|M|\\) 100 values teh matrix. \ncolor mapping centric zero.\nelse colors mapped blue, white red linearly\ninterpolating \\(q_1\\), \\((q_1 + q_2)/2\\) \\(q_2\\), \\(q_1\\) \\(q_2\\)\nmininum maxinum number unique values \\(M\\) less\n100. 100 values matrix, \\(q_1\\) 1st percentile \\(q_2\\) 99th\npercentile \\(M\\).\nfraction positive values \\(M\\) 25% 75%, colors\nmapped blue, white red linearly interpolating \\(-q\\), 0\n\\(q\\), \\(q\\) maximum \\(|M|\\) number unique\nvalues less 100, \\(q\\) 99th percentile \\(|M|\\) 100 values teh matrix. \ncolor mapping centric zero.else colors mapped blue, white red linearly\ninterpolating \\(q_1\\), \\((q_1 + q_2)/2\\) \\(q_2\\), \\(q_1\\) \\(q_2\\)\nmininum maxinum number unique values \\(M\\) less\n100. 100 values matrix, \\(q_1\\) 1st percentile \\(q_2\\) 99th\npercentile \\(M\\).rect_gp allows non-standard parameter type. set \"none\",\nclustering still applied nothing drawn heatmap body. \ncustomized graphics heatmap body can later added via self-defined cell_fun\nlayer_fun (explained Section 2.9).","code":"\nlibrary(circlize)\ncol_fun = colorRamp2(c(-2, 0, 2), c(\"green\", \"white\", \"red\"))\ncol_fun(seq(-3, 3))## [1] \"#00FF00FF\" \"#00FF00FF\" \"#B1FF9AFF\" \"#FFFFFFFF\" \"#FF9E81FF\" \"#FF0000FF\"\n## [7] \"#FF0000FF\"\nHeatmap(mat, name = \"mat\", col = col_fun)\nmat2 = mat\nmat2[1, 1] = 100000\nHeatmap(mat2, name = \"mat\", col = col_fun, \n    column_title = \"a matrix with outliers\")\nHeatmap(mat, name = \"mat\", col = col_fun, column_title = \"mat\")\nHeatmap(mat/4, name = \"mat\", col = col_fun, column_title = \"mat/4\")\nHeatmap(abs(mat), name = \"mat\", col = col_fun, column_title = \"abs(mat)\")\nHeatmap(mat, name = \"mat\", col = rev(rainbow(10)), \n    column_title = \"set a color vector for a continuous matrix\")\ndiscrete_mat = matrix(sample(1:4, 100, replace = TRUE), 10, 10)\ncolors = structure(1:4, names = c(\"1\", \"2\", \"3\", \"4\")) # black, red, green, blue\nHeatmap(discrete_mat, name = \"mat\", col = colors,\n    column_title = \"a discrete numeric matrix\")\ndiscrete_mat = matrix(sample(letters[1:4], 100, replace = TRUE), 10, 10)\ncolors = structure(1:4, names = letters[1:4])\nHeatmap(discrete_mat, name = \"mat\", col = colors,\n    column_title = \"a discrete character matrix\")\nmat_with_na = mat\nna_index = sample(c(TRUE, FALSE), nrow(mat)*ncol(mat), replace = TRUE, prob = c(1, 9))\nmat_with_na[na_index] = NA\nHeatmap(mat_with_na, name = \"mat\", na_col = \"black\",\n    column_title = \"a matrix with NA values\")\nf1 = colorRamp2(seq(min(mat), max(mat), length = 3), c(\"blue\", \"#EEEEEE\", \"red\"))\nf2 = colorRamp2(seq(min(mat), max(mat), length = 3), c(\"blue\", \"#EEEEEE\", \"red\"), space = \"RGB\")\nHeatmap(mat, name = \"mat1\", col = f1, column_title = \"LAB color space\")\nHeatmap(mat, name = \"mat2\", col = f2, column_title = \"RGB color space\")\nHeatmap(mat, name = \"mat\", border_gp = gpar(col = \"black\", lty = 2),\n    column_title = \"set heatmap borders\")\nHeatmap(mat, name = \"mat\", rect_gp = gpar(col = \"white\", lwd = 2),\n    column_title = \"set cell borders\")\nHeatmap(mat, name = \"mat\", rect_gp = gpar(type = \"none\"),\n    column_title = \"nothing is drawn in the heatmap body\")"},{"path":"a-single-heatmap.html","id":"heatmap-titles","chapter":"2 A Single Heatmap","heading":"2.2 Titles","text":"title heatmap basically tells plot . \nComplexHeatmap package, can set heatmap title either row /\ncolumn. Note time can put e.g. column title either\ntop bottom heatmap.graphic parameters can set row_title_gp column_title_gp\nrespectively. Please remember use gpar() specify graphics\nparameters.Rotations titles can set row_title_rot column_title_rot, \nhorizontal vertical rotations allowed.Row column title supports template used rows columns\nsplit heatmap (multiple row/column titles).\nfunctionality introduced Section 2.7. quick\nexample :can set fill parameter row_title_gp column_title_gp set\nbackground color titles. Since col e.g. row_title_gp controls \ncolor text, border used control color background border.might found space top column title background\ncolored. mainly consistent figure titles ggplot2 figures (make multiple-panel figure mixed\nComplexHeatmap ggplot2 plots).\ncan adjusted setting global parameter ht_opt$TITLE_PADDING.\nuse ht_opt() introduced Section 4.13.Title can set mathematical formulas.complicated text can drawn heatmap title using \ngridtext package. Following plot fives quick example. See Section 10.3.1 examples.","code":"\nHeatmap(mat, name = \"mat\", column_title = \"I am a column title\", \n    row_title = \"I am a row title\")\nHeatmap(mat, name = \"mat\", column_title = \"I am a column title at the bottom\", \n    column_title_side = \"bottom\")\nHeatmap(mat, name = \"mat\", column_title = \"I am a big column title\", \n    column_title_gp = gpar(fontsize = 20, fontface = \"bold\"))\nHeatmap(mat, name = \"mat\", row_title = \"row title\", row_title_rot = 0)\n# code only for demonstration\n# row title would be cluster_1 and cluster_2\nHeatmap(mat, name = \"mat\", row_km = 2, row_title = \"cluster_%s\")\nHeatmap(mat, name = \"mat\", column_title = \"I am a column title\", \n    column_title_gp = gpar(fill = \"red\", col = \"white\", border = \"blue\"))\nht_opt$TITLE_PADDING = unit(c(8.5, 8.5), \"points\")\nHeatmap(mat, name = \"mat\", column_title = \"I am a column title\", \n    column_title_gp = gpar(fill = \"red\", col = \"white\", border = \"blue\"))\nht_opt(RESET = TRUE)\nHeatmap(mat, name = \"mat\", \n    column_title = expression(hat(beta) == (X^t * X)^{-1} * X^t * y)) \nHeatmap(mat, name = \"mat\",\n    column_title = gt_render(\n        paste0(\"Some <span style='color:blue'>blue text **in bold.**<\/span><br>\",\n            \"And *italics text.*<br>And some \",\n            \"<span style='font-size:18pt; color:black'>large<\/span> text.\"), \n        r = unit(2, \"pt\"), \n        padding = unit(c(2, 2, 2, 2), \"pt\")\n    )\n)"},{"path":"a-single-heatmap.html","id":"clustering","chapter":"2 A Single Heatmap","heading":"2.3 Clustering","text":"Clustering might key component heatmap visualization. \nComplexHeatmap package, hierarchical clustering supported great\nflexibility. can specify clustering either :pre-defined distance method (e.g. \"euclidean\" \"pearson\"),distance function,object already contains clustering (hclust dendrogram object\nobject can coerced dendrogram class),clustering function.also possible render dendrograms different colors styles\ndifferent nodes branches better revealing structures dendrogram (e.g.\ndendextend::color_branches()).First, general settings clustering, e.g. whether apply\nclustering show dendrograms, side dendrograms heights \ndendrograms.","code":"\nHeatmap(mat, name = \"mat\", cluster_rows = FALSE) # turn off row clustering\nHeatmap(mat, name = \"mat\", show_column_dend = FALSE) # hide column dendrogram\nHeatmap(mat, name = \"mat\", row_dend_side = \"right\", column_dend_side = \"bottom\")\nHeatmap(mat, name = \"mat\", column_dend_height = unit(4, \"cm\"), \n    row_dend_width = unit(4, \"cm\"))"},{"path":"a-single-heatmap.html","id":"distance-methods","chapter":"2 A Single Heatmap","heading":"2.3.1 Distance methods","text":"Hierarchical clustering performed two steps: calculate distance\nmatrix apply clustering. three ways specify distance metric\nclustering:specify distance pre-defined option. valid values supported\nmethods dist() function \"pearson\", \"spearman\" \n\"kendall\". correlation distance defined 1 - cor(x, y, method).\nbuilt-distance methods allow NA values.self-defined function calculates distance matrix. \nfunction contain one argument. Please note clustering \ncolumns, matrix transposed automatically.self-defined function calculates distance two vectors. \nfunction contain two arguments. Note might slow \nimplemented two nested loop.Based features, can apply clustering robust outliers\nbased pairwise distance. Note set color mapping function\ndon’t want outliers affect colors.can compare two heatmaps without robust distance method:proper distance methods (like methods stringdist\npackage), can also\ncluster character matrix. cell_fun argument introduced Section\n2.9.","code":"\nHeatmap(mat, name = \"mat\", clustering_distance_rows = \"pearson\",\n    column_title = \"pre-defined distance method (1 - pearson)\")\nHeatmap(mat, name = \"mat\", clustering_distance_rows = function(m) dist(m),\n    column_title = \"a function that calculates distance matrix\")\nHeatmap(mat, name = \"mat\", clustering_distance_rows = function(x, y) 1 - cor(x, y),\n    column_title = \"a function that calculates pairwise distance\")\nmat_with_outliers = mat\nfor(i in  1:10) mat_with_outliers[i, i] = 1000\nrobust_dist = function(x, y) {\n    qx = quantile(x, c(0.1, 0.9))\n    qy = quantile(y, c(0.1, 0.9))\n    l = x > qx[1] & x < qx[2] & y > qy[1] & y < qy[2]\n    x = x[l]\n    y = y[l]\n    sqrt(sum((x - y)^2))\n}\nHeatmap(mat_with_outliers, name = \"mat\", \n    col = colorRamp2(c(-2, 0, 2), c(\"green\", \"white\", \"red\")),\n    column_title = \"dist\")\nHeatmap(mat_with_outliers, name = \"mat\", \n    col = colorRamp2(c(-2, 0, 2), c(\"green\", \"white\", \"red\")),\n    clustering_distance_rows = robust_dist,\n    clustering_distance_columns = robust_dist,\n    column_title = \"robust_dist\")\nmat_letters = matrix(sample(letters[1:4], 100, replace = TRUE), 10)\n# distance in the ASCII table\ndist_letters = function(x, y) {\n    x = strtoi(charToRaw(paste(x, collapse = \"\")), base = 16)\n    y = strtoi(charToRaw(paste(y, collapse = \"\")), base = 16)\n    sqrt(sum((x - y)^2))\n}\nHeatmap(mat_letters, name = \"letters\", col = structure(2:5, names = letters[1:4]),\n    clustering_distance_rows = dist_letters, \n    clustering_distance_columns = dist_letters,\n    cell_fun = function(j, i, x, y, w, h, col) { # add text to each grid\n        grid.text(mat_letters[i, j], x, y)\n    })"},{"path":"a-single-heatmap.html","id":"clustering-methods","chapter":"2 A Single Heatmap","heading":"2.3.2 Clustering methods","text":"Method perform hierarchical clustering can specified \nclustering_method_rows clustering_method_columns. Possible methods \nsupported hclust() function.already clustering object function directly returns \nclustering object, can ignore distance settings set cluster_rows\ncluster_columns clustering objects clustering functions. \nclustering function, argument matrix \nreturn hclust dendrogram object object can converted \ndendrogram class.following example, perform clustering methods cluster\npackage either pre-calculated clustering object clustering function:last command :Please note, cluster_rows set function, argument m \ninput mat , cluster_columns, m transpose \nmat.fastcluster::hclust implements faster version hclust(). can set\ncluster_rows cluster_columns use faster version \nhclust().make convinient use faster version hclust() (assuming\nmany heatmaps construct), can set global option. \nusage ht_opt introduced Section\n4.13.one special scenario might already subgroup\nclassification matrix rows columns, want perform\nclustering features subgroup. \ncan split heatmap subgroup variable (see Section\n2.7), can use cluster_within_group() clustering\nfunction generate special dendrogram.example, columns group still clustered, \ndendrogram degenerated flat line. dendrogram columns shows \nhierarchy groups.","code":"\nHeatmap(mat, name = \"mat\", clustering_method_rows = \"single\")\nlibrary(cluster)\nHeatmap(mat, name = \"mat\", cluster_rows = diana(mat),\n   cluster_columns = agnes(t(mat)), column_title = \"clustering objects\")\n# if cluster_columns is set as a function, you don't need to transpose the matrix\nHeatmap(mat, name = \"mat\", cluster_rows = diana,\n   cluster_columns = agnes, column_title = \"clustering functions\")\n# code only for demonstration\nHeatmap(mat, name = \"mat\", cluster_rows = function(m) as.dendrogram(diana(m)),\n    cluster_columns = function(m) as.dendrogram(agnes(m)), \n    column_title = \"clutering functions\")\n# code only for demonstration\nfh = function(x) fastcluster::hclust(dist(x))\nHeatmap(mat, name = \"mat\", cluster_rows = fh, cluster_columns = fh)\n# code only for demonstration\nht_opt$fast_hclust = TRUE\n# now fastcluster::hclust is used in all heatmaps\ngroup = kmeans(t(mat), centers = 3)$cluster\nHeatmap(mat, name = \"mat\", cluster_columns = cluster_within_group(mat, group))"},{"path":"a-single-heatmap.html","id":"render-dendrograms","chapter":"2 A Single Heatmap","heading":"2.3.3 Render dendrograms","text":"want render dendrogram, normally need generate \ndendrogram object render nodePar edgePar parameter \nadvance, send cluster_rows cluster_columns argument.can render dendrogram object dendextend package make\ncustomized visualization dendrogram.row_dend_gp column_dend_gp control global graphics setting \ndendrograms. Note e.g. graphics settings row_dend overwritten \nrow_dend_gp.version 2.5.6, can also add graphics nodes dendrogram setting\nproper nodePar.Currently, points can added nodes, however, need add\ntypes graphics, especially self-defined graphics, just send message \nthink .","code":"\nlibrary(dendextend)\nrow_dend = as.dendrogram(hclust(dist(mat)))\nrow_dend = color_branches(row_dend, k = 2) # `color_branches()` returns a dendrogram object\nHeatmap(mat, name = \"mat\", cluster_rows = row_dend)\nHeatmap(mat, name = \"mat\", cluster_rows = row_dend, \n    row_dend_gp = gpar(col = \"red\"))\nrow_dend = dendrapply(row_dend, function(d) {\n    attr(d, \"nodePar\") = list(cex = 0.8, pch = sample(20, 1), col = rand_color(1))\n    return(d)\n})\nHeatmap(mat, name = \"mat\", cluster_rows = row_dend, row_dend_width = unit(2, \"cm\"))"},{"path":"a-single-heatmap.html","id":"reorder-dendrograms","chapter":"2 A Single Heatmap","heading":"2.3.4 Reorder dendrograms","text":"Heatmap() function, dendrograms reordered make features \nlarger difference separated others (please refer \ndocumentation reorder.dendrogram()). difference (called\nweight) measured row means row dendrogram \ncolumn means column dendrogram. row_dend_reorder \ncolumn_dend_reorder control whether apply dendrogram reordering \nvalue set logical. two arguments also control weight \nreordering set numeric vectors (sent wts\nargument reorder.dendrogram()). reordering can turned \nsetting e.g. row_dend_reorder = FALSE.default, dendrogram reordering turned \ncluster_rows/cluster_columns set logical value clustering\nfunction. turned cluster_rows/cluster_columns set \nclustering object.Compare following two heatmaps:many methods reordering dendrograms, e.g. dendsort\npackage. Basically, methods still return dendrogram \nreordered, thus, can firstly generate row column dendrogram based \ndata matrix, reorder certain method, assign back \ncluster_rows cluster_columns.Compare following two reorderings dimensions. Can tell better?","code":"\nm2 = matrix(1:100, nr = 10, byrow = TRUE)\nHeatmap(m2, name = \"mat\", row_dend_reorder = FALSE, column_title = \"no reordering\")\nHeatmap(m2, name = \"mat\", row_dend_reorder = TRUE, column_title = \"apply reordering\")\nHeatmap(mat, name = \"mat\", column_title = \"default reordering\")\n\nlibrary(dendsort)\nrow_dend = dendsort(hclust(dist(mat)))\ncol_dend = dendsort(hclust(dist(t(mat))))\nHeatmap(mat, name = \"mat\", cluster_rows = row_dend, cluster_columns = col_dend,\n    column_title = \"reorder by dendsort\")"},{"path":"a-single-heatmap.html","id":"row-and_column_orders","chapter":"2 A Single Heatmap","heading":"2.4 Set row and column orders","text":"Clustering used adjust row orders column orders heatmap, \ncan still set order manually row_order column_order. \ne.g. row_order set, row clustering turned default.orders can character vectors just shuffles matrix row names column names.Note row_dend_reorder row_order two different things.\nrow_dend_reorder applied dendrogram. node \ndendrogram, rotating two branches actually gives identical dendrogram,\nthus, reordering dendrogram automatically rotating sub-dendrogram \nevery node can help separate features show\ndifference. comparison, row_order simply applied matrix\nnormally dendrograms turned .","code":"\nHeatmap(mat, name = \"mat\", \n    row_order = order(as.numeric(gsub(\"row\", \"\", rownames(mat)))), \n    column_order = order(as.numeric(gsub(\"column\", \"\", colnames(mat)))),\n    column_title = \"reorder matrix\")\nHeatmap(mat, name = \"mat\", row_order = sort(rownames(mat)), \n    column_order = sort(colnames(mat)),\n    column_title = \"reorder matrix by row/column names\")"},{"path":"a-single-heatmap.html","id":"heatmap-seriation","chapter":"2 A Single Heatmap","heading":"2.5 Seriation","text":"Seriation interesting technique ordering matrix (see \ninteresting post: http://nicolas.kruchten.com/content/2018/02/seriation/). \npowerful seriation\npackage\nimplements quite lot methods seriation. Since easy extract\nrow orders column orders object returned core function\nseriate() seriation package, can directly assigned \nrow_order column_order make heatmap.first example demonstrates directly applying seriate() matrix.\nSince \"BEA_TSP\" method allows non-negative matrix, modify \nmatrix max(mat) - mat.can apply seriate() distance matrix. Now order rows\ncolumns needs calcualted separatedly distance matrix\nneeds calculated separatedly columns rows.seriation methods also contain hierarchical clustering information.\nLet’s try:o1 o2 actually mainly composed hclust objects:orders using hclust$order get_order().can add dendrograms heatmap.use seriate() function, please refer seriation\npackage.","code":"\nlibrary(seriation)\no = seriate(max(mat) - mat, method = \"BEA_TSP\")\nHeatmap(max(mat) - mat, name = \"mat\", \n    row_order = get_order(o, 1), column_order = get_order(o, 2),\n    column_title = \"seriation by BEA_TSP method\")\no1 = seriate(dist(mat), method = \"TSP\")\no2 = seriate(dist(t(mat)), method = \"TSP\")\nHeatmap(mat, name = \"mat\", row_order = get_order(o1), column_order = get_order(o2),\n    column_title = \"seriation from the distance matrix\")\no1 = seriate(dist(mat), method = \"GW\")\no2 = seriate(dist(t(mat)), method = \"GW\")\nclass(o1[[1]])## [1] \"ser_permutation_vector\" \"hclust\"\no1[[1]]$order##  [1]  5  2  4 17 16  7 18 10 14 15  1  3  8 11  9 13  6 12\n# should be the same as the previous one\nget_order(o1)##  [1]  5  2  4 17 16  7 18 10 14 15  1  3  8 11  9 13  6 12\nHeatmap(mat, name = \"mat\", cluster_rows = as.dendrogram(o1[[1]]), \n    cluster_columns = as.dendrogram(o2[[1]]))"},{"path":"a-single-heatmap.html","id":"dimension-names","chapter":"2 A Single Heatmap","heading":"2.6 Dimension labels","text":"row names column names drawn right bottom sides \nheatmap default. Side, visibility graphics parameters dimension\nnames can set follows:rotation column names can set column_names_rot:row names column names long,\nrow_names_max_width column_names_max_height can used set \nmaximal space . default maximal space row names column\nnames 6 cm. following code, max_text_width() helper function\nquick calculate maximal width vector text.Instead directly using row/column names matrix, can also\nprovide another character vector corresponds rows columns \nset row_labels column_labels. useful don’t\nneed change dimension names matrix change labels \nheatmap can directly provide new labels.one typical scenario row_labels column_labels \nuseful. gene expression analysis, might use Ensembl ID gene\nID used row names gene expression matrix. However, \nEnsembl ID indexing Ensembl database human\nreading. Instead, prefer put gene symbols heatmap \nrow names easier read. , need assign \ncorresponding gene symbols row_labels without modifying original\nmatrix.second advantage row_labels column_labels allows duplicated\nlabels, duplicated row names column names allowed \nmatrix.Following gives simple example put letters row labels column\nlabels:third advantage mathematical expression can used row names \nheatmap.fourth advantage can construct complicated labels gridtext package.\nfollowing quick example. examples can found Section 10.3.1.Internally, row names columns names actually implemented \nanno_text() function (Section 3.14), words, \ntreated special cases text annotations.","code":"\nHeatmap(mat, name = \"mat\", row_names_side = \"left\", row_dend_side = \"right\", \n    column_names_side = \"top\", column_dend_side = \"bottom\")\nHeatmap(mat, name = \"mat\", show_row_names = FALSE)\nHeatmap(mat, name = \"mat\", row_names_gp = gpar(fontsize = 20))\nHeatmap(mat, name = \"mat\", \n    row_names_gp = gpar(col = c(rep(\"red\", 10), rep(\"blue\", 8))))\nHeatmap(mat, name = \"mat\", \n    row_names_centered = TRUE, column_names_centered = TRUE)\nHeatmap(mat, name = \"mat\", column_names_rot = 45)\nHeatmap(mat, name = \"mat\", column_names_rot = 45, column_names_side = \"top\",\n    column_dend_side = \"bottom\")\nmat2 = mat\nrownames(mat2)[1] = paste(c(letters, LETTERS), collapse = \"\")\nHeatmap(mat2, name = \"mat\", row_title = \"default row_names_max_width\")\nHeatmap(mat2, name = \"mat\", row_title = \"row_names_max_width as length of a*\",\n    row_names_max_width = max_text_width(\n        rownames(mat2), \n        gp = gpar(fontsize = 12)\n    ))\n# use a named vector to make sure the correspondance between \n# row names and row labels is correct\nrow_labels = structure(paste0(letters[1:24], 1:24), names = paste0(\"row\", 1:24))\ncolumn_labels = structure(paste0(LETTERS[1:24], 1:24), names = paste0(\"column\", 1:24))\nrow_labels##  row1  row2  row3  row4  row5  row6  row7  row8  row9 row10 row11 row12 row13 \n##  \"a1\"  \"b2\"  \"c3\"  \"d4\"  \"e5\"  \"f6\"  \"g7\"  \"h8\"  \"i9\" \"j10\" \"k11\" \"l12\" \"m13\" \n## row14 row15 row16 row17 row18 row19 row20 row21 row22 row23 row24 \n## \"n14\" \"o15\" \"p16\" \"q17\" \"r18\" \"s19\" \"t20\" \"u21\" \"v22\" \"w23\" \"x24\"\nHeatmap(mat, name = \"mat\", row_labels = row_labels[rownames(mat)], \n    column_labels = column_labels[colnames(mat)])\nHeatmap(mat, name = \"mat\", row_labels = expression(alpha, beta, gamma, \n    delta, epsilon, zeta, eta, theta, iota, kappa, lambda, mu, nu, xi, \n    omicron, pi, rho, sigma)\n)\nHeatmap(mat, name = \"mat\",\n    row_labels = gt_render(letters[1:18], padding = unit(c(2, 10, 2, 10), \"pt\")),\n    row_names_gp = gpar(box_col = rep(c(\"red\", \"green\"), times = 9)))"},{"path":"a-single-heatmap.html","id":"heatmap-split","chapter":"2 A Single Heatmap","heading":"2.7 Heatmap split","text":"One major advantage ComplexHeatmap package supports splitting \nheatmap rows columns better group features additionally\nhighlight patterns.Following arguments control splitting: row_km, row_split, column_km,\ncolumn_split. following, call sub-clusters generated splitting \n“slices.”","code":""},{"path":"a-single-heatmap.html","id":"split-by-kmeans-clustering","chapter":"2 A Single Heatmap","heading":"2.7.1 Split by k-means clustering","text":"row_km column_km apply k-means partitioning.Row splitting column splitting can performed simultaneously.might notice dashed lines row column dendrograms,\nexplained Section 2.7.2 (last paragraph).Heatmap() internally calls kmeans() random start points, \nresults , cases, generating different clusters repeated runs.\nget rid problem, row_km_repeats column_km_repeats can \nset number larger 1 run kmeans() multiple times final\nconsensus k-means clustering used. Please note final number clusters\nform consensus k-means might smaller number set row_km \ncolumn_km.Note want k-means clustering completely reproducible, must explicitly\nset random seed:","code":"\nHeatmap(mat, name = \"mat\", row_km = 2)\nHeatmap(mat, name = \"mat\", column_km = 3)\nHeatmap(mat, name = \"mat\", row_km = 2, column_km = 3)\n# of course, it will be a little bit slower\nHeatmap(mat, name = \"mat\", \n    row_km = 2, row_km_repeats = 100,\n    column_km = 3, column_km_repeats = 100)\nset.seed(123)\nHeatmap(..., row_km = ..., column_km = ...)"},{"path":"a-single-heatmap.html","id":"split-by-categorical-variables","chapter":"2 A Single Heatmap","heading":"2.7.2 Split by categorical variables","text":"generally, row_split column_split can set categorical\nvector data frame different combinations levels split \nrows/columns heatmap. control order slices \nintroduced Section 2.7.4.Actually, k-means clustering just generates vector cluster classes \nappends row_split column_split. row_km/column_km can used\nmixed row_split column_split.:happy default k-means partition, easy use\npartition methods just assigning partition vector \nrow_split/column_split.row_order column_order set, row/column slice, still\nordered.Character matrix can split row_split/column_split argument.row_km/column_km set row_split/column_split set \nvector data frame, hierarchical clustering first applied slice\ngenerates k dendrograms, parent dendrogram generated based\nmean values slice. height parent dendrogram \nadjusted adding maximal height dendrograms child\nslices parent dendrogram added top child dendrograms\nform single global dendrogram. see dashed lines \ndendrograms previous heatmaps. used discriminate parent dendrogram\nchild dendrograms, alert users calculated different\nways. dashed lines can removed setting show_parent_dend_line = FALSE Heatmap(), set global option:\nht_opt$show_parent_dend_line = FALSE, suggested .","code":"\n# split by a vector\nHeatmap(mat, name = \"mat\", \n    row_split = rep(c(\"A\", \"B\"), 9), column_split = rep(c(\"C\", \"D\"), 12))\n# split by a data frame\nHeatmap(mat, name = \"mat\", \n    row_split = data.frame(rep(c(\"A\", \"B\"), 9), rep(c(\"C\", \"D\"), each = 9)))\n# split on both dimensions\nHeatmap(mat, name = \"mat\", row_split = factor(rep(c(\"A\", \"B\"), 9)),\n    column_split = factor(rep(c(\"C\", \"D\"), 12)))\nHeatmap(mat, name = \"mat\", row_split = rep(c(\"A\", \"B\"), 9), row_km = 2)\n# code only for demonstration\ncl = kmeans(mat, centers = 2)$cluster\n# classes from k-means are always put as the first column in `row_split`\nHeatmap(mat, name = \"mat\", row_split = cbind(cl, rep(c(\"A\", \"B\"), 9)))\npa = cluster::pam(mat, k = 3)\nHeatmap(mat, name = \"mat\", row_split = paste0(\"pam\", pa$clustering))\n# remember when `row_order` is set, row clustering is turned off\nHeatmap(mat, name = \"mat\", row_order = 18:1, row_km = 2)\n# split by the first column in `discrete_mat`\nHeatmap(discrete_mat, name = \"mat\", col = 1:4, row_split = discrete_mat[, 1])\nHeatmap(mat, name = \"mat\", row_km = 2, column_km = 3, \n    show_parent_dend_line = FALSE)"},{"path":"a-single-heatmap.html","id":"spilt-by-dendrogram","chapter":"2 A Single Heatmap","heading":"2.7.3 Split by dendrogram","text":"second scenario splitting users may still want keep \nglobal dendrogram generated complete matrix. case, row_split/column_split can \nset single number apply cutree() row/column\ndendrogram. works cluster_rows/cluster_columns set TRUE\nassigned hclust/dendrogram object.case, dendrogram still original one, except \npositions dendrogram leaves slightly adjusted gaps \nslices. (dashed lines, dendrogram calcualted\ncomplete one parent dendrogram child dendrograms.)want combine splitting cutree() categorical\nvariables, need generate partitions cutree() first\nplace, append e.g. row_split data frame send \nrow_split argument.","code":"\nHeatmap(mat, name = \"mat\", row_split = 2, column_split = 3)\ndend = as.dendrogram(hclust(dist(mat)))\ndend = color_branches(dend, k = 2)\nHeatmap(mat, name = \"mat\", cluster_rows = dend, row_split = 2)\n# code only for demonstration\nsplit = data.frame(cutree(hclust(dist(mat)), k = 2), rep(c(\"A\", \"B\"), 9))\nHeatmap(mat, name = \"mat\", row_split = split)"},{"path":"a-single-heatmap.html","id":"order-of-slices","chapter":"2 A Single Heatmap","heading":"2.7.4 Order of slices","text":"row_split/column_split set categorical variable (vector \ndata frame) row_km/column_km set, default, additional\nclustering applied mean slices show hierarchy slice\nlevel. scenario, precisely control order slices\ncontrolled clustering slices.Nevertheless, can set cluster_row_slices cluster_column_slices \nFALSE turn clustering slices, now can precisely\ncontrol order slices.slice clustering, order slice can controlled\nlevels variable row_split/column_split (case, \nvariable factor). variables characters, default\norder unique(row_split) unique(column_split). Compare following\nheatmaps:Also can see third heatmap, cluster_row_slices cluster_column_slices\nset FALSE, dendrogram slice level.","code":"\nHeatmap(mat, name = \"mat\", \n    row_split = rep(LETTERS[1:3], 6), column_split = rep(letters[1:6], 4))\n# clustering is similar as previous heatmap with branches \n# in some nodes in the dendrogram flipped\nHeatmap(mat, name = \"mat\", \n    row_split = factor(rep(LETTERS[1:3], 6), levels = LETTERS[3:1]),\n    column_split = factor(rep(letters[1:6], 4), levels = letters[6:1]))\n# now the order is exactly what we set\nHeatmap(mat, name = \"mat\", \n    row_split = factor(rep(LETTERS[1:3], 6), levels = LETTERS[3:1]),\n    column_split = factor(rep(letters[1:6], 4), levels = letters[6:1]),\n    cluster_row_slices = FALSE, \n    cluster_column_slices = FALSE)"},{"path":"a-single-heatmap.html","id":"titles-for-splitting","chapter":"2 A Single Heatmap","heading":"2.7.5 Titles for splitting","text":"row_split/column_split set single number, one\ncategorical variable, row_km/column_km set /\nrow_split/column_split set categorical variables, \nmultiple categorical variables. default, titles form \n\"level1,level2,...\" corresponds every combination levels \ncategorical variables. titles splitting can controlled “\ntemplate.”ComplexHeatmap supports three types templates. first one \nsprintf() %s replaced corresponding level. \nfollowing example, since combinations split c(\"\", \"C\"), c(\"\", \"D\"), c(\"B\", \"C\")\nc(\"B\", \"D\"), row_title set %s|%s, four row titles \n|C, |D, B|C, B|D.sprintf() template, can put levels ,B,C,D\ntitle, C,D always ,B (.e. always ,C \n,D). However, making heatmap, might want put \nmeaningful text instead internal levels. know \ncorrespond text level, can add following two template\nmethods.following two template methods, special marks used mark R\ncode executable (called variable interpolation code\nextracted executed returned value put back string).\ntwo types template marks @{} {}. first one \nGetoptLong package already installed install \nComplexHeatmap package second one glue package \nneed install first.internal variable x use use latter two\ntemplates. x just simple vector contains current category levels\n(e.g. c(\"\", \"C\")).row title rotated default, can set row_title_rot = 0 make\nhorizontal:row_split/column_split set number, can also use template\nadjust titles slices.know final number row slices, can directly set vector \ntitles row_title. careful number row slices always\nidentical n_level_1 * n_level_2 * ....length row_title specified single string, like\nsingle title slices.still want titles slice, also global title, can \nfollows.Actually row_title used draw() function row title \nheatmap list (although example one heatmap). draw()\nfunction heatmap list introduced Chapter\n4.row_title set NULL, row title drawn.rules also work column titles slices.","code":"\nsplit = data.frame(rep(c(\"A\", \"B\"), 9), rep(c(\"C\", \"D\"), each = 9))\nHeatmap(mat, name = \"mat\", row_split = split, row_title = \"%s|%s\")\n# We only run the code for the first heatmap\nmap = c(\"A\" = \"aaa\", \"B\" = \"bbb\", \"C\" = \"333\", \"D\" = \"444\")\nHeatmap(mat, name = \"mat\", row_split = split, \n    row_title = \"@{map[ x[1] ]}|@{map[ x[2] ]}\")\nHeatmap(mat, name = \"mat\", row_split = split, \n    row_title = \"{map[ x[1] ]}|{map[ x[2] ]}\")\nHeatmap(mat, name = \"mat\", row_split = split, row_title = \"%s|%s\", \n    row_title_rot = 0)\nHeatmap(mat, name = \"mat\", row_split = 2, row_title = \"cluster_%s\")\n# we know there are four slices\nHeatmap(mat, name = \"mat\", row_split = split, \n    row_title = c(\"top_slice\", \"middle_top_slice\", \"middle_bottom_slice\", \"bottom_slice\"),\n    row_title_rot = 0)\nHeatmap(mat, name = \"mat\", row_split = split, row_title = \"there are four slices\")\nht = Heatmap(mat, name = \"mat\", row_split = split, row_title = \"%s|%s\")\n# This row_title is actually a heatmap-list-level row title\ndraw(ht, row_title = \"I am a row title\")\nHeatmap(mat, name = \"mat\", row_split = split, row_title = NULL)"},{"path":"a-single-heatmap.html","id":"graphic-parameters-for-splitting","chapter":"2 A Single Heatmap","heading":"2.7.6 Graphic parameters for splitting","text":"splitting applied rows/columns, graphic parameters row/column\ntitle row/column names can specified length number \nslices.","code":"\n# by defalt, there no space on the top of the title, here we add 4pt to the top.\n# it can be reset by `ht_opt(RESET = TRUE)`\nht_opt$TITLE_PADDING = unit(c(4, 4), \"points\")\nHeatmap(mat, name = \"mat\", \n    row_km = 2, \n    row_title_gp = gpar(col = c(\"red\", \"blue\"), font = 1:2),\n    row_names_gp = gpar(col = c(\"green\", \"orange\"), fontsize = c(10, 14)),\n    column_km = 3, \n    column_title_gp = gpar(fill = c(\"red\", \"blue\", \"green\"), font = 1:3),\n    column_names_gp = gpar(col = c(\"green\", \"orange\", \"purple\"), \n        fontsize = c(10, 14, 8))\n)"},{"path":"a-single-heatmap.html","id":"gaps-between-slices","chapter":"2 A Single Heatmap","heading":"2.7.7 Gaps between slices","text":"space gaps row/column slices can controlled \nrow_gap/column_gap. value can single unit vector units.heatmap border added setting border = TRUE, border every\nslice added.set gap size zero, heatmap look like partitioned \nvertical horizontal lines.","code":"\nHeatmap(mat, name = \"mat\", row_km = 3, row_gap = unit(5, \"mm\"))\nHeatmap(mat, name = \"mat\", row_km = 3, row_gap = unit(c(2, 4), \"mm\"))\nHeatmap(mat, name = \"mat\", row_km = 3, row_gap = unit(c(2, 4), \"mm\"),\n    column_km = 3, column_gap = unit(c(2, 4), \"mm\"))\nHeatmap(mat, name = \"mat\", row_km = 2, column_km = 3, border = TRUE)\nHeatmap(mat, name = \"mat\", row_km = 2, column_km = 3, \n    row_gap = unit(0, \"mm\"), column_gap = unit(0, \"mm\"), border = TRUE)"},{"path":"a-single-heatmap.html","id":"split-heatmap-annotations","chapter":"2 A Single Heatmap","heading":"2.7.8 Split heatmap annotations","text":"heatmap split, heatmap components split accordingly.\nFollowing gives simple example heatmap annotation \nintroduced Chapter 3.","code":"\nHeatmap(mat, name = \"mat\", row_km = 2, column_km = 3,\n    top_annotation = HeatmapAnnotation(foo1 = 1:24, bar1 = anno_points(runif(24))),\n    right_annotation = rowAnnotation(foo2 = 18:1, bar2 = anno_barplot(runif(18)))\n)"},{"path":"a-single-heatmap.html","id":"heatmap-as-raster-image","chapter":"2 A Single Heatmap","heading":"2.8 Heatmap as raster image","text":"produce -called “high quality figures,” normally save figures\nvector graphics \nformat e.g. pdf svg. vector graphics basically store details \nevery single graphic elements, thus, heatmap made huge matrix \nsaved vector graphics, final file size big. \nhand, visualizing e.g. pdf file screen, multiple grids \nheatmap actually map single pixels, due limited size \nscreen. Thus, need ways effectively reduce original image \nnecessary store complete matrix heatmap.Rasterization way covnert vector graphics matrix colors.\ncase, image represented matrix RGB values, \ncalled raster image. \nheatmap larger size screen pixels current\ngraphics devices can support, can convert heatmap reduce , \nsaving form color matrix dimension device.Let’s assume matrix \\(n_r\\) rows \\(n_c\\) columns. drawn \ncertain graphics device, e.g. -screen device, corresponding heatmap\nbody \\(p_r\\) \\(p_c\\) pixels (points) rows columns,\nrespectively. \\(n_r > p_r\\) /\\(n_c > p_c\\), multiple values \nmatrix mapped single pixels. need reduce \\(n_r\\) /\\(n_c\\)\nlarger \\(p_r\\) /\\(p_c\\).make simple, assume \\(n_r > p_r\\) \\(n_c > p_c\\). \nprinciple basically scenarios one dimension \nmatrix larger device.ComplexHeatmap version 2.5.4, following three implementations \nimage rasterization. Note implementation little bit different \nearlier versions (course, better earlier versions).First image\n(specific format, e.g. png jpeg) \\((p_r \\cdot ) \\times (p_c \\cdot )\\) resolution saved temporary file (e.g., png() jpeg()) \\(\\) zooming\nfactor, next read back raster object e.g.\npng::readPNG() jpeg::readJPEG(), later raster object \nfilled heatmap body grid::grid.raster(). can say, \nrasterization done raster image devices (png() jpeg()).\ntype rasterization automatically turned (magick package \ninstalled) number rows columns exceeds 2000 (\nsee message. won’t happen silently). can also manually\ncontrolled setting use_raster argument:First image\n(specific format, e.g. png jpeg) \\((p_r \\cdot ) \\times (p_c \\cdot )\\) resolution saved temporary file (e.g., png() jpeg()) \\(\\) zooming\nfactor, next read back raster object e.g.\npng::readPNG() jpeg::readJPEG(), later raster object \nfilled heatmap body grid::grid.raster(). can say, \nrasterization done raster image devices (png() jpeg()).type rasterization automatically turned (magick package \ninstalled) number rows columns exceeds 2000 (\nsee message. won’t happen silently). can also manually\ncontrolled setting use_raster argument:zooming factor controlled raster_quality argument. value larger\n1 generates files larger size.Simply reduce original matrix \\(p_r \\times p_c\\) now single values can\ncorrespond single pixels. reduction, user-defined function applied summarize\nsub-matrices.\ncan set raster_resize_mat argument:Simply reduce original matrix \\(p_r \\times p_c\\) now single values can\ncorrespond single pixels. reduction, user-defined function applied summarize\nsub-matrices.can set raster_resize_mat argument:temporary image complete resolution \\(n_r \\times n_c\\) first generated, \nmagick::image_resize() used reduce image size \\(p_r \\times p_c\\). Finally reduced image read raster object filled \nheatmap body. magick provides lot methods \n“resizing”/“scaling” image, called “filtering methods”\nterm magick. filtering\nmethods\ncan obtained magick::filter_types().\ntype rasterization can truned setting raster_by_magick = TRUE\nchoosing proper raster_magick_filter.temporary image complete resolution \\(n_r \\times n_c\\) first generated, \nmagick::image_resize() used reduce image size \\(p_r \\times p_c\\). Finally reduced image read raster object filled \nheatmap body. magick provides lot methods \n“resizing”/“scaling” image, called “filtering methods”\nterm magick. filtering\nmethods\ncan obtained magick::filter_types().type rasterization can truned setting raster_by_magick = TRUE\nchoosing proper raster_magick_filter.type temporary image controlled raster_device argument. supported\n“raster devices” : png, CairoPNG, agg_png, jpeg, tiff, CairoJPEG \nCairoTIFF. CairoPNG taken default raster device (Cairo package installed) previously\ndefault device png occasionally produces white vertical horizontal lines \nraster image.ComplexHeatmap, use_raster default turned number \nrows columns 2000 matrix.following parts section, compare visual difference\ndifferent image rasterization methods. following example Guillaume Devailly’s simulated\ndata \nsmall adaptations. example shows enrichment pattern top center plot.folowing examples, won’t show code making heatmaps \nmany heatmaps specific settings already written \nrow title heatmap. set color mapping heatmaps, \ncan see different rasterizations change original patterns.comparison, generated many heatmaps. can categoried three groups, corresponded \nthree rasterization methods mentioned previously.png()/CairoPNG()/agg_png()/jpeg(): Rasterization method 1. First row following heatmaps.raster_resize_mat = *: Rasterization method 2, different summary methods. Second row following heatmaps.filter = *: Rasterization method 3, different filterring method. string filter\nraster_magick_filter. truncated row title won’t cut plot regions.examples image rasteration can found blog post: Rasterization ComplexHeatmap.According examples shown, say\nrasterization magick package performs better, thus, default, \nComplexHeatmap, rasterization done magick (\"Lanczos\"\ndefault filter method) magick installed, uses\nCairoPNG() friendly message printed suggest users install\nmagick.Following example compares PDF file size raster images different\nraster devices.can see png-family methods generate smaller file size.","code":"\nHeatmap(..., use_raster = TRUE)\nHeatmap(..., use_raster = TRUE, raster_quality = 5)\n# the default summary function is mean()\nHeatmap(..., use_raster = TRUE, raster_resize_mat = TRUE)\n# use max() as the summary function\nHeatmap(..., use_raster = TRUE, raster_resize_mat = max)\n# randomly pick one\nHeatmap(..., use_raster = TRUE, raster_resize_mat = function(x) sample(x, 1))\nHeatmap(..., use_raster = TRUE, raster_by_magick = TRUE)\nHeatmap(..., use_raster = TRUE, raster_by_magick = TRUE, raster_magick_filter = ...)\nlibrary(GetoptLong)\nset.seed(123)\nmat2 = matrix(rnorm(10000*100), ncol = 100)\npdf(qq(\"heatmap_no_rasteration.pdf\"), width = 8, height = 8)\nht = Heatmap(mat2, cluster_rows = FALSE, cluster_columns = FALSE, use_raster = FALSE)\ndraw(ht)\ndev.off()\n\nall_devices = c(\"png\", \"CairoPNG\", \"agg_png\", \"jpeg\", \"CairoJPEG\")\nfor(device in all_devices) {\n    pdf(qq(\"heatmap_@{device}.pdf\"), width = 8, height = 8)\n    ht = Heatmap(mat2, cluster_rows = FALSE, cluster_columns = FALSE, use_raster = TRUE, \n        raster_device = device)\n    draw(ht)\n    dev.off()\n}\nall_files = qq(\"heatmap_@{all_devices}.pdf\", collapse = FALSE)\nall_files = c(\"heatmap_no_rasteration.pdf\", all_files)\nfs = file.size(all_files)\nnames(fs) = all_files\nsapply(fs, function(x) paste(round(x/1024), \"KB\"))## heatmap_no_rasteration.pdf            heatmap_png.pdf \n##                  \"6394 KB\"                   \"175 KB\" \n##       heatmap_CairoPNG.pdf        heatmap_agg_png.pdf \n##                   \"177 KB\"                   \"308 KB\" \n##           heatmap_jpeg.pdf      heatmap_CairoJPEG.pdf \n##                   \"667 KB\"                   \"677 KB\""},{"path":"a-single-heatmap.html","id":"customize-the-heatmap-body","chapter":"2 A Single Heatmap","heading":"2.9 Customize the heatmap body","text":"heatmap body can self-defined add types graphics. default\nheatmap body composed matrix small rectangles (might \ncalled grids parts documentation, let’s call “cells”\n) different filled colors. However, also possible add \ngraphics symbols additional layers heatmap. two\narguments cell_fun layer_fun user-defined\nfunctions.later chapter, introduce OncoPrint (Chapter 7), UpSet plot (Chapter 8)\n3D heatmap (Chapter 12). implemented cell_fun/layer_fun.","code":""},{"path":"a-single-heatmap.html","id":"cell-fun","chapter":"2 A Single Heatmap","heading":"2.9.1 cell_fun","text":"cell_fun draws cell repeatedly, internally executed two\nnested loops, layer_fun vectorized version cell_fun.\ncell_fun easier understand layer_fun much faster execute\ncustomizable.cell_fun expects function 7 arguments (argument names can \ndifferent following, order must ), :j: column index matrix. Column index corresponds x-direction\nviewport, ’s j put first argument.: row index matrix.x: x coordinate middle point cell measured \nviewport heatmap body.y: y coordinate middle point cell measured \nviewport heatmap body.width: width cell. value unit(1/ncol(sub_mat), \"npc\")\nsub_mat correspond sub-matrix row splitting column\nsplitting.height: height cell. value unit(1/nrow(sub_mat), \"npc\").fill: color cell.values seven arguments automatically sent function \nexecuted cell.common use add values matrix onto heatmap:can also choose add text cells positive values:can split heatmap without anything extra cell_fun:following example, make heatmap shows correlation matrix similar\ncorrplot package:may see previous plot, setting non-standard parameter\nrect_gp = gpar(type = \"none\"), clustering performed nothing \ndrawn heatmap body.One last example visualize GO\ngame. input data takes\nrecords moves game.convert matrix:Black white stones put based values matrix:Go game example, actually self-defined legend. introduced Section 5 details.","code":"\nsmall_mat = mat[1:9, 1:9]\ncol_fun = colorRamp2(c(-2, 0, 2), c(\"green\", \"white\", \"red\"))\nHeatmap(small_mat, name = \"mat\", col = col_fun,\n    cell_fun = function(j, i, x, y, width, height, fill) {\n        grid.text(sprintf(\"%.1f\", small_mat[i, j]), x, y, gp = gpar(fontsize = 10))\n})\nHeatmap(small_mat, name = \"mat\",  col = col_fun,\n    cell_fun = function(j, i, x, y, width, height, fill) {\n        if(small_mat[i, j] > 0)\n            grid.text(sprintf(\"%.1f\", small_mat[i, j]), x, y, gp = gpar(fontsize = 10))\n})\nHeatmap(small_mat, name = \"mat\", col = col_fun,\n    row_km = 2, column_km = 2,\n    cell_fun = function(j, i, x, y, width, height, fill) {\n        grid.text(sprintf(\"%.1f\", small_mat[i, j]), x, y, gp = gpar(fontsize = 10))\n})\ncor_mat = cor(small_mat)\nod = hclust(dist(cor_mat))$order\ncor_mat = cor_mat[od, od]\nnm = rownames(cor_mat)\ncol_fun = circlize::colorRamp2(c(-1, 0, 1), c(\"green\", \"white\", \"red\"))\n# `col = col_fun` here is used to generate the legend\nHeatmap(cor_mat, name = \"correlation\", col = col_fun, rect_gp = gpar(type = \"none\"), \n    cell_fun = function(j, i, x, y, width, height, fill) {\n        grid.rect(x = x, y = y, width = width, height = height, \n            gp = gpar(col = \"grey\", fill = NA))\n        if(i == j) {\n            grid.text(nm[i], x = x, y = y)\n        } else if(i > j) {\n            grid.circle(x = x, y = y, r = abs(cor_mat[i, j])/2 * min(unit.c(width, height)), \n                gp = gpar(fill = col_fun(cor_mat[i, j]), col = NA))\n        } else {\n            grid.text(sprintf(\"%.1f\", cor_mat[i, j]), x, y, gp = gpar(fontsize = 10))\n        }\n    }, cluster_rows = FALSE, cluster_columns = FALSE,\n    show_row_names = FALSE, show_column_names = FALSE)\nstr = [1615 chars quoted with '\"']\nstr = gsub(\"\\\\n\", \"\", str)\nstep = strsplit(str, \";\")[[1]]\ntype = gsub(\"(B|W).*\", \"\\\\1\", step)\nrow = gsub(\"(B|W)\\\\[(.).\\\\]\", \"\\\\2\", step)\ncolumn = gsub(\"(B|W)\\\\[.(.)\\\\]\", \"\\\\2\", step)\n\ngo_mat = matrix(nrow = 19, ncol = 19)\nrownames(go_mat) = letters[1:19]\ncolnames(go_mat) = letters[1:19]\nfor(i in seq_along(row)) {\n    go_mat[row[i], column[i]] = type[i]\n}\ngo_mat[1:4, 1:4]##   a   b   c   d  \n## a NA  NA  NA  \"W\"\n## b \"W\" \"W\" \"W\" \"B\"\n## c \"B\" \"B\" \"W\" \"W\"\n## d \"B\" \"W\" \"B\" \"W\"\nht = Heatmap(go_mat, name = \"go\", rect_gp = gpar(type = \"none\"),\n    cell_fun = function(j, i, x, y, w, h, col) {\n        grid.rect(x, y, w, h, gp = gpar(fill = \"#dcb35c\", col = NA))\n        if(i == 1) {\n            grid.segments(x, y-h*0.5, x, y)\n        } else if(i == nrow(go_mat)) {\n            grid.segments(x, y, x, y+h*0.5)\n        } else {\n            grid.segments(x, y-h*0.5, x, y+h*0.5)\n        }\n        if(j == 1) {\n            grid.segments(x, y, x+w*0.5, y)        \n        } else if(j == ncol(go_mat)) {\n            grid.segments(x-w*0.5, y, x, y)\n        } else {\n            grid.segments(x-w*0.5, y, x+w*0.5, y)\n        }\n\n        if(i %in% c(4, 10, 16) & j %in% c(4, 10, 16)) {\n            grid.points(x, y, pch = 16, size = unit(2, \"mm\"))\n        }\n                \n        r = min(unit.c(w, h))*0.45\n        if(is.na(go_mat[i, j])) {\n        } else if(go_mat[i, j] == \"W\") {\n            grid.circle(x, y, r, gp = gpar(fill = \"white\", col = \"white\"))\n        } else if(go_mat[i, j] == \"B\") {\n            grid.circle(x, y, r, gp = gpar(fill = \"black\", col = \"black\"))\n        }\n    },\n    col = c(\"B\" = \"black\", \"W\" = \"white\"),\n    show_row_names = FALSE, show_column_names = FALSE,\n    column_title = \"One famous GO game\",\n    show_heatmap_legend = FALSE\n)\nlgd = Legend(title = \"Players\", labels = c(\"player1\", \"player2\"),\n    type = \"points\", legend_gp = gpar(col = c(\"black\", \"white\")),\n    size = unit(0.45, \"snpc\"), background = \"#dcb35c\")\ndraw(ht, heatmap_legend_list = lgd)"},{"path":"a-single-heatmap.html","id":"layer-fun","chapter":"2 A Single Heatmap","heading":"2.9.2 layer_fun","text":"tried previous code Go game, might see generation \nplot little bit slow fragments plot come one .\ncell_fun applied every cell separately. section,\nintroduce layer_fun vectorized version cell_fun.cell_fun adds graphics cell cell, layer_fun adds graphics \nblock-wise manner. Similar cell_fun, layer_fun also needs seven\narguments, vector form (layer_fun can also eighth \nninth arguments introduced later section):j still contain column row indices corresponding \noriginal matrix, since now layer_fun applied heatmap slice \ncontains block cells, j vectors cells \ncurrent heatmap slice. Similarlly, x, y, w, h fill vectors\ncorresponding cells current heatmap slice.Since j now vectors, get corresponding values matrix, \nuse form mat[j, ] gives sub-matrix \nlength() rows length(j) columns. Instead can use pindex()\nfunction ComplexHeatmap like pairwise indexing matrix.\nSee follow example:Next example shows layer_fun version adding text heatmap. ’s\nbasically cell_fun version.add text cells positive values:heatmap split, layer_fun applied every slice.layer_fun can also two arguments index \ncurrent row slice column slice. E.g. want add borders top\nright bottom left slices.advantage layer_fun fast add graphics, \nalso provides possibilities customize heatmap, e.g. can\ninteract cells heatmap slice. Consider following visualization: \nrow heatmap, values neighbouring two columns \nsign, add red line green line depending sign two values.\nSince now graphics cell depend cells, possible \nimplement via layer_fun. (Don’t frightened following code. \nexplained code.)values sent layer_fun vectors (vectorization\ngrid graphics functions), however, heatmap slice \nlayer_fun applied , still represented matrix, thus, \nconvinient arguments layer_fun can converted \nsub-matrix current slice. , shown example,\nrestore_matrix() job. restore_matrix() directly accepts first\nfour argument layer_fun returns index matrix, rows \ncolumns correspond rows columns current slice, top \nbottom left right. values matrix natural order\ne.g. vector j current slice.run following code:first output top-left slice:see, three-row five-column index matrix first\nrow corresponds top row slice. values matrix\ncorrespond natural index (.e. 1, 2, …) j, , x, y,\n… layer_fun. Now, want add values second column \ntop-left slice, code put inside layer_fun look like:Now easier understand second example: want add points \nsecond row third column every slice:","code":"\n# code only for demonstration\nHeatmap(..., layer_fun = function(j, i, x, y, w, h, fill) {...})\n# or you can capitalize the arguments to mark they are vectors,\n# the names of the argument do not matter\nHeatmap(..., layer_fun = function(J, I, X, Y, W, H, F) {...})\nmfoo = matrix(1:9, nr = 3)\nmfoo[1:2, c(1, 3)]##      [,1] [,2]\n## [1,]    1    7\n## [2,]    2    8\n# but we actually want mfoo[1, 1] and mfoo[2, 3]\npindex(mfoo, 1:2, c(1, 3))## [1] 1 8\ncol_fun = colorRamp2(c(-2, 0, 2), c(\"green\", \"white\", \"red\"))\nHeatmap(small_mat, name = \"mat\", col = col_fun,\n    layer_fun = function(j, i, x, y, width, height, fill) {\n        # since grid.text can also be vectorized\n        grid.text(sprintf(\"%.1f\", pindex(small_mat, i, j)), x, y, \n            gp = gpar(fontsize = 10))\n})\nHeatmap(small_mat, name = \"mat\", col = col_fun, \n    layer_fun = function(j, i, x, y, width, height, fill) {\n        v = pindex(small_mat, i, j)\n        l = v > 0\n        grid.text(sprintf(\"%.1f\", v[l]), x[l], y[l], gp = gpar(fontsize = 10))\n})\nHeatmap(small_mat, name = \"mat\", col = col_fun,\n    row_km = 2, column_km = 2,\n    layer_fun = function(j, i, x, y, width, height, fill) {\n        v = pindex(small_mat, i, j)\n        grid.text(sprintf(\"%.1f\", v), x, y, gp = gpar(fontsize = 10))\n        if(sum(v > 0)/length(v) > 0.75) {\n            grid.rect(gp = gpar(lwd = 2, fill = \"transparent\"))\n        }\n})\nHeatmap(small_mat, name = \"mat\", col = col_fun,\n    row_km = 2, column_km = 2,\n    layer_fun = function(j, i, x, y, width, height, fill, slice_r, slice_c) {\n        v = pindex(small_mat, i, j)\n        grid.text(sprintf(\"%.1f\", v), x, y, gp = gpar(fontsize = 10))\n        if(slice_r != slice_c) {\n            grid.rect(gp = gpar(lwd = 2, fill = \"transparent\"))\n        }\n})\nHeatmap(small_mat, name = \"mat\", col = col_fun,\n    row_km = 2, column_km = 2,\n    layer_fun = function(j, i, x, y, w, h, fill) {\n        # restore_matrix() is explained after this chunk of code\n        ind_mat = restore_matrix(j, i, x, y)\n        for(ir in seq_len(nrow(ind_mat))) {\n            # start from the second column\n            for(ic in seq_len(ncol(ind_mat))[-1]) {\n                ind1 = ind_mat[ir, ic-1] # previous column\n                ind2 = ind_mat[ir, ic]   # current column\n                v1 = small_mat[i[ind1], j[ind1]]\n                v2 = small_mat[i[ind2], j[ind2]]\n                if(v1 * v2 > 0) { # if they have the same sign\n                    col = ifelse(v1 > 0, \"darkred\", \"darkgreen\")\n                    grid.segments(x[ind1], y[ind1], x[ind2], y[ind2],\n                        gp = gpar(col = col, lwd = 2))\n                    grid.points(x[c(ind1, ind2)], y[c(ind1, ind2)], \n                        pch = 16, gp = gpar(col = col), size = unit(4, \"mm\"))\n                }\n            }\n        }\n    }\n)\nHeatmap(small_mat, name = \"mat\", col = col_fun,\n    row_km = 2, column_km = 2,\n    layer_fun = function(j, i, x, y, w, h, fill) {\n        ind_mat = restore_matrix(j, i, x, y)\n        print(ind_mat)\n    }\n)     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    4    7   10   13\n[2,]    2    5    8   11   14\n[3,]    3    6    9   12   15\nfor(ind in ind_mat[, 2]) {\n    grid.text(small_mat[i[ind], j[ind]], x[ind], y[ind], ...)\n}\nHeatmap(small_mat, name = \"mat\", col = col_fun,\n    row_km = 2, column_km = 2,\n    layer_fun = function(j, i, x, y, w, h, fill) {\n        ind_mat = restore_matrix(j, i, x, y)\n        ind = unique(c(ind_mat[2, ], ind_mat[, 3]))\n        grid.points(x[ind], y[ind], pch = 16, size = unit(4, \"mm\"))\n    }\n)"},{"path":"a-single-heatmap.html","id":"size-of-the-heatmap","chapter":"2 A Single Heatmap","heading":"2.10 Size of the heatmap","text":"width, heatmap_width, height heatmap_height control size \nheatmap. default, heatmap components fixed width height,\ne.g. width row dendrogram 1cm. width height \nheatmap body fill rest area final plotting region, means, \ndraw interactive graphic window change size \nwindow draging , size heatmap body automatically adjusted.heatmap_width heatmap_height control width/height complete\nheatmap including heatmap components (excluding legends) width\nheight control width/height heamtap body. four\narguments can set absolute units.four arguments important adjust size list \nheatmaps (see Section\n4.2).size heatmap set absolute units, possible \nsize figure larger size heatmap, gives blank\nareas around heatmap. size heatmap can retrieved ComplexHeatmap:::width()\nComplexHeatmap:::height() functions.Check blog post (Set cell width/height heatmap) want save heatmap figure file \nexactly size heatmap.","code":"\nHeatmap(mat, name = \"mat\", width = unit(8, \"cm\"), height = unit(8, \"cm\"))\nHeatmap(mat, name = \"mat\", heatmap_width = unit(8, \"cm\"), \n    heatmap_height = unit(8, \"cm\"))\nht = Heatmap(mat, name = \"mat\", width = unit(8, \"cm\"), height = unit(8, \"cm\"))\nht = draw(ht) # you must call draw() to reassign the heatmap variable\nComplexHeatmap:::width(ht)## [1] 118.851591171994mm\nComplexHeatmap:::height(ht)## [1] 114.717557838661mm\nht = Heatmap(mat, name = \"mat\", heatmap_width = unit(8, \"cm\"), \n    heatmap_height = unit(8, \"cm\"))\nht = draw(ht)\nComplexHeatmap:::width(ht)## [1] 94.8877245053272mm\nComplexHeatmap:::height(ht)## [1] 83.8660578386606mm"},{"path":"a-single-heatmap.html","id":"plot-the-heatmap","chapter":"2 A Single Heatmap","heading":"2.11 Plot the heatmap","text":"Heatmap() function actually constructor, means puts\ndata configurations object Heatmap class. \nclustering performed draw() method called. \ninteractive mode (e.g. interactive R terminal can type R\ncode line line), directly calling Heatmap() without assigning \nobject prints object print method (S4 show() method) \nHeatmap class object calls draw() internally. type\nHeatmap(...) R terminal, looks like plotting function\nlike plot(), need aware actually true \nfollowing cases might see nothing plotted.put Heatmap(...) inside function,put Heatmap(...) code chunk like -elseyou put Heatmap(...) Rscript run command line.reason three cases, show() method called \nthus draw() method executed either. , make plot, need \ncall draw() explicitly: draw(Heatmap(...)) :draw() function actually applied list heatmaps \nHeatmapList class. draw() method single Heatmap class\nconstructs HeatmapList one heatmap call draw() method \nHeatmapList class. draw() function accpets lot arguments\ne.g. control legends. discussed Chapter\n4.","code":"\n# code only for demonstration\nht = Heatmap(...)\ndraw(ht)\ndraw(ht, heatmap_legend_side, padding, ...)"},{"path":"a-single-heatmap.html","id":"get-orders-and-dendrograms-from-heatmap","chapter":"2 A Single Heatmap","heading":"2.12 Extract orders and dendrograms","text":"row/column orders heatmap can obtained \nrow_order()/column_order() functions. can directly apply \nheatmap object returned Heatmap() object returned draw().\nfollowing, take row_order() example.explained previous section, Heatmap() function perform\nclustering, thus, directly apply row_order() ht1, clustering \nfirst performed. Later making heatmap draw(ht1), \nclustering applied . might problem set\nk-means clustering heatmap. Since clustering applied twice,\nk-means might give different clusterings, means, might \ndifferent results row_order() might different heatmap.following chunk code, o1, o2 o3 might different \ntime, k-means clustering performed.draw() function returns heatmap (precisely, heatmap list)\nalready reordered, applying row_order() just extracts \nrow order object, ensures row order exactly \none shown heatmap. code, o3 always identical o4., preferable way get row/column orders follows.rows/columns split, row order column order list.Similarly, row_dend()/column_dend() functions return dendrograms.\nreturns single dendrogram list dendrograms depending whether\nheatmap split.row_order(), column_order(), row_dend() column_dend() also work\nlist heatmaps, introduced Section\n4.12.","code":"\nsmall_mat = mat[1:9, 1:9]\nht1 = Heatmap(small_mat)\nrow_order(ht1)## [1] 5 7 2 4 9 6 8 1 3\nht2 = draw(ht1)\nrow_order(ht2)## [1] 5 7 2 4 9 6 8 1 3\n# code only for demonstration\nht1 = Heatmap(small_mat, row_km = 2)\no1 = row_order(ht1)\no2 = row_order(ht1)\nht2 = draw(ht1)\no3 = row_order(ht2)\no4 = row_order(ht2)\n# code only for demonstration\nht = Heatmap(small_mat)\nht = draw(ht)\nrow_order(ht)\ncolumn_order(ht)\nht = Heatmap(small_mat, row_km = 2, column_km = 3)\nht = draw(ht)\nrow_order(ht)## $`2`\n## [1] 5 7 2 4\n## \n## $`1`\n## [1] 9 6 8 1 3\ncolumn_order(ht)## $`1`\n## [1] 6 2 7\n## \n## $`3`\n## [1] 1 3 4 5\n## \n## $`2`\n## [1] 8 9\nht = Heatmap(small_mat, row_km = 2)\nht = draw(ht)\nrow_dend(ht)## $`2`\n## 'dendrogram' with 2 branches and 4 members total, at height 2.946428 \n## \n## $`1`\n## 'dendrogram' with 2 branches and 5 members total, at height 2.681351\ncolumn_dend(ht)## 'dendrogram' with 2 branches and 9 members total, at height 4.574114"},{"path":"a-single-heatmap.html","id":"subset-a-heatmap","chapter":"2 A Single Heatmap","heading":"2.13 Subset a heatmap","text":"Since heatmap representation matrix, also subset method\nHeatmap class.annotations subsetted accordingly well.heatmap components subsetted vector-like. \nconfigurations heatmap keep subsetting, e.g. row_km\nset original heatmap, configuration k-means kept \nperformed sub-heatmap. following example, k-means clustering \nperformed making heatmap ht2.implementation subsetting heatmaps experimental. \nalways working, e.g. cell_fun defined uses external matrix, \nclustering objects assigned cluster_rows cluster_columns.also subset methods HeatmapAnnotation class (Section\n3.22) HeatmapList class (Section 4.10),\nexperimental well.","code":"\nht = Heatmap(mat, name = \"mat\")\ndim(ht)## [1] 18 24\nht[1:10, 1:10]\nht = Heatmap(mat, name = \"mat\", row_km = 2, column_km = 3,\n    col = colorRamp2(c(-2, 0, 2), c(\"green\", \"white\", \"red\")),\n    top_annotation = HeatmapAnnotation(foo1 = 1:24, bar1 = anno_points(runif(24))),\n    right_annotation = rowAnnotation(foo2 = 18:1, bar2 = anno_barplot(runif(18)))\n)\nht[1:9*2 - 1, 1:12*2] # odd rows, even columns\nht = Heatmap(mat, name = \"mat\", row_km = 2)\nht2 = ht[1:10, 1:10]\nht2"},{"path":"heatmap-annotations.html","id":"heatmap-annotations","chapter":"3 Heatmap Annotations","heading":"3 Heatmap Annotations","text":"Heatmap annotations important components heatmap shows\nadditional information associates rows columns heatmap.\nComplexHeatmap package provides flexible supports setting\nannotations defining new annotation graphics. annotations can put\nfour sides heatmap, top_annotation, bottom_annotation,\nleft_annotation right_annotation arguments.value four arguments HeatmapAnnotation class\nconstructed HeatmapAnnotation() function, \nrowAnnotation() function row annotation. (rowAnnotation() \njust helper function identical HeatmapAnnotation(..., = \"row\")). simple usage heatmap annotations follows.assign bottom annotation left annotation.examples, column_ha row_ha two annotations \nfoo1 foo2 numeric vectors bar1 bar2 barplots. \nvector-like annotation called “simple annotation” barplot\nannotation called “complex annotation”. can already see \nannotations must defined name-value pairs (e.g. foo = ...).Heatmap annotations can also independent heatmaps. can \nconcatenated heatmap list + horizontal, %v% \nvertical. Chapter 4 discuss concatenate\nheatmaps annotations.HeatmapAnnotation() returns HeatmapAnnotation class object. object\nusually composed several annotations. following sections \nchapter, first introduce settings individal annotation, later \nshow put toghether.can see information column_ha row_ha objects directly enter object names:following examples chapter, show graphics \nannotations heatmap, unless necessary. want try \nheatmap, just assign HeatmapAnnotation object always\nname ha top_annotation, bottom_annotation, left_annotation \nright_annotation arguments.Settings basically column annotations row annotations. \nnothing specicial, show column annotation examples. \nwant try row annotation, just add = \"row\" \nHeatmapAnnotation() directly change rowAnnotation() function.","code":"\nset.seed(123)\nmat = matrix(rnorm(100), 10)\nrownames(mat) = paste0(\"R\", 1:10)\ncolnames(mat) = paste0(\"C\", 1:10)\ncolumn_ha = HeatmapAnnotation(foo1 = runif(10), bar1 = anno_barplot(runif(10)))\nrow_ha = rowAnnotation(foo2 = runif(10), bar2 = anno_barplot(runif(10)))\nHeatmap(mat, name = \"mat\", top_annotation = column_ha, right_annotation = row_ha)\nHeatmap(mat, name = \"mat\", bottom_annotation = column_ha, left_annotation = row_ha)\n# code only for demonstration\nHeatmap(...) + rowAnnotation() + ...\nHeatmap(...) %v% HeatmapAnnotation(...) %v% ...\ncolumn_ha## A HeatmapAnnotation object with 2 annotations\n##   name: heatmap_annotation_0 \n##   position: column \n##   items: 10 \n##   width: 1npc \n##   height: 15.3514598035146mm \n##   this object is subsettable\n##   5.92288888888889mm extension on the left \n##   9.4709mm extension on the right \n## \n##  name   annotation_type color_mapping height\n##  foo1 continuous vector        random    5mm\n##  bar1    anno_barplot()                 10mm\nrow_ha## A HeatmapAnnotation object with 2 annotations\n##   name: heatmap_annotation_1 \n##   position: row \n##   items: 10 \n##   width: 15.3514598035146mm \n##   height: 1npc \n##   this object is subsettable\n##   9.96242222222222mm extension on the bottom \n## \n##  name   annotation_type color_mapping width\n##  foo2 continuous vector        random   5mm\n##  bar2    anno_barplot()                10mm"},{"path":"heatmap-annotations.html","id":"simple-annotation","chapter":"3 Heatmap Annotations","heading":"3.1 Simple annotation","text":"-called “simple annotation” used style annotations \nheatmap-like grid-like graphics colors used map \nannotation values. generate simple annotation, just simply put \nannotation vector HeatmapAnnotation() certain name.discrete annotation:can use strings annotation names except pre-defined arguments\nHeatmapAnnotation().colors specified, colors randomly generated. set colors \nannotations, col needs set named list names \nannotation names. continuous values, color mapping \ncolor mapping function generated circlize::colorRamp2().discrete annotations, color named vector names\ncorrespond levels annotation.specify one vectors, multiple annotations\n(foo bar following example). Also can see col set \nfoo bar put single HeatmapAnnotation(). Maybe now \ncan understand names color list actually used map \nannotation names. Values col used construct legends simple\nannotations.color NA value controlled na_col argument.gp mainly controls graphics parameters borders grids.simple annotation can also matrix (numeric character) \ncolumns matrix share color mapping schema. Note columns \nmatrix correspond rows column annotation (can imagine vector one-column matrix). Also column\nnames matrix used annotation names.matrix column name, name annotation still used, drawn\nmiddle annotation.simple annotations can different modes (e.g. numeric, character),\ncan combined data frame send df argument. Imagine \nproject, might already annotation table, can directly set \ndf.Single annotations data frame can mixed, single annotations \ninserted data frame annotation. following example, colors \nfoo2 specified, random colors used.border controls border every single annotation.height simple annotation controlled simple_anno_size\nargument. Since single annotations height, value \nsimple_anno_size single unit value. Note arguments like\nwidth, height, annotation_width annotation_height, \nused adjust width/height complete heamtap annotations (\nalways mix several annotations). adjustment four arguments\nintroduced Section 3.21.multiple heatmaps better keep size simple\nannotations heatmaps size. ht_opt$simple_anno_size can\nset control simple annotation size globally (introduced\nSection 4.13).","code":"\nha = HeatmapAnnotation(foo = 1:10)\nha = HeatmapAnnotation(bar = sample(letters[1:3], 10, replace = TRUE))\nlibrary(circlize)\ncol_fun = colorRamp2(c(0, 5, 10), c(\"blue\", \"white\", \"red\"))\nha = HeatmapAnnotation(foo = 1:10, col = list(foo = col_fun))\nha = HeatmapAnnotation(bar = sample(letters[1:3], 10, replace = TRUE),\n    col = list(bar = c(\"a\" = \"red\", \"b\" = \"green\", \"c\" = \"blue\")))\nha = HeatmapAnnotation(\n    foo = 1:10, \n    bar = sample(letters[1:3], 10, replace = TRUE),\n    col = list(foo = col_fun,\n               bar = c(\"a\" = \"red\", \"b\" = \"green\", \"c\" = \"blue\")\n    )\n)\nha = HeatmapAnnotation(\n    foo = c(1:4, NA, 6:10), \n    bar = c(NA, sample(letters[1:3], 9, replace = TRUE)),\n    col = list(foo = col_fun,\n               bar = c(\"a\" = \"red\", \"b\" = \"green\", \"c\" = \"blue\")\n    ),\n    na_col = \"black\"\n)\nha = HeatmapAnnotation(\n    foo = 1:10, \n    bar = sample(letters[1:3], 10, replace = TRUE),\n    col = list(foo = col_fun,\n               bar = c(\"a\" = \"red\", \"b\" = \"green\", \"c\" = \"blue\")\n    ),\n    gp = gpar(col = \"black\")\n)\nha = HeatmapAnnotation(foo = cbind(a = runif(10), b = runif(10)))\nha = HeatmapAnnotation(foo = cbind(runif(10), runif(10)))\nanno_df = data.frame(\n    foo = 1:10,\n    bar = sample(letters[1:3], 10, replace = TRUE)\n)\nha = HeatmapAnnotation(df = anno_df,\n    col = list(foo = col_fun,\n               bar = c(\"a\" = \"red\", \"b\" = \"green\", \"c\" = \"blue\")\n    )\n)\nha = HeatmapAnnotation(df = anno_df,\n    foo2 = rnorm(10),\n    col = list(foo = col_fun,\n               bar = c(\"a\" = \"red\", \"b\" = \"green\", \"c\" = \"blue\")\n    )\n)\nha = HeatmapAnnotation(\n    foo = cbind(1:10, 10:1),\n    bar = sample(letters[1:3], 10, replace = TRUE),\n    col = list(foo = col_fun,\n               bar = c(\"a\" = \"red\", \"b\" = \"green\", \"c\" = \"blue\")\n    ),\n    border = TRUE\n)\nha = HeatmapAnnotation(\n    foo = cbind(a = 1:10, b = 10:1), \n    bar = sample(letters[1:3], 10, replace = TRUE),\n    col = list(foo = col_fun,\n               bar = c(\"a\" = \"red\", \"b\" = \"green\", \"c\" = \"blue\")\n    ),\n    simple_anno_size = unit(1, \"cm\")\n)"},{"path":"heatmap-annotations.html","id":"simple-annotation-as-an-annotation-function","chapter":"3 Heatmap Annotations","heading":"3.2 Simple annotation as an annotation function","text":"HeatmapAnnotation() supports “complex annotation” setting \nannotation function. annotation function defines draw \ngraphics certain position corresponding column row \nheatmap. quite lot annotation functions predefined \nComplexHeatmap package. end chapter, introduce \nconstruct annotation function AnnotationFunction class.annotation functions forms anno_*(), specified \nHeatmapAnnotation() rowAnnotation(), don’t need anything\nexplicitly anno_*() tell whether drawn rows \ncolumns. anno_*() automatically detects whether row annotation\nenvironment column annotation environment.simple annotation shown previous section internally constructed \nanno_simple() annotation function. Directly using anno_simple() \nautomatically generate legends final plot, , can provide \nflexibility annotation graphics (note Chapter\n5 show, although anno_simple() automatically generate \nlegends, legends can controlled added final plot manually).example previous section:actually identical :anno_simple() makes heatmap-like annotations (simple annotations).\nBasically users make heatmap-like annotations, need \ndirectly use anno_simple(), function allows add symbols \nannotation grids.anno_simple() allows add “points” single-letter symbols top \nannotation grids. pch, pt_gp pt_size control settings \npoints. value pch can vector possible NA values.Set pch vector:Set pch vector letters:Set pch vector NA values (nothing drawn NA pch values):pch also works value anno_simple() matrix. length \npch number matrix rows columns even \nlength matrix (length matrix length data\npoints matrix).Length pch corresponds matrix columns:Length pch corresponds matrix rows:pch matrix:Till now, might wonder set legends symbols ’ve added\nsimple annotations. show simple example \nfunctionality discussed Chapter 5. following\nexample, assume simple annotations kind p-values add *\np-values less 0.01.height simple annotation can controlled height argument \nsimple_anno_size inside anno_simple(). simple_anno_size controls \nsize single-row annotation height/width controls total\nheight/width simple annotations. height/width set,\nsimple_anno_size ignored.annotation functions introduce later, height width\nindividual annotations set inside anno_*()\nfunctions., width, height, annotation_width annotation_height\narguments HeatmapAnnotation() used adjust size multiple\nannotations.","code":"\n# code only for demonstration\nha = HeatmapAnnotation(foo = 1:10)\n# code only for demonstration\nha = HeatmapAnnotation(foo = anno_simple(1:10))\nha = HeatmapAnnotation(foo = anno_simple(1:10, pch = 1, \n    pt_gp = gpar(col = \"red\"), pt_size = unit(1:10, \"mm\")))\nha = HeatmapAnnotation(foo = anno_simple(1:10, pch = 1:10))\nha = HeatmapAnnotation(foo = anno_simple(1:10, \n    pch = sample(letters[1:3], 10, replace = TRUE)))\nha = HeatmapAnnotation(foo = anno_simple(1:10, pch = c(1:4, NA, 6:8, NA, 10, 11)))\nha = HeatmapAnnotation(foo = anno_simple(cbind(1:10, 10:1), pch = 1:2))\nha = HeatmapAnnotation(foo = anno_simple(cbind(1:10, 10:1), pch = 1:10))\npch = matrix(1:20, nc = 2)\npch[sample(length(pch), 10)] = NA\nha = HeatmapAnnotation(foo = anno_simple(cbind(1:10, 10:1), pch = pch))\nset.seed(123)\npvalue = 10^-runif(10, min = 0, max = 3)\nis_sig = pvalue < 0.01\npch = rep(\"*\", 10)\npch[!is_sig] = NA\n# color mapping for -log10(pvalue)\npvalue_col_fun = colorRamp2(c(0, 2, 3), c(\"green\", \"white\", \"red\")) \nha = HeatmapAnnotation(\n    pvalue = anno_simple(-log10(pvalue), col = pvalue_col_fun, pch = pch),\n    annotation_name_side = \"left\")\nht = Heatmap(matrix(rnorm(100), 10), name = \"mat\", top_annotation = ha)\n# now we generate two legends, one for the p-value\n# see how we define the legend for pvalue\nlgd_pvalue = Legend(title = \"p-value\", col_fun = pvalue_col_fun, at = c(0, 1, 2, 3), \n    labels = c(\"1\", \"0.1\", \"0.01\", \"0.001\"))\n# and one for the significant p-values\nlgd_sig = Legend(pch = \"*\", type = \"points\", labels = \"< 0.01\")\n# these two self-defined legends are added to the plot by `annotation_legend_list`\ndraw(ht, annotation_legend_list = list(lgd_pvalue, lgd_sig))\nha = HeatmapAnnotation(foo = anno_simple(1:10, height = unit(2, \"cm\")))\nha = HeatmapAnnotation(foo = anno_simple(cbind(1:10, 10:1), \n    simple_anno_size = unit(2, \"cm\")))# code only for demonstration\nanno_*(..., width = ...)\nanno_*(..., height = ...)"},{"path":"heatmap-annotations.html","id":"empty-annotation","chapter":"3 Heatmap Annotations","heading":"3.3 Empty annotation","text":"anno_empty() place holder nothing drawn. Later user-defined\ngraphics can added decorate_annotation() function.Chapter 6, introduce use \ndecoration functions, give quick example. gene expression\nexpression analysis, senarios split heatmaps \nseveral groups want highlight key genes group. \ncase, simply add gene names right side heatmap without\naligning corresponding rows. (anno_mark() can align \nlabels correclty corresponding rows, example show ,\nnecessray).following example, since rows split four slices, empty\nannotation also split four slices. Basically \nempty annotation slice, add colored segment text.Note previous plot can also made anno_block() anno_textbox() (Section 3.19).second use empty annotation add complex annotation graphics\nempty annotation pretends virtual plotting region. can\nconstruct annotation function AnnotationFunction class complex\nannotation graphics, allows subsetting splitting, still, can\nsecondary choice directly draw inside empty annotation, \neasier faster implementing (less flexible allow\nsplitting).following show add “complex version” points annotation. \nthing needs careful location x-axis (y-axis \nrow annotation) correspond column index column\nreordering.","code":"\nha = HeatmapAnnotation(foo = anno_empty(border = TRUE))\nrandom_text = function(n) {\n    sapply(1:n, function(i) {\n        paste0(sample(letters, sample(4:10, 1)), collapse = \"\")\n    })\n}\ntext_list = list(\n    text1 = random_text(4),\n    text2 = random_text(4),\n    text3 = random_text(4),\n    text4 = random_text(4)\n)\n# note how we set the width of this empty annotation\nha = rowAnnotation(foo = anno_empty(border = FALSE, \n    width = max_text_width(unlist(text_list)) + unit(4, \"mm\")))\nHeatmap(matrix(rnorm(1000), nrow = 100), name = \"mat\", row_km = 4, right_annotation = ha)\nfor(i in 1:4) {\n    decorate_annotation(\"foo\", slice = i, {\n        grid.rect(x = 0, width = unit(2, \"mm\"), gp = gpar(fill = i, col = NA), just = \"left\")\n        grid.text(paste(text_list[[i]], collapse = \"\\n\"), x = unit(4, \"mm\"), just = \"left\")\n    })\n}\n# Note this example is only for demonstration of `anno_empty()`.\n# Actually it can be made easily by `anno_points()`.\nha = HeatmapAnnotation(foo = anno_empty(border = TRUE, height = unit(3, \"cm\")))\nht = Heatmap(matrix(rnorm(100), nrow = 10), name = \"mat\", top_annotation = ha)\nht = draw(ht)\nco = column_order(ht)\nvalue = runif(10)\ndecorate_annotation(\"foo\", {\n    # value on x-axis is always 1:ncol(mat)\n    x = 1:10\n    # while values on y-axis is the value after column reordering\n    value = value[co]\n    pushViewport(viewport(xscale = c(0.5, 10.5), yscale = c(0, 1)))\n    grid.lines(c(0.5, 10.5), c(0.5, 0.5), gp = gpar(lty = 2),\n        default.units = \"native\")\n    grid.points(x, value, pch = 16, size = unit(2, \"mm\"),\n        gp = gpar(col = ifelse(value > 0.5, \"red\", \"blue\")), default.units = \"native\")\n    grid.yaxis(at = c(0, 0.5, 1))\n    popViewport()\n})"},{"path":"heatmap-annotations.html","id":"block-annotation","chapter":"3 Heatmap Annotations","heading":"3.4 Block annotation","text":"two uses block annotation. 1. simply rectangles (labels\ninside) mark heatmap slices, 2. plotting regions associate subsets \nrows columns heatmap.","code":""},{"path":"heatmap-annotations.html","id":"block-for-putting-labels","chapter":"3 Heatmap Annotations","heading":"3.4.1 Block for putting labels","text":"case, block annotation like color block identifies groups \nrows columns heatmap split.Labels can added block.Note length labels graphics parameters length\nnumber slices.anno_block() function draws rectangles row/column slices one\nrectangle corresponds one single slice. want draw\nrectangles several slices show belong certain groups?Currently, difficult directly support anno_block(), however,\nworkaround . Actually, draw rectangles across several\nslices, need know two things: 1. positions slices \nplot, 2. space draw rectangles. Luckily, positions can \nobtained directly go correspoding viewport space can \nallocated anno_empty() function.following code, use anno_empty() create empty annotation:Let’s say, want put first three column slices group last two\nslices second group.positions first third slices annotation \"empty\" can obtained :viewport name \"annotation_empty_1\" correspond first slice \nannotation empty, take left bottom first “empty”\nannotation slice top right third slice, saved loc1 \nloc2 variables.important use grid::deviceLoc() function. directly\nconverts location measured certain viewport position \ngraphics device.end, go \"global\" viewport size \"global\"\nviewport size graphics device, draw rectangle add\nlabel.viewport names annotations fixed format, \nannotation_{annotation_name}_{slice_index}. full set viewport names\ncan obtained list_components() function.one group-level rectangles added, can wrap code\nsimple function group_block_anno():","code":"\nHeatmap(matrix(rnorm(100), 10), name = \"mat\",\n    top_annotation = HeatmapAnnotation(foo = anno_block(gp = gpar(fill = 2:4))),\n    column_km = 3)\nHeatmap(matrix(rnorm(100), 10), name = \"mat\",\n    top_annotation = HeatmapAnnotation(foo = anno_block(gp = gpar(fill = 2:4),\n        labels = c(\"group1\", \"group2\", \"group3\"), \n        labels_gp = gpar(col = \"white\", fontsize = 10))),\n    column_km = 3,\n    left_annotation = rowAnnotation(foo = anno_block(gp = gpar(fill = 2:4),\n        labels = c(\"group1\", \"group2\", \"group3\"), \n        labels_gp = gpar(col = \"white\", fontsize = 10))),\n    row_km = 3)\nset.seed(123)\nmat2 = matrix(rnorm(50*50), nrow = 50)\nsplit = rep(1:5, each = 10)\nha = HeatmapAnnotation(\n    empty = anno_empty(border = FALSE),\n    foo = anno_block(gp = gpar(fill = 2:6), labels = LETTERS[1:5])\n)\nHeatmap(mat2, name = \"mat2\", column_split = split, top_annotation = ha, \n    column_title = NULL)\nseekViewport(\"annotation_empty_1\")\nloc1 = deviceLoc(x = unit(0, \"npc\"), y = unit(0, \"npc\"))\nseekViewport(\"annotation_empty_3\")\nloc2 = deviceLoc(x = unit(1, \"npc\"), y = unit(1, \"npc\"))\nloc2## $x\n## [1] 4.07403126835173inches\n## \n## $y\n## [1] 6.51051067246731inches\nseekViewport(\"global\")\ngrid.rect(loc1$x, loc1$y, width = loc2$x - loc1$x, height = loc2$y - loc1$y, \n    just = c(\"left\", \"bottom\"), gp = gpar(fill = \"red\"))\ngrid.text(\"group 1\", x = (loc1$x + loc2$x)*0.5, y = (loc1$y + loc2$y)*0.5)\nlist_components()##  [1] \"ROOT\"                        \"global\"                     \n##  [3] \"global_layout\"               \"global-heatmaplist\"         \n##  [5] \"main_heatmap_list\"           \"heatmap_mat2\"               \n##  [7] \"mat2_heatmap_body_wrap\"      \"mat2_heatmap_body_1_1\"      \n##  [9] \"mat2_heatmap_body_1_2\"       \"mat2_heatmap_body_1_3\"      \n## [11] \"mat2_heatmap_body_1_4\"       \"mat2_heatmap_body_1_5\"      \n## [13] \"mat2_dend_row_1\"             \"mat2_dend_column_1\"         \n## [15] \"mat2_dend_column_2\"          \"mat2_dend_column_3\"         \n## [17] \"mat2_dend_column_4\"          \"mat2_dend_column_5\"         \n## [19] \"annotation_empty_1\"          \"annotation_foo_1\"           \n## [21] \"annotation_empty_2\"          \"annotation_foo_2\"           \n## [23] \"annotation_empty_3\"          \"annotation_foo_3\"           \n## [25] \"annotation_empty_4\"          \"annotation_foo_4\"           \n## [27] \"annotation_empty_5\"          \"annotation_foo_5\"           \n## [29] \"global-heatmap_legend_right\" \"heatmap_legend\"\nha = HeatmapAnnotation(\n    empty = anno_empty(border = FALSE, height = unit(8, \"mm\")),\n    foo = anno_block(gp = gpar(fill = 2:6), labels = LETTERS[1:5])\n)\nHeatmap(mat2, name = \"mat2\", column_split = split, top_annotation = ha, \n    column_title = NULL)\n\nlibrary(GetoptLong)  # for the function qq()\ngroup_block_anno = function(group, empty_anno, gp = gpar(), \n    label = NULL, label_gp = gpar()) {\n\n    seekViewport(qq(\"annotation_@{empty_anno}_@{min(group)}\"))\n    loc1 = deviceLoc(x = unit(0, \"npc\"), y = unit(0, \"npc\"))\n    seekViewport(qq(\"annotation_@{empty_anno}_@{max(group)}\"))\n    loc2 = deviceLoc(x = unit(1, \"npc\"), y = unit(1, \"npc\"))\n\n    seekViewport(\"global\")\n    grid.rect(loc1$x, loc1$y, width = loc2$x - loc1$x, height = loc2$y - loc1$y, \n        just = c(\"left\", \"bottom\"), gp = gp)\n    if(!is.null(label)) {\n        grid.text(label, x = (loc1$x + loc2$x)*0.5, y = (loc1$y + loc2$y)*0.5, gp = label_gp)\n    }\n}\n\ngroup_block_anno(1:3, \"empty\", gp = gpar(fill = \"red\"), label = \"group 1\")\ngroup_block_anno(4:5, \"empty\", gp = gpar(fill = \"blue\"), label = \"group 2\")"},{"path":"heatmap-annotations.html","id":"blocks-as-plotting-regions","chapter":"3 Heatmap Annotations","heading":"3.4.2 Blocks as plotting regions","text":"heatmap split, block block annotation can thought \nvirtual plotting region. anno_block() allows argument panel_fun \naccepts self-defined function draws graphics slice. must\ntwo arguments:row/column indices current slice (let’s call index),vector levels split variable correspond current slice (let’s call level). e.g. row_km \nset row_split set one categorical variable, level vector length one. multiple\ncategorical variables set row_km row_split, level vector length number\ncategorical variables.panel_fun set, graphics parameters anno_block() ignored. See following example:make general, anno_block() accepts argument align_to defines\nlist indices blocks corresponded , need make sure\nindices continuously adjacent heatmaps.anno_block() normally works row_split, necessary, see following example:","code":"\ncol = c(\"1\" = \"red\", \"2\" = \"blue\", \"A\" = \"green\", \"B\" = \"orange\")\nHeatmap(matrix(rnorm(100), 10), name = \"mat\", row_km = 2, \n    row_split = sample(c(\"A\", \"B\"), 10, replace = TRUE)) + \nrowAnnotation(foo = anno_block(\n    panel_fun = function(index, levels) {\n        grid.rect(gp = gpar(fill = col[levels[2]], col = \"black\"))\n        txt = paste(levels, collapse = \",\")\n        txt = paste0(txt, \"\\n\", length(index), \" rows\")\n        grid.text(txt, 0.5, 0.5, rot = 0,\n            gp = gpar(col = col[levels[1]]))\n    },\n    width = unit(3, \"cm\")\n))\nsplit = sample(c(\"A\", \"B\"), 10, replace = TRUE)\nalign_to = list(\"A\" = which(split == \"A\"))\npanel_fun = function(index, nm) {\n    grid.rect()\n    grid.text(paste0(length(index), \" rows\"), 0.5, 0.5)\n}\nHeatmap(matrix(rnorm(100), 10), name = \"mat\", row_split = split) + \nrowAnnotation(foo = anno_block(\n    align_to = align_to,\n    panel_fun = panel_fun,\n    width = unit(3, \"cm\")\n))\nalign_to = list(\"A\" = 2:4, \"B\" = 7:9)\nHeatmap(matrix(rnorm(100), 10), name = \"mat\", cluster_rows = FALSE) + \nrowAnnotation(foo = anno_block(\n    align_to = align_to,\n    panel_fun = panel_fun,\n    width = unit(3, \"cm\")\n))"},{"path":"heatmap-annotations.html","id":"image-annotation","chapter":"3 Heatmap Annotations","heading":"3.5 Image annotation","text":"Images can added annotations. anno_image() supports image png,\nsvg, pdf, eps, jpeg/jpg, tiff formats. imported \nannotations follows:png, jpeg/jpg tiff images imported png::readPNG(),\njpeg::readJPEG() tiff::readTIFF(), drawn \ngrid::grid.raster().svg images firstly reformatted rsvg::rsvg_svg() imported\ngrImport2::readPicture() drawn grImport2::grid.picture().pdf eps images imported grImport::PostScriptTrace() \ngrImport::readPicture(), later drawn grImport::grid.picture().free icons following examples \nhttps://github.com/Keyamoon/IcoMoon-Free. vector image paths set \nfirst argument anno_image().Different image formats can mixed input vector.Border background colors (images transparent background) can\nset gp.border controls border whole annotation.Padding space around images set space.images need drawn, elements image\nvector can set '' NA.","code":"\nimage_png = sample(dir(\"IcoMoon-Free-master/PNG/64px\", full.names = TRUE), 10)\nimage_svg = sample(dir(\"IcoMoon-Free-master/SVG/\", full.names = TRUE), 10)\nimage_eps = sample(dir(\"IcoMoon-Free-master/EPS/\", full.names = TRUE), 10)\nimage_pdf = sample(dir(\"IcoMoon-Free-master/PDF/\", full.names = TRUE), 10)\n\n# we only draw the image annotation for PNG images, while the others are the same\nha = HeatmapAnnotation(foo = anno_image(image_png))\n# code only for demonstration\nha = HeatmapAnnotation(foo = anno_image(c(image_png[1:3], image_svg[1:3], \n    image_eps[1:3], image_pdf[1:3])))\nha = HeatmapAnnotation(foo = anno_image(image_png, \n    gp = gpar(fill = 1:10, col = \"black\")))\nha = HeatmapAnnotation(foo = anno_image(image_png, border = \"red\"))\nha = HeatmapAnnotation(foo = anno_image(image_png, space = unit(3, \"mm\")))\nimage_png[1:2] = \"\"\nha = HeatmapAnnotation(foo = anno_image(image_png))"},{"path":"heatmap-annotations.html","id":"points-annotation","chapter":"3 Heatmap Annotations","heading":"3.6 Points annotation","text":"Points annotation implemented anno_points() shows distribution list\ndata points. data points object x can single vector matrix.\nmatrix, graphics settings pch, size gp can\ncorrepspond matrix columns. Note , x matrix, rows x\ncorrespond columns heatmap matrix.ylim controls range “y-axis” “data axis” (row\nannotation, data axis horizontal), extend controls extended space\ndata axis direction. axis controls whether show axis \naxis_param controls settings axis. default settings axis :can overwrite :One thing might useful can control rotation axis\nlabels.configuration axis annotation functions \naxes.default size points annotation 5mm. can controlled \nheight/width argument anno_points().","code":"\nha = HeatmapAnnotation(foo = anno_points(runif(10)))\nha = HeatmapAnnotation(foo = anno_points(matrix(runif(20), nc = 2), \n    pch = 1:2, gp = gpar(col = 2:3)))\ndefault_axis_param(\"column\")## $at\n## NULL\n## \n## $labels\n## NULL\n## \n## $labels_rot\n## [1] 0\n## \n## $gp\n## $fontsize\n## [1] 8\n## \n## \n## $side\n## [1] \"left\"\n## \n## $facing\n## [1] \"outside\"\n## \n## $direction\n## [1] \"normal\"\nha = HeatmapAnnotation(foo = anno_points(runif(10), ylim = c(0, 1),\n    axis_param = list(\n        side = \"right\",\n        at = c(0, 0.5, 1), \n        labels = c(\"zero\", \"half\", \"one\")\n    ))\n)\nha = rowAnnotation(foo = anno_points(runif(10), ylim = c(0, 1),\n    width = unit(2, \"cm\"),\n    axis_param = list(\n        side = \"bottom\",\n        at = c(0, 0.5, 1), \n        labels = c(\"zero\", \"half\", \"one\"),\n        labels_rot = 45\n    ))\n)\nha = HeatmapAnnotation(foo = anno_points(runif(10), height = unit(2, \"cm\")))"},{"path":"heatmap-annotations.html","id":"lines-annotation","chapter":"3 Heatmap Annotations","heading":"3.7 Line annotation","text":"anno_lines() connects data points list segments. Similar \nanno_points(), data variable can numeric vector:matrix:shown , points can added lines setting add_points = TRUE.Smoothed lines (loess()) can added instead original lines \nsetting smooth = TRUE, used caution order \ncolumns heatmap used “x-value” fitting think\nfitting reordered order makes sense.Smoothing also works input data variable matrix smoothing\nperformed column separately.smooth TRUE, add_points set TRUE default.default size lines annotation 5mm. can controlled \nheight/width argument anno_lines().","code":"\nha = HeatmapAnnotation(foo = anno_lines(runif(10)))\nha = HeatmapAnnotation(foo = anno_lines(cbind(c(1:5, 1:5), c(5:1, 5:1)), \n    gp = gpar(col = 2:3), add_points = TRUE, pt_gp = gpar(col = 5:6), pch = c(1, 16)))\nha = HeatmapAnnotation(foo = anno_lines(runif(10), smooth = TRUE))\n# code only for demonstration\nha = HeatmapAnnotation(foo = anno_lines(runif(10), height = unit(2, \"cm\")))"},{"path":"heatmap-annotations.html","id":"barplot_annotation","chapter":"3 Heatmap Annotations","heading":"3.8 Barplot annotation","text":"data points can represented barplots. arguments \nanno_barplot() ylim, axis, axis_param \nanno_points().width bars controlled bar_width. relative value \nwidth cell heatmap.Graphic parameters controlled gp.can choose baseline bars baseline.input value matrix, stacked barplots.length parameters gp can number columns matrix:default size barplot annotation 5mm. can controlled \nheight/width argument anno_barplot().Following example shows barplot annotation visualizes proportion\nmatrix (row sums 1).direction axis can reversed useful annotation\nput left heatmap.direction = \"reverse\" also works annotation functions \naxes, commonly used barplot annotations.Argument add_numbers can set TRUE numbers associated bars drawn top bars.\ncolumn annotation, texts default 45 degree rotation.input anno_barplot() matrix, argument beside can set \nTRUE bars heatmap column positioned :Argument attach can set TRUE two adjacent bars attached.","code":"\nha = HeatmapAnnotation(foo = anno_barplot(1:10))\nha = HeatmapAnnotation(foo = anno_barplot(1:10, bar_width = 1))\nha = HeatmapAnnotation(foo = anno_barplot(1:10, gp = gpar(fill = 1:10)))\nha = HeatmapAnnotation(foo = anno_barplot(seq(-5, 5), baseline = \"min\"))\nha = HeatmapAnnotation(foo = anno_barplot(seq(-5, 5), baseline = 0))\nha = HeatmapAnnotation(foo = anno_barplot(matrix(nc = 2, c(1:10, 10:1))))\nha = HeatmapAnnotation(foo = anno_barplot(cbind(1:10, 10:1), \n    gp = gpar(fill = 2:3, col = 2:3)))\n# code only for demonstration\nha = HeatmapAnnotation(foo = anno_barplot(runif(10), height = unit(2, \"cm\")))\nm = matrix(runif(4*10), nc = 4)\nm = t(apply(m, 1, function(x) x/sum(x)))\nha = HeatmapAnnotation(foo = anno_barplot(m, gp = gpar(fill = 2:5), \n    bar_width = 1, height = unit(6, \"cm\")))\nha_list = rowAnnotation(axis_reverse = anno_barplot(m, gp = gpar(fill = 2:5), \n    axis_param = list(direction = \"reverse\"), \n    bar_width = 1, width = unit(4, \"cm\"))) +\nrowAnnotation(axis_normal = anno_barplot(m, gp = gpar(fill = 2:5), \n    bar_width = 1, width = unit(4, \"cm\")))\ndraw(ha_list, ht_gap = unit(4, \"mm\"))\nha = HeatmapAnnotation(foo = anno_barplot(1:10, add_numbers = TRUE, \n    height = unit(1, \"cm\")))\nha = HeatmapAnnotation(foo = anno_barplot(matrix(nc = 2, c(1:10, 10:1)), \n    beside = TRUE))\nha = HeatmapAnnotation(foo = anno_barplot(matrix(nc = 2, c(1:10, 10:1)), \n    beside = TRUE, attach = TRUE))"},{"path":"heatmap-annotations.html","id":"box-annotation","chapter":"3 Heatmap Annotations","heading":"3.9 Boxplot annotation","text":"Boxplot annotation well annotation functions introduced\nlater suitable small matrice. don’t think want put\nboxplots column annotation matrix 100 columns.anno_boxplot(), input data variable matrix list. \nx matrix column annotation, statistics boxplots \ncalculated columns, row annotation, calculation done\nrows.Graphic parameters controlled gp.Width boxes controlled box_width. outline controls whether \nshow outlier points.anno_boxplot() draws one boxplot one single row. Section\n14.6 demonstrates define annotation function \ndraws multiple boxplots single row, Section 3.18\ndemonstrates draw one single boxplot group rows.","code":"\nset.seed(12345)\nm = matrix(rnorm(100), 10)\nha = HeatmapAnnotation(foo = anno_boxplot(m, height = unit(4, \"cm\")))\nha = HeatmapAnnotation(foo = anno_boxplot(m, height = unit(4, \"cm\"), \n    gp = gpar(fill = 1:10)))\nha = HeatmapAnnotation(foo = anno_boxplot(m, height = unit(4, \"cm\"), \n    box_width = 0.9, outline = FALSE))"},{"path":"heatmap-annotations.html","id":"histogram-annotation","chapter":"3 Heatmap Annotations","heading":"3.10 Histogram annotation","text":"Annotations histograms suitable put row annotations. \nsetting data variable anno_boxplot() can \nmatrix list.Similar anno_boxplot(), input data variable matrix list. \nx matrix column annotation, histograms \ncalculated columns, row annotation, histograms calculated\nrows.Number breaks histograms controlled n_breaks.Colors controlled gp.","code":"\nm = matrix(rnorm(1000), nc = 100)\nha = rowAnnotation(foo = anno_histogram(m)) # apply `m` on rows\nha = rowAnnotation(foo = anno_histogram(m, n_breaks = 20))\nha = rowAnnotation(foo = anno_histogram(m, gp = gpar(fill = 1:10)))"},{"path":"heatmap-annotations.html","id":"density-annotation","chapter":"3 Heatmap Annotations","heading":"3.11 Density annotation","text":"Similar histogram annotations, anno_density() shows distribution\nfitted curve.height density peaks can controlled make distribution\nlook like “joyplot”.visualize distribution violin plot.many rows input variable, space normal\ndensity peaks might small. case, can visualize \ndistribution heatmaps.color schema heatmap distribution controlled heatmap_colors.ComplexHeatmap package, densityHeatmap() function \nvisualizes distribution heatmap. introduced Section\n11.1.","code":"\nha = rowAnnotation(foo = anno_density(m))\nha = rowAnnotation(foo = anno_density(m, joyplot_scale = 2, \n    gp = gpar(fill = \"#CCCCCC80\")))\nha = rowAnnotation(foo = anno_density(m, type = \"violin\", \n    gp = gpar(fill = 1:10)))\nm2 = matrix(rnorm(50*10), nrow = 50)\nha = rowAnnotation(foo = anno_density(m2, type = \"heatmap\", width = unit(6, \"cm\")))\nha = rowAnnotation(foo = anno_density(m2, type = \"heatmap\", width = unit(6, \"cm\"), \n    heatmap_colors = c(\"white\", \"orange\")))"},{"path":"heatmap-annotations.html","id":"joyplot-annotation","chapter":"3 Heatmap Annotations","heading":"3.12 Joyplot annotation","text":"anno_joyplot() specific -called joyplot (http://blog.revolutionanalytics.com/2017/07/joyplots.html).\ninput data matrix list.Note anno_joyplot() always applied columns input matrix.\njoyplot visualizes parallel distributions matrix \nnecessary format list already enough , sure\nset matrix, just convert list using .show lines (scale argument controls relative height \ncurves).format input variable special. can one following\ntwo:matrix (remember anno_joyplot() always applied columns \nmatrix) x coordinate corresponds 1:nrow(matrix) column\nmatrix corresponds one distribution joyplot.list data frames data frame two columns \ncorrespond x coordinate y coordinate.","code":"\nm = matrix(rnorm(1000), nc = 10)\nlt = apply(m, 2, function(x) data.frame(density(x)[c(\"x\", \"y\")]))\nha = rowAnnotation(foo = anno_joyplot(lt, width = unit(4, \"cm\"), \n    gp = gpar(fill = 1:10), transparency = 0.75))\nm = matrix(rnorm(5000), nc = 50)\nlt = apply(m, 2, function(x) data.frame(density(x)[c(\"x\", \"y\")]))\nha = rowAnnotation(foo = anno_joyplot(lt, width = unit(4, \"cm\"), gp = gpar(fill = NA), \n    scale = 4))"},{"path":"heatmap-annotations.html","id":"horizon-chart-annotation","chapter":"3 Heatmap Annotations","heading":"3.13 Horizon chart annotation","text":"Horizon\nchart\nannotation can added row annotation. format input\nvariable anno_horizon() anno_joyplot() \nintroduced previous section.default style horizon chart annotation :Values track normalized x/max(abs(x)).Colors positive values negative values controlled pos_fill\nneg_fill gpar().pos_fill neg_fill can assigned vector.Whether peaks negative values start bottom top.space every two neighbouring charts.","code":"\nlt = lapply(1:20, function(x) cumprod(1 + runif(1000, -x/100, x/100)) - 1)\nha = rowAnnotation(foo = anno_horizon(lt))\nha = rowAnnotation(foo = anno_horizon(lt, \n    gp = gpar(pos_fill = \"orange\", neg_fill = \"darkgreen\")))\nha = rowAnnotation(foo = anno_horizon(lt, \n    gp = gpar(pos_fill = rep(c(\"orange\", \"red\"), each = 10),\n              neg_fill = rep(c(\"darkgreen\", \"blue\"), each = 10))))\nha = rowAnnotation(foo = anno_horizon(lt, negative_from_top = TRUE))\nha = rowAnnotation(foo = anno_horizon(lt, gap = unit(1, \"mm\")))"},{"path":"heatmap-annotations.html","id":"text-annotation","chapter":"3 Heatmap Annotations","heading":"3.14 Text annotation","text":"Text can used annotations anno_text(). Graphics parameters controlled\ngp.Locationsn controlled location just. Rotation controlled rot.location just automatically calculated according position\nannotations put heatmap (e.g. text aligned left \nright annotation heatmap aligned right \nleft annotation).width/height automatically calculated based text. Normally\ndon’t need manually set width/height .Background colors can set gp. fill controls filled\nbackground color, col controls color text non-standard\nborder controls background border color.can see explicitly set width 1.2 times width longest\ntext.complicated texts can drawn integrating gridtext\npackage (Section 10.3.3). quick example follows:Unlike annotations, default annotation title text annotation. title\ncan added setting show_name = TRUE anno_text():","code":"\nha = rowAnnotation(foo = anno_text(month.name, gp = gpar(fontsize = 1:12+4)))\nha = rowAnnotation(foo = anno_text(month.name, location = 1, rot = 30, \n    just = \"right\", gp = gpar(fontsize = 1:12+4)))\nha = rowAnnotation(foo = anno_text(month.name, location = 0.5, just = \"center\"))\nha = rowAnnotation(foo = anno_text(month.name, location = 0.5, just = \"center\",\n    gp = gpar(fill = rep(2:4, each = 4), col = \"white\", border = \"black\"),\n    width = max_text_width(month.name)*1.2))\ntext = sapply(LETTERS[1:10], function(x) {\n    qq(\"<span style='color:red'>**@{x}**<sub>@{x}<\/sub><\/span>_@{x}_<sup>@{x}<\/sup>\")\n})\nha = rowAnnotation(\n    foo = anno_text(gt_render(text, align_widths = TRUE, \n                        r = unit(2, \"pt\"),\n                        padding = unit(c(2, 2, 2, 2), \"pt\")), \n                    gp = gpar(box_col = \"blue\", box_lwd = 2), \n                    just = \"right\", \n                    location = unit(1, \"npc\")\n    ))\nm = matrix(rnorm(100), 10)\nHeatmap(m) + rowAnnotation(month = anno_text(month.name[1:10], just = \"center\", \n        location = unit(0.5, \"npc\"), show_name = TRUE), \n    annotation_name_rot = 0)"},{"path":"heatmap-annotations.html","id":"anno-numeric","chapter":"3 Heatmap Annotations","heading":"3.15 Numeric labels annotation","text":"special text annotation numeric labels. emphasize visual effect,\nalso want add bars show absolute values numbers. can \ndone anno_numeric() function. Note currently supports row annotation.Background colors can controlled bg_gp.align_to can set \"right\" \"left\":Format labels plot can controlled labels_format:also possible show numeric vector negative positive values.\ncase, graphics parameters length two first one\ncontrols negative values second controls positive values.Another example visualize vector p-values. apply -log10()\np-values mapping bar heights x_convert argument:","code":"\nx = round(runif(10), 3)\nha = rowAnnotation(numeric = anno_numeric(x), annotation_name_rot = 0)\nha = rowAnnotation(numeric = anno_numeric(x, \n        bg_gp = gpar(fill = \"orange\", col = \"black\")),\n    annotation_name_rot = 0)\nha = rowAnnotation(numeric = anno_numeric(x, \n        bg_gp = gpar(fill = \"orange\", col = \"black\"),\n        align_to = \"right\"),\n    annotation_name_rot = 0)\nha = rowAnnotation(numeric = anno_numeric(x,\n        labels_format = function(x) paste0(sprintf(\"%.2f\", x*100), \"%\")),\n    annotation_name_rot = 0)\nx = round(runif(10, -1, 1), 3)\nha = rowAnnotation(numeric = anno_numeric(x, \n        bg_gp = gpar(fill = c(\"green\", \"red\"))), \n    annotation_name_rot = 0)\nx = 10^(-runif(10, 1, 6))\nha = rowAnnotation(pvalue = anno_numeric(x, \n        rg = c(min(x), 1),\n        x_convert = function(x) -log10(x), \n        labels_format = function(x) sprintf(\"%.2e\", x)),\n    annotation_name_rot = 0)"},{"path":"heatmap-annotations.html","id":"completely-customized-annotation","chapter":"3 Heatmap Annotations","heading":"3.16 Completely customized annotation","text":"annotation functions implemented ComplexHeatmap, \ndraw one type annotation graphics, e.g. anno_points() draws\npoints anno_image() draws images. ComplexHeatmap version 2.9.4, added new annotation\nfunction anno_customize(), can completely freely define\ngraphics every annotation cell.input anno_customize() categorical vector.level, need define graphics function .adding graphics, annotation cell independent viewport, thus, self-defined graphics function accepts four arguments: x y: center\nviewport annotation cell, w h: width height viewport. example , set horizontal bar \"\", text \"b\",\npoint \"c\" image \"d\".add new annotation row column heatmap, just way normal annotations.Reordering splitting automatically adjusted.Legend() function also accepts graphics argument, easy add\nlegends “customized annotations.” use Legend() function \nintroduced Chapter 5.","code":"\nx = c(\"a\", \"a\", \"a\", \"b\", \"b\", \"b\", \"c\", \"c\", \"d\", \"d\")\ngraphics = list(\n    \"a\" = function(x, y, w, h) {\n        grid.rect(x, y, w*0.8, h*0.33, gp = gpar(fill = \"red\"))\n    },\n    \"b\" = function(x, y, w, h) {\n        grid.text(\"A\", x, y, gp = gpar(col = \"darkgreen\"))\n    },\n    \"c\" = function(x, y, w, h) {\n        grid.points(x, y, gp = gpar(col = \"orange\"), pch = 16)\n    },\n    \"d\" = function(x, y, w, h) {\n        img = png::readPNG(system.file(\"extdata\", \"Rlogo.png\", package = \"circlize\"))\n        grid.raster(img, x, y, width = unit(0.8, \"snpc\"), \n            height = unit(0.8, \"snpc\")*nrow(img)/ncol(img))\n    }\n)\nm = matrix(rnorm(100), 10)\nHeatmap(m, \n    top_annotation = HeatmapAnnotation(foo = anno_customize(x, graphics = graphics)),\n    right_annotation = rowAnnotation(bar = anno_customize(x, graphics = graphics)))\nHeatmap(m, \n    top_annotation = HeatmapAnnotation(foo = anno_customize(x, graphics = graphics)),\n    right_annotation = rowAnnotation(bar = anno_customize(x, graphics = graphics)),\n    column_split = x, row_split = x)\nm = matrix(rnorm(100), 10)\nht = Heatmap(m, \n    top_annotation = HeatmapAnnotation(foo = anno_customize(x, graphics = graphics)))\nlgd = Legend(title = \"foo\", at = names(graphics), graphics = graphics)\ndraw(ht, annotation_legend_list = lgd)"},{"path":"heatmap-annotations.html","id":"mark-annotation","chapter":"3 Heatmap Annotations","heading":"3.17 Mark annotation","text":"Sometimes many rows columns heatmap want mark\n. anno_mark() used mark subset rows columns \nconnect labels lines.anno_mark() least needs two arguments indices \noriginal matrix labels corresponding text.calculation positions texts depends absolute size graphics\ndevice. resize current interactive device use grid.grabExpr()\ncapture current plot, might see positions texts corrupt.\nPlease refer Section 10.2 solution.","code":"\nm = matrix(rnorm(1000), nrow = 100)\nrownames(m) = 1:100\nha = rowAnnotation(foo = anno_mark(at = c(1:4, 20, 60, 97:100), \n    labels = month.name[1:10]))\nHeatmap(m, name = \"mat\", cluster_rows = FALSE, right_annotation = ha,\n    row_names_side = \"left\", row_names_gp = gpar(fontsize = 4))\nHeatmap(m, name = \"mat\", cluster_rows = FALSE, right_annotation = ha,\n    row_names_side = \"left\", row_names_gp = gpar(fontsize = 4), row_km = 4)"},{"path":"heatmap-annotations.html","id":"zoom-annotation","chapter":"3 Heatmap Annotations","heading":"3.18 Zoom/link annotation","text":"anno_mark() connects single row column heatmap label, \nnext annotation function anno_link() connects subsets rows columns \nplotting regions comprehensive graphics can added .\nSee following example make boxplot every row group.important arguments anno_zoom() :align_to: defines plotting regions (boxes) correspond\nrows columns heatmap. value list \nindices, box corresponds rows columns indices one\nvector list. value categorical variable (e.g. factor\ncharacter vector) length rows columns \nheatmap, box corresponds rows/columns level \ncategorical variable.panel_fun: self-defined function defines draw graphics \nbox. function must index argument indices \nrows/columns box corresponds . can second argument\nnm “name” selected part heatmap. \ncorresponding value nm comes align_to specified \ncategorical variable list names.size: size boxes. can pure numeric treated \nrelative fractions total height/width heatmap. value \nsize can also absolute units.gap: Gaps boxes. unit object.previous example, align_to set categorical variable. next\nexample, align_to set list indicies cover slices “” “b.”anno_link() also works column annotations.Similar anno_mark(), positions plotting regions also depends\nabsolute size graphic device. resize current\ninteractive device use grid.grabExpr() capture current plot,\nmight see positions texts corrupt. Please refer Section\n10.2 solution.show previous examples, anno_link() normally works together \nrow_split/column_split associate additional graphics slices. However,\nnecessary, long rows indices align_to continuously\nadjacent heatmaps.","code":"\nset.seed(123)\nm = matrix(rnorm(100*10), nrow = 100)\nsubgroup = sample(letters[1:3], 100, replace = TRUE, prob = c(1, 5, 10))\nrg = range(m)\npanel_fun = function(index, nm) {\n    pushViewport(viewport(xscale = rg, yscale = c(0, 2)))\n    grid.rect()\n    grid.xaxis(gp = gpar(fontsize = 8))\n    grid.boxplot(m[index, ], pos = 1, direction = \"horizontal\")\n    popViewport()\n}\nanno = anno_link(align_to = subgroup, which = \"row\", panel_fun = panel_fun, \n    size = unit(2, \"cm\"), gap = unit(1, \"cm\"), width = unit(4, \"cm\"))\nHeatmap(m, name = \"mat\", right_annotation = rowAnnotation(foo = anno), \n    row_split = subgroup)\nalign_to = split(1:nrow(m), subgroup)\nalign_to = align_to[c(\"a\", \"b\")]\nanno = anno_link(align_to = align_to, which = \"row\", panel_fun = panel_fun, \n    size = unit(2, \"cm\"), gap = unit(1, \"cm\"), width = unit(4, \"cm\"))\nHeatmap(m, name = \"mat\", right_annotation = rowAnnotation(foo = anno), \n    row_split = subgroup)\nalign_to = list(1:20)\nanno = anno_link(align_to = align_to, which = \"row\", panel_fun = panel_fun, \n    size = unit(2, \"cm\"), gap = unit(1, \"cm\"), width = unit(4, \"cm\"))\n# here row indices 1 to 20 are adjacent since no clustering is applied on rows\nHeatmap(m, name = \"mat\", right_annotation = rowAnnotation(foo = anno), \n    cluster_rows = FALSE)"},{"path":"heatmap-annotations.html","id":"anno-text-box","chapter":"3 Heatmap Annotations","heading":"3.19 Text box annotation","text":"ComplexHeatmap 2.11.1, supports drawing text boxes associating \nheatmaps.","code":""},{"path":"heatmap-annotations.html","id":"construct-the-text-box","chapter":"3 Heatmap Annotations","heading":"3.19.1 Construct the text box","text":"Text box annotation depends text box “grob.” text box grob can \nconstructed function textbox_grob(). accpets character vector\nwords phrases/sentences. first demonstrate use words.Following functionn random_text() generates vector random words phrases.Following code shows set graphics parameters:Following code shows set background:Following code shows set spaces words lines, set width\ntext box:Words can added bottom left box top left:Sentences phrases composed several words, extra parameters.\nlongest sentence longer max_width, width longest sentence \nwidth text box. Setting word_wrap = TRUE can adjust text\naccording width text box.Also argument add_new_line can set TRUE sentence single line.Finally, width height text box grob can obtained grobWidth() grobHeight().\nAlso companion function grid.textbox() directly draws text box certain position.","code":"\nrandom_text = function(n, n_words = 1) {\n    sapply(1:n, function(i) {\n         w = replicate(sample(n_words, 1), \n            paste0(sample(letters, sample(4:10, 1)), collapse = \"\"))\n        if(n_words > 1) {\n            paste(w, collapse = \" \")\n        } else {\n            w\n        }\n    })\n}\nset.seed(123)\nwords = random_text(10)\nwords##  [1] \"sncjrkeyti\" \"hgjisd\"     \"kgul\"       \"mgixj\"      \"ugzfbe\"    \n##  [6] \"mrafuoi\"    \"ptfkh\"      \"gpqvrxbdm\"  \"sytvnchpl\"  \"nczg\"\ngrid.newpage()\ngb = textbox_grob(words)\ngrid.draw(gb)\ngrid.newpage()\ngb = textbox_grob(words, gp = gpar(col = 1:10))\ngrid.draw(gb)\ngrid.newpage()\ngb = textbox_grob(words, gp = gpar(fontsize = runif(10, 5, 20)))\ngrid.draw(gb)\ngrid.newpage()\ngb = textbox_grob(words, background_gp = gpar(fill = \"#CCCCCC\", col = \"#808080\"))\ngrid.draw(gb)\ngrid.newpage()\ngb = textbox_grob(words, background_gp = gpar(fill = \"#CCCCCC\", col = NA), \n    round_corners = TRUE)\ngrid.draw(gb)\ngrid.newpage()\ngb = textbox_grob(words, background_gp = gpar(fill = \"#CCCCCC\", col = \"#808080\"), \n    padding = unit(4, \"mm\"))\ngrid.draw(gb)\ngrid.newpage()\ngb = textbox_grob(words, line_space = unit(5, \"mm\"))\ngrid.draw(gb)\ngrid.newpage()\ngb = textbox_grob(words, text_space = unit(5, \"mm\"))\ngrid.draw(gb)\ngrid.newpage()\ngb = textbox_grob(words, max_width = unit(12, \"cm\"))\ngrid.draw(gb)\nfontsize = sort(runif(10, 5, 20))\ngrid.newpage()\ngb = textbox_grob(words, gp = gpar(fontsize = fontsize))\ngrid.draw(gb)\ngrid.newpage()\ngb = textbox_grob(words, gp = gpar(fontsize = fontsize), \n    first_text_from = \"bottom\")\ngrid.draw(gb)\nsentences = random_text(5, 8)\nsentences## [1] \"ihztacybvx gmtnpzdyls\"                               \n## [2] \"ilhgo qkgscf djqphuclne fiatnsebx\"                   \n## [3] \"dkevzsc gewi xque bvrdjoh\"                           \n## [4] \"ekoxjw\"                                              \n## [5] \"lidcgxh exfdckjz kjos jmxcrzh jgyfqta jmzbovhc fnosi\"\nfontsize = runif(5, 5, 20)\ngrid.newpage()\ngb = textbox_grob(sentences, gp = gpar(col = 1:5, fontsize = fontsize))\ngrid.draw(gb)\ngrid.newpage()\ngb = textbox_grob(sentences, gp = gpar(col = 1:5, fontsize = fontsize), \n    word_wrap = TRUE)\ngrid.draw(gb)\ngrid.newpage()\ngb = textbox_grob(sentences, gp = gpar(col = 1:5, fontsize = fontsize), \n    add_new_line = TRUE)\ngrid.draw(gb)\ngrid.newpage()\ngb = textbox_grob(sentences, gp = gpar(col = 1:5, fontsize = fontsize), \n    add_new_line = TRUE, word_wrap = TRUE)\ngrid.draw(gb)\n# code only for demonstration\ngb = textbox_grob(words)\ngrobWidth(gb)\ngrobHeight(gb)\ngrid.textbox(words, x, y)"},{"path":"heatmap-annotations.html","id":"draw-textbox-annotation","chapter":"3 Heatmap Annotations","heading":"3.19.2 Draw textbox annotation","text":"function anno_textbox() draws several text boxes associate heatmaps.\nNote don’t need directly use textbox_grob() function anno_textbox(),\nparameters control texts anno_textbox() directly passed textbox_grob().Since texts already wrapped boxes, text box annotations basically\nimplemented anno_link() anno_block().default, text box annotation implemented anno_link(). Since heights\ntext boxes always height subsets rows correspond ,\nconnections heatmap text boxes. following example,\ngenerated 10 text boxes one linked heatmap slice. case,\nfirst parameter anno_textbox() categorical variable also split heatmap rows.\nsecond parameter text named list character vectors name list\ncorrespond levels split.put left side heatmap:Parameters textbox_grob() can directly passed anno_textbox(). E.g.\ntext sentences, control word wrap new lines:first argument anno_textbox() can also set list indicies. Note\nindices rows continuously adjacent heatmaps.anno_textbox() works mainly together row_split associate information\nevery heatmap slice. necessary, long can ensure indices\ncontinuously adjacent heatmaps. next example, rows clustered,\nadd two text boxed correspond row 1-10 row 11-30.cases users want put text boxes exactly positions\ncorresponding heatmap slices. case, argument \nset \"anno_block\". now anno_block() internally used implement text\nbox annotations.Similarly, first parameter can set list indicies:far, texts assigned random colors. Now question \nexactly control graphics parameters texts text boxes. previous examples,\nvalue text list character vectors. graphics parameters can\nintegrated text setting text list data frames. data\nframe, first column contains texts put boxes. data frame\ncan also contains following four columns (\"col\", \"fontsize\", \"fontfamily\"\n\"fontface\") exactly control corresponding text.simplifyEnrichment package,\nuse anno_textbox() implement word cloud annotation visualize\nsummaries biological functions GO cluster.","code":"\nmat = matrix(rnorm(100*10), nrow = 100)\nsplit = sample(letters[1:10], 100, replace = TRUE)\ntext = lapply(unique(split), function(x) {\n    random_text(10)\n})\nnames(text) = unique(split)\n\nHeatmap(mat, name = \"mat\", cluster_rows = FALSE, row_split = split,\n    right_annotation = rowAnnotation(textbox = anno_textbox(split, text))\n)\nHeatmap(mat, name = \"mat\", cluster_rows = FALSE, row_split = split, row_title = NULL,\n    left_annotation = rowAnnotation(textbox = anno_textbox(split, text, side = \"left\"))\n)\nsplit = sample(letters[1:5], 100, replace = TRUE)\nsentences = lapply(unique(split), function(x) {\n    random_text(3, 8)\n})\nnames(sentences) = unique(split)\n\nHeatmap(mat, name = \"mat\", row_split = split,\n    right_annotation = rowAnnotation(\n        textbox = anno_textbox(\n            split, sentences, \n            word_wrap = TRUE, \n            add_new_line = TRUE)\n    )\n)\nalign_to = split(seq_along(split), split)\nHeatmap(mat, name = \"mat\", row_split = split,\n    right_annotation = rowAnnotation(\n        textbox = anno_textbox(\n            align_to[c(\"a\", \"b\")], \n            sentences[c(\"a\", \"b\")], # names should match\n            word_wrap = TRUE, \n            add_new_line = TRUE)\n    )\n)\nHeatmap(mat, name = \"mat\", cluster_rows = FALSE,\n    right_annotation = rowAnnotation(\n        textbox = anno_textbox(\n            list(\"a\" = 1:10, \"b\" = 11:30), \n            sentences[c(\"a\", \"b\")], \n            word_wrap = TRUE, \n            add_new_line = TRUE)\n    )\n)\nsplit = rep(letters[1:10], 10)\ntext = lapply(unique(split), function(x) {\n    random_text(10)\n})\nnames(text) = unique(split)\n\nHeatmap(mat, name = \"mat\", row_split = split,\n    right_annotation = rowAnnotation(\n        textbox = anno_textbox(split, text, by = \"anno_block\")\n    )\n)\nalign_to = split(seq_along(split), split)\nHeatmap(mat, name = \"mat\", row_split = split,\n    right_annotation = rowAnnotation(\n        textbox = anno_textbox(\n            align_to[c(\"a\", \"b\")], \n            text[c(\"a\", \"b\")], # names should match\n            by = \"anno_block\")\n    )\n)\nHeatmap(mat, name = \"mat\", cluster_rows = FALSE,\n    right_annotation = rowAnnotation(\n        textbox = anno_textbox(\n            list(\"a\" = 1:10, \"b\" = 50:70), \n            text[c(\"a\", \"b\")], \n            by = \"anno_block\"))\n)\nsplit = rep(letters[1:5], 20)\ntext = lapply(unique(split), function(x) {\n    df = data.frame(text = random_text(10))\n    df$fontsize = runif(10, 6, 20)\n    if(runif(1) > 0.5) {\n        df$col = rep(rand_color(1), 10)\n    } else {\n        df$col = 1:10\n    }\n    df\n})\nnames(text) = unique(split)\nhead(text[[1]])##         text  fontsize       col\n## 1 gixsnwmyjr 16.409436 #E80DF8FF\n## 2    klxdszq 14.065497 #E80DF8FF\n## 3    nmyaiko 10.148988 #E80DF8FF\n## 4  iytaznevh  9.719641 #E80DF8FF\n## 5  wbqlhxiof 19.864118 #E80DF8FF\n## 6   zaovsbwe 14.295501 #E80DF8FF\nHeatmap(mat, name = \"mat\", cluster_rows = FALSE, row_split = split,\n    right_annotation = rowAnnotation(textbox = anno_textbox(split, text))\n)"},{"path":"heatmap-annotations.html","id":"summary-annotation","chapter":"3 Heatmap Annotations","heading":"3.20 Summary annotation","text":"one special annotation anno_summary() works \none-column heatmap one-row heatmap (can say heatmap contains \nvector). shows summary statistics vector heatmap. \ncorresponding vector discrete, summary annotation presented \nbarplots vector continuous, summary annotation boxplot.\nanno_summary() always used heatmap split statistics\ncan compared heatmap slices.first example shows summary annotation discrete heatmap. \nbarplot shows proportion level slice. absolute values\ncan already seen height heatmap slice.color schema barplots automatically extracted heatmap.second example shows summary annotation continuous heatmap. \ngraphic parameters manually set gp. legend boxplot\ncan created added introduced Section 5.2,\nlast second paragraph.Normally don’t draw one-column heatmap along. always combined\n“main heatmaps.” E.g. gene expression matrix one-column\nheatmap shows whether gene protein coding gene linc-RNA\ngene.following, show simple example “main heatmap” two one-column\nheatmaps. functionality heatmap concatenation introduced \nChapter 4.","code":"\nha = HeatmapAnnotation(summary = anno_summary(height = unit(4, \"cm\")))\nv = sample(letters[1:2], 50, replace = TRUE)\nsplit = sample(letters[1:2], 50, replace = TRUE)\n\nHeatmap(v, name = \"mat\", col = c(\"a\" = \"red\", \"b\" = \"blue\"),\n    top_annotation = ha, width = unit(2, \"cm\"), row_split = split)\nha = HeatmapAnnotation(summary = anno_summary(gp = gpar(fill = 2:3), \n    height = unit(4, \"cm\")))\nv = rnorm(50)\nHeatmap(v, name = \"mat\", top_annotation = ha, width = unit(2, \"cm\"), \n    row_split = split)\nm = matrix(rnorm(50*10), nrow = 50)\nht_list = Heatmap(m, name = \"main_matrix\")\n\nha = HeatmapAnnotation(summary = anno_summary(height = unit(3, \"cm\")))\nv = sample(letters[1:2], 50, replace = TRUE)\nht_list = ht_list + Heatmap(v, name = \"mat1\", top_annotation = ha, width = unit(1, \"cm\"))\n\nha = HeatmapAnnotation(summary = anno_summary(gp = gpar(fill = 2:3), \n    height = unit(3, \"cm\")))\nv = rnorm(50)\nht_list = ht_list + Heatmap(v, name = \"mat2\", top_annotation = ha, width = unit(1, \"cm\"))\n\nsplit = sample(letters[1:2], 50, replace = TRUE)\nlgd_boxplot = Legend(labels = c(\"group a\", \"group b\"), title = \"group\",\n    legend_gp = gpar(fill = c(\"red\", \"blue\")))\ndraw(ht_list, row_split = split, ht_gap = unit(5, \"mm\"), \n    heatmap_legend_list = list(lgd_boxplot))"},{"path":"heatmap-annotations.html","id":"multiple-annotations","chapter":"3 Heatmap Annotations","heading":"3.21 Multiple annotations","text":"","code":""},{"path":"heatmap-annotations.html","id":"heatmap-annotation-general-settings","chapter":"3 Heatmap Annotations","heading":"3.21.1 General settings","text":"mentioned , put multiple annotations HeatmapAnnotation(),\njust need specified name-value pairs. HeatmapAnnotation(),\narguments controls multiple annotations. \narguments, specified vector length number \nannotations, named vector subset annotations.simple annotations specified vectors, matrices data\nframes automatically legends heatmap. show_legend controls\nwhether draw legends . Note show_legend vector,\nvalue show_legend one following formats:logical vector length number simple annotations.logical vector length number totla annotations. \nvalues complex annotations ignored.named vector control subset simple annotations.customization annotation legends, please refer Section 5.4.gp controls graphic parameters (except fill) simple annotatios,\nborder annotation grids.border controls border every single annotations.\nshow_annotation_name controls whether show annotation names. mentioned,\nvalue can single value, vector named vector.annotation_name_gp, annotation_name_offset, annotation_name_side \nannotation_name_rot control style position annotation names.\nlatter three can specified named vectors. \nannotation_name_offset specified named vector, can specified\ncharacters unit objects: annotation_name_offset = c(foo = \"1cm\").gap controls space every two neighbouring annotations. value\ncan single unit vector units.","code":"\nha = HeatmapAnnotation(foo = 1:10, \n    bar = cbind(1:10, 10:1),\n    pt = anno_points(1:10),\n    show_legend = c(\"bar\" = FALSE)\n)\nHeatmap(matrix(rnorm(100), 10), name = \"mat\", top_annotation = ha)\nha = HeatmapAnnotation(foo = 1:10, \n    bar = cbind(1:10, 10:1),\n    pt = anno_points(1:10),\n    gp = gpar(col = \"red\")\n)\nha = HeatmapAnnotation(foo = 1:10, \n    bar = cbind(1:10, 10:1),\n    pt = anno_points(1:10),\n    show_annotation_name = c(bar = FALSE), # only turn off `bar`\n    border = c(foo = TRUE) # turn on foo\n)\nha = HeatmapAnnotation(foo = 1:10, \n    bar = cbind(1:10, 10:1),\n    pt = anno_points(1:10),\n    gap = unit(2, \"mm\"))\nha = HeatmapAnnotation(foo = 1:10, \n    bar = cbind(1:10, 10:1),\n    pt = anno_points(1:10),\n    gap = unit(c(2, 10), \"mm\"))"},{"path":"heatmap-annotations.html","id":"size-of-annotations","chapter":"3 Heatmap Annotations","heading":"3.21.2 Size of annotations","text":"height, width, annotation_height annotation_width control \nheight width complete heatmap annotations. Normally don’t need\nset single annotations fixed height/width \nfinal height/width whole heatmap annotation sum .\nResizing values involve rather complicated adjustment depending \nwhether simple annotation complex annotation. resizing \nheatmap annotations also happen adjusting list heatmaps. \nfollowing examples, take column annotations examples demonstrate\nscenarios resizing adjustment.First default height ha:height set, size simple annotation change, \ncomplex annotations adjusted. multiple complex\nannotations, adjusted according ratio original size.simple_anno_size controls height simple annotations. Recall\nht_opt$simple_anno_size can set globally control size simple\nannotations heatmaps.annotation_height set vector absolute units, height \nthree annotations adjusted accordingly.annotation_height set pure numbers treated relative\nratios annotations, height also set absolute unit \nsize every single annotation adjusted ratios.annotation_height can mixed relative units (null unit) \nabsolute units.simple annotations, simply setting height won’t change \nheight.unless simple_anno_size_adjust set TRUE.Section 4.6 introduces \nannotation sizes adjusted among list heatmaps.","code":"\n# foo: 1cm, bar: 5mm, pt: 1cm\nha = HeatmapAnnotation(foo = cbind(1:10, 10:1), \n    bar = 1:10,\n    pt = anno_points(1:10))\n# foo: 1cm, bar: 5mm, pt: 4.5cm\nha = HeatmapAnnotation(foo = cbind(1:10, 10:1), \n    bar = 1:10,\n    pt = anno_points(1:10),\n    height = unit(6, \"cm\"))\n# foo: 2cm, bar:1cm, pt: 3cm\nha = HeatmapAnnotation(foo = cbind(1:10, 10:1), \n    bar = 1:10,\n    pt = anno_points(1:10),\n    simple_anno_size = unit(1, \"cm\"), height = unit(6, \"cm\"))\n# foo: 1cm, bar: 2cm, pt: 3cm\nha = HeatmapAnnotation(foo = cbind(1:10, 10:1), \n    bar = 1:10,\n    pt = anno_points(1:10),\n    annotation_height = unit(1:3, \"cm\"))\n# foo: 1cm, bar: 2cm, pt: 3cm\nha = HeatmapAnnotation(foo = cbind(1:10, 10:1), \n    bar = 1:10,\n    pt = anno_points(1:10),\n    annotation_height = 1:3, height = unit(6, \"cm\"))\n# foo: 1.5cm, bar: 1.5cm, pt: 3cm\nha = HeatmapAnnotation(foo = cbind(1:10, 10:1), \n    bar = 1:10,\n    pt = anno_points(1:10),\n    annotation_height = unit(c(1, 1, 3), c(\"null\", \"null\", \"cm\")), height = unit(6, \"cm\")\n)\n# foo: 2cm, bar: 1cm, pt: 3cm\nha = HeatmapAnnotation(foo = cbind(1:10, 10:1), \n    bar = 1:10,\n    pt = anno_points(1:10),\n    annotation_height = unit(c(2, 1, 3), c(\"cm\", \"null\", \"cm\")), height = unit(6, \"cm\")\n)\n# foo: 1cm, bar: 5mm\nha = HeatmapAnnotation(foo = cbind(1:10, 10:1), \n    bar = 1:10,\n    height = unit(6, \"cm\"))\n# foo: 4cm, bar: 2cm\nha = HeatmapAnnotation(foo = cbind(1:10, 10:1), \n    bar = 1:10,\n    height = unit(6, \"cm\"),\n    simple_anno_size_adjust = TRUE)"},{"path":"heatmap-annotations.html","id":"annotation-labels","chapter":"3 Heatmap Annotations","heading":"3.21.3 Annotation labels","text":"version 2.3.3, alternative labels annotations can set annotation_label argument:Annotation labels can also set complex text:rows:","code":"\nha = HeatmapAnnotation(foo = 1:10, \n    bar = cbind(1:10, 10:1),\n    pt = anno_points(1:10),\n    annotation_label = c(\"Annotation_foo\", \"Annotation_bar\", \"Annotation_pt\")\n)\nha = HeatmapAnnotation(foo = 1:10, \n    bar = cbind(1:10, 10:1),\n    pt = anno_points(1:10),\n    annotation_label = gt_render(\n        c(\"**Anno**_<span style='color:red'>foo<\/span>\", \n          \"**Anno**_<span style='color:blue'>bar<\/span>\", \n          \"**Anno**_<span style='color:green'>pt<\/span>\"),\n        gp = gpar(box_fill = \"grey\")\n    )\n)\nHeatmap(matrix(rnorm(100), 10), name = \"mat\", top_annotation = ha)\nha = HeatmapAnnotation(foo = 1:10, \n    bar = cbind(1:10, 10:1),\n    pt = anno_points(1:10),\n    annotation_name_rot = 45\n)\nHeatmap(matrix(rnorm(100), 10), name = \"mat\", top_annotation = ha)\nha = rowAnnotation(foo = 1:10, \n    bar = cbind(1:10, 10:1),\n    pt = anno_points(1:10),\n    annotation_name_rot = 45\n)\nHeatmap(matrix(rnorm(100), 10), name = \"mat\", left_annotation = ha)"},{"path":"heatmap-annotations.html","id":"heatmap-annotation-utility-function","chapter":"3 Heatmap Annotations","heading":"3.22 Utility functions","text":"utility functions make manipulation heatmap\nannotation easier. Just see following examples.Get set names annotations:can concatenate two HeatmapAnnotation objects contain \nnumber observations different annotation names.HeatmapAnnotation object sometimes subsettable. row index corresponds\nobservations annotation column index corresponds \nannotations. annotations simple annotations complex\nannotation created anno_*() functions ComplexHeatmap package, \nHeatmapAnnotation object always subsettable.construction heatmaps annotations can separated, later annotations\ncan filled heatmap objects attach_annotation() function.","code":"\nha = HeatmapAnnotation(foo = 1:10, \n    bar = cbind(1:10, 10:1),\n    pt = anno_points(1:10))\nlength(ha)## [1] 3\nnobs(ha)## [1] 10\nnames(ha)## [1] \"foo\" \"bar\" \"pt\"\nnames(ha) = c(\"FOO\", \"BAR\", \"PT\")\nnames(ha)## [1] \"FOO\" \"BAR\" \"PT\"\nha1 = HeatmapAnnotation(foo = 1:10, \n    bar = cbind(1:10, 10:1),\n    pt = anno_points(1:10))\nha2 = HeatmapAnnotation(FOO = runif(10), \n    BAR = sample(c(\"a\", \"b\"), 10, replace = TRUE),\n    PT = anno_points(rnorm(10)))\nha = c(ha1, ha2)\nnames(ha)## [1] \"foo\" \"bar\" \"pt\"  \"FOO\" \"BAR\" \"PT\"\nha_subset = ha[1:5, c(\"foo\", \"PT\")]\nha_subset## A HeatmapAnnotation object with 2 annotations\n##   name: heatmap_annotation_136 \n##   position: column \n##   items: 5 \n##   width: 1npc \n##   height: 15.3514598035146mm \n##   this object is subsettable\n##   5.21733333333333mm extension on the left \n##   6.75733333333333mm extension on the right \n## \n##  name   annotation_type color_mapping height\n##   foo continuous vector        random    5mm\n##    PT     anno_points()                 10mm\n# code only for demonstration\nha1 = HeatmapAnnotation(foo = 1:10)\nha2 = rowAnnotation(bar = letters[1:10])\nht = Heatmap(mat)\nht = attach_annotation(ht, ha1, side = \"top\")\nht = attach_annotation(ht, ha2, side = \"left\")"},{"path":"heatmap-annotations.html","id":"implement-new-annotation-functions","chapter":"3 Heatmap Annotations","heading":"3.23 Implement new annotation functions","text":"annotation functions defined ComplexHeatmap constructed \nAnnotationFunction class. AnnotationFunction class stores\n“real R function” draws graphics, also calculates spaces\nproduced annotation axis. importantly, allows splitting \nannotation graphics according split main heatmap.expected, main part AnnotationFunction class function\ndefines draw specific positions correspond rows \ncolumns heatmap. function three arguments: index, k\nn (names arguments can arbitrary) k n \noptional. index corresponds indices rows columns \nheatmap. value index necessarily whole row indices\ncolumn indices heatmap. can also subset indices \nannotation split slices according split heatmap.\nindex reordered according reordering heatmap rows columns\n(e.g. clustering). , index actually contains list row column\nindices current slice row column reordering.mentioned, annotation can split slices. k corresponds \ncurrent slice n corresponds total number slices. \nannotation function draws every slice repeatedly. information k\nn sometimes can useful, example, want add axis \nannotation, column annotation axis drawn \nright annotation area, axis drawn k == n.Since function allows index, k n, function sometimes\nuses several external variables can defined inside function,\ne.g. data points annotation. variables imported\nAnnotationFunction class var_import function can\ncorrectly find variables.One important feature AnnotationFunction class can subsettable,\nbase splitting. allow subsetting object, users need\ndefine rule imported variables . rules \nsimple functions accpet variable indices, return subset\nvariable. subset rule functions implemented package \nsubset_gp(), subset_matrix_by_row() subset_vector(). \nsubsetting rule provided, inferred type object.following example, first construct AnnotationFunction object needs external\nvariable supports subsetting. annotation contains list “lolipops” (points plus vertical segments) \ndrawn viewport. Y-axis drawn first slices.variable x outside function, added var_import.can assign anno1 HeatmapAnnotation() function. Since anno1 \nsubsettable, can split columns heatmap.second way put data variables inside function need \nimport variables.compact way specify function constructor. allows\nreordering, work split heatmap.anno_*() functions introduced section actually \nreally annotation functions, functions generating annotation\nfunctions specific configurations.cases, don’t need manually construct AnnotationFunction\nobjects. annotation function anno_*() implemented ComplexHeatmap\nalready enough analysis tasks. hand, users\ncan also use anno_empty() decorate_annotation() quickly add\nself-defined annotation graphics. E.g. can re-implement previous heatmap\n(course lengthy):","code":"\nx = 1:10\nanno1 = AnnotationFunction(\n    fun = function(index, k, n) {\n        n = length(index)\n        pushViewport(viewport(xscale = c(0.5, n + 0.5), yscale = c(0, 10)))\n        grid.rect()\n        grid.points(1:n, x[index], default.units = \"native\")\n        grid.segments(1:n, 0, 1:n, x[index], default.units = \"native\")\n        if(k == 1) grid.yaxis()\n        popViewport()\n    },\n    var_import = list(x = x),\n    n = 10,\n    subsettable = TRUE,\n    height = unit(2, \"cm\")\n)\nanno1## An AnnotationFunction object\n##   function: user-defined\n##   position: column \n##   items: 10 \n##   width: 1npc \n##   height: 2cm \n##   imported variable: x \n##   this object is subsettable\nm = rbind(1:10, 11:20)\nHeatmap(m, top_annotation = HeatmapAnnotation(foo = anno1))\nHeatmap(m, top_annotation = HeatmapAnnotation(foo = anno1), \n    column_split = rep(c(\"A\", \"B\"), each = 5))\n# code only for demonstration\nanno2 = AnnotationFunction(\n    fun = function(index) {\n        x = 1:10\n        n = length(index)\n        pushViewport(viewport())\n        grid.points(1:n, x[index])\n        popViewport()\n    },\n    n = 10,\n    subsettable = TRUE\n)\n# code only for demonstration\nanno3 = AnnotationFunction(\n    fun = function(index) {\n        x = 1:10\n        n = length(index)\n        pushViewport(viewport())\n        grid.points(1:n, x[index])\n        popViewport()\n    }\n)\nanno_points(1:10)## An AnnotationFunction object\n##   function: anno_points()\n##   position: column \n##   items: 10 \n##   width: 1npc \n##   height: 1cm \n##   imported variable: data_scale, axis_param, border, size, value, pch_as_image, axis, gp, axis_grob, pch \n##   subsettable variable: gp, value, size, pch \n##   this object is subsettable\n##   5.13831111111111mm extension on the left\nht = Heatmap(m, name = \"mat\",\n    top_annotation = HeatmapAnnotation(foo = anno_empty(height = unit(2, \"cm\"))), \n    column_split = rep(c(\"A\", \"B\"), each = 5))\nht = draw(ht)\nco = column_order(ht)\ndecorate_annotation(\"foo\", slice = 1, {\n    od = co[[1]]\n    pushViewport(viewport(xscale = c(0.5, length(od) + 0.5), yscale = c(0, 10)))\n    grid.points(seq_along(od), x[od])\n    grid.segments(seq_along(od), 0, seq_along(od), x[od], default.units = \"native\")\n    grid.yaxis()\n    popViewport()\n})\ndecorate_annotation(\"foo\", slice = 2, {\n    od = co[[2]]\n    pushViewport(viewport(xscale = c(0.5, length(od) + 0.5), yscale = c(0, 10)))\n    grid.points(seq_along(od), x[od])\n    grid.segments(seq_along(od), 0, seq_along(od), x[od], default.units = \"native\")\n    popViewport()\n})"},{"path":"heatmap-annotations.html","id":"construct-annotation-function-by-cell_fun","chapter":"3 Heatmap Annotations","heading":"3.23.1 Construct annotation function by cell_fun","text":"simplify use AnnotationFunction(), version 2.9.3, new argument cell_fun accepts\nself-defined function draws single “annotation cell.”\nconvenient annotation cells.\nSee following example visualizes percent values text bars.\nActually anno_numeric() (Section 3.15) implemented.Note cell_fun set AnnotationFunction, returned annotation function\nsubsettable, means also works heatmap split.","code":"\nanno_pct = function(x) {\n\n    max_x = max(x)\n    text = paste0(sprintf(\"%.2f\", x*100), \"%\")\n    cell_fun_pct = function(i) {\n        pushViewport(viewport(xscale = c(0, max_x)))\n        grid.roundrect(x = unit(1, \"npc\"), width = unit(x[i], \"native\"), \n            height = unit(1, \"npc\") - unit(4, \"pt\"), \n            just = \"right\", gp = gpar(fill = \"#0000FF80\", col = NA))\n        grid.text(text[i], x = unit(1, \"npc\"), just = \"right\")\n        popViewport()\n    }\n\n    AnnotationFunction(\n        cell_fun = cell_fun_pct,\n        var_import = list(max_x, x, text), \n        which = \"row\",\n        width = max_text_width(text)*1.25\n    )\n}\n\nx = runif(10)\nha = rowAnnotation(foo = anno_pct(x), annotation_name_rot = 0)\n\nm = matrix(rnorm(100), 10)\nrownames(m) = x\nha + Heatmap(m)"},{"path":"a-list-of-heatmaps.html","id":"a-list-of-heatmaps","chapter":"4 A List of Heatmaps","heading":"4 A List of Heatmaps","text":"main feature ComplexHeatmap package supports concatenate \nlist heatmaps annotations horizontally vertically makes\npossible visualize associations various sources information.\nchapter, mainly introduce horizontal concatenation \nmajor case use analysis. end show \nexamples vertical concatenation. concept behind horizontal \nvertical concatenation basically similar.horizontal concatenation, number rows heatmaps \nannotations . following first introduce \nconcatenation heatmaps later show concatenate heatmaps\nannotations.following example, three matrices third heatmap \nvector transformed one-column matrix. one-column\nheatmap sometimes useful concatenate list heatmaps \ncan show e.g. annotations row scores row. E.g. \nrows genes, type genes (.e. protein coding ) can \nrepresented one-column character matrix, p-value fold\nchange differential expression analysis can represented \none-column numeric matrix, concatenated main expression heatmap.concatenate heatmaps, simply use + operator.default mode, dendrograms second heatmap removed \nrow orders first one. Also row names first two\nheatmaps removed well.returned value concatenation HeatmapList object. Similar \nexplained Section 2.11, directly printing ht_list \ncall draw() method default settings. explicitly calling draw()\nmethod, can controls heatmap list.can append number heatmaps heatmap list. Also can append\nheatmap list heatmap list.NULL can added heatmap list. convinient users\nwant construct heatmap list loop.can also add heatmap annotations heatmap list, see details \nSection 4.7.","code":"\nset.seed(123)\nmat1 = matrix(rnorm(80, 2), 8, 10)\nmat1 = rbind(mat1, matrix(rnorm(40, -2), 4, 10))\nrownames(mat1) = paste0(\"R\", 1:12)\ncolnames(mat1) = paste0(\"C\", 1:10)\n\nmat2 = matrix(runif(60, max = 3, min = 1), 6, 10)\nmat2 = rbind(mat2, matrix(runif(60, max = 2, min = 0), 6, 10))\nrownames(mat2) = paste0(\"R\", 1:12)\ncolnames(mat2) = paste0(\"C\", 1:10)\n\nle = sample(letters[1:3], 12, replace = TRUE)\nnames(le) = paste0(\"R\", 1:12)\n\nind = sample(12, 12)\nmat1 = mat1[ind, ]\nmat2 = mat2[ind, ]\nle = le[ind]\nht1 = Heatmap(mat1, name = \"rnorm\")\nht2 = Heatmap(mat2, name = \"runif\")\nht3 = Heatmap(le, name = \"letters\")\n\nht1 + ht2 + ht3\nht_list = ht1 + ht2 + ht3\nclass(ht_list)## [1] \"HeatmapList\"\n## attr(,\"package\")\n## [1] \"ComplexHeatmap\"\n# code only for demonstration\nht1 + ht_list\nht_list + ht1\nht_list + ht_list\n# code only for demonstration\nht_list = NULL  ## Heatmap(...) + NULL gives you a HeatmapList object\nfor(s in sth) {\n    ht_list = ht_list + Heatmap(...)\n}"},{"path":"a-list-of-heatmaps.html","id":"heatmap-list-titles","chapter":"4 A List of Heatmaps","heading":"4.1 Titles","text":"heatmap list also title like global title covering \nheatmaps. row_title column_title set draw()\nfunction.following example, set different colors heatmap make \ndistinguishable.can use gt_render() construct complicated text, see Section 10.3.","code":"\ncol_rnorm = colorRamp2(c(-3, 0, 3), c(\"green\", \"white\", \"red\"))\ncol_runif = colorRamp2(c(0, 3), c(\"white\", \"orange\"))\ncol_letters = c(\"a\" = \"pink\", \"b\" = \"purple\", \"c\" = \"blue\")\nht1 = Heatmap(mat1, name = \"rnorm\", col = col_rnorm,\n    row_title = \"Heatmap 1\", column_title = \"Heatmap 1\")\nht2 = Heatmap(mat2, name = \"runif\", col = col_runif,\n    row_title = \"Heatmap 2\", column_title = \"Heatmap 2\")\nht3 = Heatmap(le, name = \"letters\", col = col_letters)\nht_list = ht1 + ht2 + ht3\n\ndraw(ht_list, row_title = \"Three heatmaps, row title\", row_title_gp = gpar(col = \"red\"),\n    column_title = \"Three heatmaps, column title\", column_title_gp = gpar(fontsize = 16))"},{"path":"a-list-of-heatmaps.html","id":"size-of-heatmaps","chapter":"4 A List of Heatmaps","heading":"4.2 Size of heatmaps","text":"width heatmaps can set absolute units. Note width\ncontrols width heatmap body.width heatmaps can set absolute units.width numeric, converted null unit.heatmap_width also can control width heatmap, total\nwidth heatmap body plus heatmap components.","code":"\nht2 = Heatmap(mat2, name = \"runif\", col = col_runif, width = unit(4, \"cm\"))\nht3 = Heatmap(le, name = \"letters\", col = col_letters, width = unit(5, \"mm\"))\nht1 + ht2 + ht3\nht1 = Heatmap(mat1, name = \"rnorm\", col = col_rnorm, width = unit(4, \"cm\"))\nht2 = Heatmap(mat2, name = \"runif\", col = col_runif, width = unit(6, \"cm\"))\nht3 = Heatmap(le, name = \"letters\", col = col_letters, width = unit(1, \"cm\"))\nht1 + ht2 + ht3\nht1 = Heatmap(mat1, name = \"rnorm\", col = col_rnorm, width = 6)\nht2 = Heatmap(mat2, name = \"runif\", col = col_runif, width = 4)\nht3 = Heatmap(le, name = \"letters\", col = col_letters, width = 1)\nht1 + ht2 + ht3"},{"path":"a-list-of-heatmaps.html","id":"gap-between-heatmaps","chapter":"4 A List of Heatmaps","heading":"4.3 Gap between heatmaps","text":"ht_gap controls space heatmaps. value can single unit\nvector units.","code":"\nht1 = Heatmap(mat1, name = \"rnorm\", col = col_rnorm)\nht2 = Heatmap(mat2, name = \"runif\", col = col_runif)\nht3 = Heatmap(le, name = \"letters\", col = col_letters)\nht_list = ht1 + ht2 + ht3\ndraw(ht_list, ht_gap = unit(1, \"cm\"))\ndraw(ht_list, ht_gap = unit(c(3, 10), \"mm\"))"},{"path":"a-list-of-heatmaps.html","id":"automatic-adjustment-to-the-main-heatmap","chapter":"4 A List of Heatmaps","heading":"4.4 Automatic adjustment to the main heatmap","text":"always main heatmap heatmap list controls global\nrow ordering. heatmaps automatically adjusted according \nsettings main heatmap. non-main heatmaps, adjustments\n:row clustering performed take row ordering \nmain heatmap.Row titles removed.main heatmap split rows, heatmaps also split\nlevels main heatmap.height main heatmap taken height heatmaps.default, first heatmap taken main heatmap.main heatmap can specified main_heatmap argument. value can \nnumeric index name heatmap (course, need set \nheatmap name create Heatmap object). following example,\nalthough ht1 second heatmap, can set main heatmap.default, dendrogram row title plotted just beside main\nheatmap, just emphasize clustering splitting calculated \nmain heatmap heatmaps. However, position \ndendrogram row title main heatmap can controlled \nrow_dend_side row_sub_title_side draw() function.Similarly, row clustering main heatmap, \nheatmaps clustered neither.may observed, row names heatmaps removed \nplot. can show setting auto_adjust = FALSE.","code":"\nht1 = Heatmap(mat1, name = \"rnorm\", col = col_rnorm, row_km = 2)\nht2 = Heatmap(mat2, name = \"runif\", col = col_runif)\nht3 = Heatmap(le, name = \"letters\", col = col_letters)\nht2 + ht1 + ht3 # ht2 is the main heatmap and row_km in ht1 is ignored\nht_list = ht2 + ht1 + ht3\ndraw(ht_list, main_heatmap = \"rnorm\")\nht_list = ht2 + ht1 + ht3\ndraw(ht_list, main_heatmap = \"rnorm\", row_dend_side = \"right\", row_sub_title_side = \"left\")\nht1 = Heatmap(mat1, name = \"rnorm\", col = col_rnorm, cluster_rows = FALSE)\nht2 = Heatmap(mat2, name = \"runif\", col = col_runif)\nht3 = Heatmap(le, name = \"letters\", col = col_letters)\nht1 + ht2 + ht3\nht1 = Heatmap(mat1, name = \"rnorm\", col = col_rnorm)\nht2 = Heatmap(mat2, name = \"runif\", col = col_runif)\nht3 = Heatmap(le, name = \"letters\", col = col_letters)\nht_list = ht1 + ht2 + ht3\ndraw(ht_list, auto_adjust = FALSE)"},{"path":"a-list-of-heatmaps.html","id":"control-main-heatmap-in-draw-function","chapter":"4 A List of Heatmaps","heading":"4.5 Control main heatmap in draw() function","text":"Settings main heatmap can controlled main Heatmap()\nfunction. make convinient, settings affect heatmap rows can also \ndirectly set draw(). settings set, corresponding\nsettings main Heatmap() overwritten.draw() function, following main heatmap settings control row orders \nheatmaps.cluster_rowsclustering_distance_rowsclustering_method_rowsrow_dend_widthshow_row_dendrow_dend_reorderrow_dend_gprow_orderFollowing settings control row slices.row_gaprow_kmrow_km_repeatsrow_splitFollowing settings control heatmap height.heightheatmap_heightIn following example, row_km = 2, cluster_rows = FALSE ht1 \noverwritten draw().","code":"\nht1 = Heatmap(mat1, name = \"rnorm\", col = col_rnorm, row_km = 2, cluster_rows = FALSE)\nht2 = Heatmap(mat2, name = \"runif\", col = col_runif)\nht3 = Heatmap(le, name = \"letters\", col = col_letters)\nht_list = ht1 + ht2 + ht3\ndraw(ht_list, row_km = 1, row_split = le, cluster_rows = TRUE)"},{"path":"a-list-of-heatmaps.html","id":"annotations-as-components-are-adjusted","chapter":"4 A List of Heatmaps","heading":"4.6 Annotations as components are adjusted","text":"heatmaps heatmap list annotations, \ncases, heights heatmap annotations different different\nheatmaps. automatic adjustment heatmap annotations, \nadjustment also involve adjustment dendrograms.Normally, size simple annotations change adjustment. \nfollowing example, dendrogram second heatmap adjusted. Note \nstill can change size simple annotation setting anno_simple_size\nHeatmapAnnotation() globally set ht_opt$anno_simple_size.first two heatmaps annotations, since size simple\nannotations keep unchanged, size complex annotations adjusted\nmake total heights two heatmap annotations .Similarly, first heatmap contains simple annotatins, dendrogram\nadjusted.heatmaps contain simple annotations unequal number,\ndendrogram adjusted.also want automatically adjust size simple annotations, set\nsimple_anno_size_adjust = TRUE every HeatmapAnnotation() calls.second heatmap bottom annotation, column names second\nheatmap adjusted put directly heatmap body.","code":"\nha1 = HeatmapAnnotation(foo1 = 1:10, annotation_name_side = \"left\")\nht1 = Heatmap(mat1, name = \"rnorm\", col = col_rnorm, top_annotation = ha1)\nht2 = Heatmap(mat2, name = \"runif\", col = col_runif)\nht3 = Heatmap(le, name = \"letters\", col = col_letters)\nht1 + ht2 + ht3\nha1 = HeatmapAnnotation(foo1 = 1:10, bar1 = anno_points(1:10), \n    annotation_name_side = \"left\")\nha2 = HeatmapAnnotation(bar2 = anno_barplot(1:10))\nht1 = Heatmap(mat1, name = \"rnorm\", col = col_rnorm, top_annotation = ha1)\nht2 = Heatmap(mat2, name = \"runif\", col = col_runif, top_annotation = ha2)\nht3 = Heatmap(le, name = \"letters\", col = col_letters)\nht_list = ht1 + ht2 + ht3\ndraw(ht_list, ht_gap = unit(c(6, 2), \"mm\"))\nha1 = HeatmapAnnotation(foo1 = 1:10, annotation_name_side = \"left\")\nha2 = HeatmapAnnotation(bar2 = anno_barplot(1:10, height = unit(2, \"cm\")))\nht1 = Heatmap(mat1, name = \"rnorm\", col = col_rnorm, top_annotation = ha1)\nht2 = Heatmap(mat2, name = \"runif\", col = col_runif, top_annotation = ha2)\nht3 = Heatmap(le, name = \"letters\", col = col_letters)\nht_list = ht1 + ht2 + ht3\ndraw(ht_list, ht_gap = unit(c(6, 2), \"mm\"))\nha1 = HeatmapAnnotation(foo1 = 1:10, annotation_name_side = \"left\")\nha2 = HeatmapAnnotation(bar2 = cbind(b1 = 1:10, b2 = 11:20, b3 = 21:30))\nht1 = Heatmap(mat1, name = \"rnorm\", col = col_rnorm, top_annotation = ha1)\nht2 = Heatmap(mat2, name = \"runif\", col = col_runif, top_annotation = ha2)\nht3 = Heatmap(le, name = \"letters\", col = col_letters)\nht_list = ht1 + ht2 + ht3\ndraw(ht_list)\nha1 = HeatmapAnnotation(foo1 = 1:10, bar1 = anno_points(1:10), annotation_name_side = \"left\")\nht1 = Heatmap(mat1, name = \"rnorm\", col = col_rnorm, bottom_annotation = ha1)\nht2 = Heatmap(mat2, name = \"runif\", col = col_runif)\nht3 = Heatmap(le, name = \"letters\", col = col_letters)\nht_list = ht1 + ht2 + ht3\ndraw(ht_list)"},{"path":"a-list-of-heatmaps.html","id":"concatenate-with-annotations","chapter":"4 A List of Heatmaps","heading":"4.7 Concatenate with annotations","text":"Row annotations can concatenated horizontal heatmap list, \ncomponent heatmap. See following examples \nstraightforward.foo bar annotations can defined two separated\nrowAnnotation() calls.may wonder recover row names mat1. two ways.can set row annotation “right annotation” heatmap \nput heatmap last one.add row names adding text annotation:Basically heatmaps row annotations can concatenated arbitarily.mentioned previous chapters, row annotations can also heatmap\ncomponents left annotations right annotations. difference row\nannotations independent ones heatmap components discussed \nSection 4.9.","code":"\nha1 = rowAnnotation(foo = 1:12, bar = anno_barplot(1:12, width = unit(4, \"cm\")))\nht1 = Heatmap(mat1, name = \"rnorm\", col = col_rnorm, row_km = 2)\nht1 + ha1\nHeatmap(mat1, name = \"rnorm\", col = col_rnorm, row_km = 2) + \n    rowAnnotation(foo = 1:12) +\n    rowAnnotation(bar = anno_barplot(1:12, width = unit(4, \"cm\")))\nHeatmap(mat1, name = \"rnorm\", col = col_rnorm, row_km = 2, right_annotation = ha1)\n# or using the previous variable\n# attach_annotation(ht1, ha1, side = \"right\")\nht1 + ha1 + rowAnnotation(rn = anno_text(rownames(mat1), \n    location = unit(0, \"npc\"), just = \"left\"))\nrowAnnotation(foo = 1:12) +\n    Heatmap(mat1, name = \"rnorm\", col = col_rnorm, row_km = 2) + \n    rowAnnotation(bar = anno_barplot(1:12, width = unit(4, \"cm\"))) +\n    Heatmap(mat2, name = \"runif\", col = col_runif)"},{"path":"a-list-of-heatmaps.html","id":"concatenate-only-the-annotations","chapter":"4 A List of Heatmaps","heading":"4.8 Concatenate only the annotations","text":"concatenation can done without heatmap.one HeatmapAnnotation object, must concatenated NULL.annotation list actually also HeatmapList object.Thus, can use functionalities draw() function \nannotation list, row splitting.Section 11.2, show use list \nannotations visualize multiple summary statistics.","code":"\nrowAnnotation(foo = 1:12) +\n    rowAnnotation(bar = anno_barplot(1:12, width = unit(4, \"cm\")))\nrowAnnotation(bar = anno_barplot(1:12, width = unit(4, \"cm\"))) + NULL\nanno_list = rowAnnotation(foo = 1:12) +\n    rowAnnotation(bar = anno_barplot(1:12, width = unit(4, \"cm\")))\nclass(anno_list)## [1] \"HeatmapList\"\n## attr(,\"package\")\n## [1] \"ComplexHeatmap\"\ndraw(anno_list, row_split = rep(c(\"A\", \"B\"), each = 6))"},{"path":"a-list-of-heatmaps.html","id":"vertical-concatenation","chapter":"4 A List of Heatmaps","heading":"4.9 Vertical concatenation","text":"Heatmaps annotations (now column annotation) can concatenated\nvertically %v% operator. relatated settings adjustments\nsimilar horizontal concatenation. Please check following\nexamples.vertical heatmap list, now row annotations heatmap\ncomponents (right_annotation left_annotation) adjusted\njust like column annotations horizontal heatmap list.Since rowAnnotation() allows arbitary number annotations, way showed\nway expand heatmap list horizontally vertically\ntime.","code":"\nmat1t = t(mat1)\nmat2t = t(mat2)\nht1 = Heatmap(mat1t, name = \"rnorm\", col = col_rnorm, row_title = \"rnorm\")\nht2 = Heatmap(mat2t, name = \"runif\", col = col_runif, row_title = \"runif\")\nht3 = Heatmap(rbind(letters = le), name = \"letters\", col = col_letters)\nht_list = ht1 %v% ht2 %v% ht3\ndraw(ht_list)\ndraw(ht_list, column_km = 2)\nha = HeatmapAnnotation(foo = anno_barplot(1:12, height = unit(2, \"cm\")))\nht_list = ht1 %v% ha %v% ht2 %v% ht3\ndraw(ht_list, column_km = 2)\nht1 = Heatmap(mat1t, name = \"rnorm\", col = col_rnorm, row_km = 2)\nht2 = Heatmap(mat2t, name = \"runif\", col = col_runif, row_km = 2)\nht3 = Heatmap(rbind(letters = le), name = \"letters\", col = col_letters)\nha = HeatmapAnnotation(foo = anno_barplot(1:12, height = unit(2, \"cm\")))\nht_list = ht1 %v% ha %v% ht2 %v% ht3\ndraw(ht_list, column_km = 2)\nht1 = Heatmap(mat1t, name = \"rnorm\", col = col_rnorm, row_km = 2,\n    left_annotation = rowAnnotation(foo1 = 1:10, bar1 = anno_barplot(1:10)))\nha = HeatmapAnnotation(foo = anno_barplot(1:12, height = unit(2, \"cm\"), \n    axis_param = list(side = \"right\")))\nht2 = Heatmap(mat2t, name = \"runif\", col = col_runif, row_km = 2,\n    left_annotation = rowAnnotation(foo2 = 1:10))\nht3 = Heatmap(rbind(letters = le), name = \"letters\", col = col_letters)\nht_list = ht1 %v% ha %v% ht2 %v% ht3\ndraw(ht_list, column_km = 2)"},{"path":"a-list-of-heatmaps.html","id":"subset-heatmap-list","chapter":"4 A List of Heatmaps","heading":"4.10 Subset the heatmap list","text":"Similar subsetting Heatmap object (Section 2.13),\nheatmap list can also subsetted providing row index column\nindex. horizontal heatmap list, row index correspond rows \nheatmaps annotations, column index corresponds subset \nheatmaps annotations. vertical heatmap list, ’s way\naround.following use horizontal heatmap list example.foo1 bar components heatmap rnorm, can \nselected subset function, foo2 bar2 independent row\nannotations can selected take subset .","code":"\nht1 = Heatmap(mat1, name = \"rnorm\", col = col_rnorm, \n    left_annotation = rowAnnotation(foo1 = 1:12, bar1 = anno_points(1:12)))\nht2 = Heatmap(mat2, name = \"runif\", col = col_runif)\nha = rowAnnotation(foo2 = anno_barplot(1:12), bar2 = 12:1)\nht_list = ht1 + ht2 + ha\nnames(ht_list)## [1] \"rnorm\" \"runif\" \"foo2\"  \"bar2\"\nht_list[1:6, c(\"rnorm\", \"bar2\")]"},{"path":"a-list-of-heatmaps.html","id":"plot-the-heamtap-list","chapter":"4 A List of Heatmaps","heading":"4.11 Plot the heatmap list","text":"Similar described Section 2.11, directly entering \nHeatmapList object interactive R session calls show() method \ncalls draw() method internally. plot entering\nobject, use draw() explicitly:","code":"\n# code only for demonstration\ndraw(ht_list, ...)"},{"path":"a-list-of-heatmaps.html","id":"get-orders-and-dendrograms-from-a-list-of-heatmaps","chapter":"4 A List of Heatmaps","heading":"4.12 Get orders and dendrograms","text":"row_order(), column_order(), row_dend() column_dend() can used\nretrieve corresponding information heatmap list. usage \nstraightforward following examples. remember need apply \nfunctions object returned draw().rows columns split, returned values also list.can specify certain heatmap column order.logic extracting dendrograms also vertical\nheatmap list, don’t show examples .","code":"\nht1 = Heatmap(mat1, name = \"rnorm\", col = col_rnorm)\nht2 = Heatmap(mat2, name = \"runif\", col = col_runif)\nht_list = ht1 + ht2\nht_list = draw(ht_list)\nrow_order(ht_list)##  [1] 10  4  8  2  1 12 11  6  7  3  9  5\ncolumn_order(ht_list)## $rnorm\n##  [1]  5  2  7  6 10  1  9  8  4  3\n## \n## $runif\n##  [1]  4 10  2  5  7  6  1  3  8  9\nht1 = Heatmap(mat1, name = \"rnorm\", col = col_rnorm)\nht2 = Heatmap(mat2, name = \"runif\", col = col_runif, column_km = 2)\nht_list = ht1 + ht2\nht_list = draw(ht_list, row_km = 2)\nrow_order(ht_list)## $`1`\n## [1] 7 3 9 5\n## \n## $`2`\n## [1] 10  4  8  2  1 12 11  6\ncolumn_order(ht_list)## $rnorm\n## $rnorm[[1]]\n##  [1]  5  2  7  6 10  1  9  8  4  3\n## \n## \n## $runif\n## $runif$`2`\n## [1]  4 10  2  5\n## \n## $runif$`1`\n## [1] 7 6 1 3 8 9\ncolumn_order(ht_list, name = \"runif\")## $`2`\n## [1]  4 10  2  5\n## \n## $`1`\n## [1] 7 6 1 3 8 9"},{"path":"a-list-of-heatmaps.html","id":"change-parameters-globally","chapter":"4 A List of Heatmaps","heading":"4.13 Change parameters globally","text":"ht_opt() option function controls parameters globally. \ncan set parameters heatmaps/annotations simultaneously \nglobal function. Please note put heatmap code \nreset option values drawing heatmaps get rid affecting\nnext heatmap.following parameters control heatmaps:heatmap_row_names_gp: set row_names_gp Heatmap().heatmap_column_names_gp: set column_names_gp Heatmap().heatmap_row_title_gp: set row_title_gp Heatmap().heatmap_column_title_gp: set column_title_gp Heatmap().heatmap_border: set border Heatmap().Following parameters control legends:legend_title_gp: set title_gp heatmap legends annotation\nlegends.legend_title_position: set title_position heatmap legends \nannotation legends.legend_labels_gp: set labels_gp heatmap legends annotation\nlegends.legend_grid_width: set grid_width heatmap legends annotation\nlegends.legend_grid_height: set grid_height heatmap legends \nannotation legends.legend_border: set border heatmap legends annotation legends.Following parameters control heatmap annotations:annotation_border: set border HeatmapAnnotation().anno_simple_size: set size simple annotation.Following parameters control space heatmap components:DENDROGRAM_PADDING: space bewteen dendrograms heatmap body.DIMNAME_PADDING: space row/column names heatmap body.TITLE_PADDING: space row/column titles heatmap body.COLUMN_ANNO_PADDING: space column annotations heatmap body.ROW_ANNO_PADDING: space row annotations heatmap body.parameters:fast_hclust: whether use fastcluster::hclust() speed clustering?show_parent_dend_line: heatmap split, whether add dashed line\nmark parent dendrogram children dendrograms?can get set option values traditional way (like\nbase::options()) $ operator:Reset default values :Following example shows control graphic parameters globally.global parameters can also set draw() function \ntemporarily change global parameters, reset back \nplot made. Please check help page draw,HeatmapList-method.","code":"\nht_opt##  Option                       Value             \n##  ----------------------------:--------------------\n##  heatmap_row_names_gp         NULL              \n##  heatmap_column_names_gp      NULL              \n##  heatmap_row_title_gp         NULL              \n##  heatmap_column_title_gp      NULL              \n##  legend_title_gp              NULL              \n##  legend_title_position        NULL              \n##  legend_labels_gp             NULL              \n##  legend_grid_height           NULL              \n##  legend_grid_width            NULL              \n##  legend_border                NULL              \n##  legend_gap                   4mm, 4mm          \n##  heatmap_border               NULL              \n##  annotation_border            NULL              \n##  fast_hclust                  FALSE             \n##  show_parent_dend_line        TRUE              \n##  verbose                      FALSE             \n##  message                      TRUE              \n##  show_vp                      FALSE             \n##  simple_anno_size             5mm               \n##  DENDROGRAM_PADDING           0.5mm             \n##  DIMNAME_PADDING              1mm               \n##  TITLE_PADDING                NULL              \n##  COLUMN_ANNO_PADDING          1mm               \n##  ROW_ANNO_PADDING             1mm               \n##  HEATMAP_LEGEND_PADDING       2mm               \n##  ANNOTATION_LEGEND_PADDING    2mm               \n##  save_last                    FALSE             \n##  validate_names               TRUE              \n##  raster_temp_image_max_width  30000             \n##  raster_temp_image_max_height 30000             \n##  COLOR                        blue, #EEEEEE, red\nht_opt(\"heatmap_row_names_gp\")\nht_opt$heatmap_row_names_gp\n\n# to set option values\nht_opt(\"heatmap_row_names_gp\" = gpar(fontsize = 8))\nht_opt$heatmap_row_names_gp = gpar(fontsize = 8)\nht_opt(RESET = TRUE)\nht_opt(heatmap_column_names_gp = gpar(fontface = \"italic\"), \n    heatmap_column_title_gp = gpar(fontsize = 10),\n    legend_border = \"black\",\n    heatmap_border = TRUE,\n    annotation_border = TRUE\n)\nht1 = Heatmap(mat1, name = \"ht1\", column_title = \"Heatmap 1\",\n    top_annotation = HeatmapAnnotation(foo = 1:10))\nht2 = Heatmap(mat2, name = \"ht2\", column_title = \"Heatmap 2\",\n    top_annotation = HeatmapAnnotation(bar = 1:10))\nht1 + ht2\nht_opt(RESET = TRUE)"},{"path":"a-list-of-heatmaps.html","id":"adjust-blank-space-caused-by-annotations","chapter":"4 A List of Heatmaps","heading":"4.14 Adjust blank space caused by annotations","text":"Heatmap annotations may annotation names axes, spaces\nalso taken account arranging heatmap components final\nlayout. Sometimes, adjustment smart may see blank areas\nplot necessary.One scenario matrix row names, space right \nheatmap determined size annotation name, results blank\nspace heatmap legend. Also heatmap list level row\ntitle plotted left annotation axis, gives blank area \nrow dendrogram.adjust_annotation_extension controls whether take account space \nannotation names axes layout. Compare following two plots.Another way partially solve space problem move annotation name\nleft use heamtap-level row title.However, adjustment annotations sometimes also necessary, e.g. heatmap \nshort:Therefore, set TRUE default adjust_annotation_extension users can configure\nbased specific scenarios.","code":"\nm = matrix(rnorm(100), 10)\nht = Heatmap(m, name = \"mat\",\n    top_annotation = HeatmapAnnotation(foo = anno_points(1:10)),\n    show_row_dend = FALSE)\ndraw(ht, row_title = \"fooooooooooo\", adjust_annotation_extension = TRUE,  # default\n    column_title = \"adjust_annotation_extension = TRUE\")\ndraw(ht, row_title = \"fooooooooooo\", adjust_annotation_extension = FALSE,\n    column_title = \"adjust_annotation_extension = FALSE\")\nHeatmap(m, name = \"mat\",\n    top_annotation = HeatmapAnnotation(foo = anno_points(1:10),\n        annotation_name_side = \"left\"),\n    row_title = \"fooooooooooo\",\n    show_row_dend = FALSE)\nht = Heatmap(m, name = \"mat\",\n    top_annotation = HeatmapAnnotation(foo = anno_points(1:10)),\n    show_row_dend = FALSE)\ndraw(ht, row_title = \"fooooooooooo\", adjust_annotation_extension = TRUE,\n    column_title = \"adjust_annotation_extension = TRUE\")"},{"path":"a-list-of-heatmaps.html","id":"manually-increase-space-around-the-plot","chapter":"4 A List of Heatmaps","heading":"4.15 Manually increase space around the plot","text":"layout ComplexHeatmap perfect still possible text \ndrawn plotting region. case, can manually set padding argument draw() function\nincrease blank areas around final plot.value padding unit vector length four. four values correspond space \nbottom, left, top right sides.following example perfect example maximal width row names can controlled\nmax_row_name_width argument, can still use demonstrate use padding.","code":"\nm2 = m\nrownames(m2) = paste0(\"R\", 1:10)\nrownames(m2)[1] = \"a long long long long long row name\"\nht = Heatmap(m2, name = \"mat\", row_names_side = \"left\", show_row_dend = FALSE)\ndraw(ht, padding = unit(c(2, 20, 2, 2), \"mm\")) ## see right heatmap in following"},{"path":"legends.html","id":"legends","chapter":"5 Legends","heading":"5 Legends","text":"heatmaps simple annotations automatically generate legends \nput one right side heatmap. default legend \ncomplex annotations, can constructed added manually (Section\n5.5). legends internally constructed \nLegend() constructor. later sections, first introduce settings \ncontinuous legends discrete legends, discuss configure\nlegends associated heatmaps annotations, add new\nlegends plot.legends (matter single legend pack legends) belong \nLegends class. class one slot grob real\ngrid::grob object grid::gTree object records draw \ngraphics. wrapping Legends class methods designed \nclass make legends single objects can drawn like points \nspecifying positions viewport.legends heatmaps annotations can controlled \nheatmap_legend_param argument Heatmap(), annotation_legend_param\nargument HeatmapAnnotation(). parameters Legend()\nfunction can directly set two arguments parameter\nname. details setting heatmap legends annotation legends\nparameters introduced Section 5.4.","code":""},{"path":"legends.html","id":"continuous-legends","chapter":"5 Legends","heading":"5.1 Continuous legends","text":"Since heatmaps contain continuous values, first introduce \nsettings continuous legend.Continuous legend needs color mapping function generated \ncirclize::colorRamp2(). heatmap legends annotation legends \nautomatically generated, color mapping functions passed \ncol argument Heatmap() HeatmapAnnotation() function, \nconstruct self-defined legend, need provide color mapping\nfunction.break values provided color mapping function (e.g. c(0, 0.5, 1)\nfollowing example) exactly break values \nlegends). finally break values presented legend internally\nadjusted make numbers labels close 5 6.First show default style vertical continuous legend:lgd Legends class object. size legend can obtained \nComplexHeatmap:::width() ComplexHeatmap:::height() function.legend actually packed graphic object composed rectangles, lines\ntexts. can added plot draw() function. \nComplexHeatmap pacakge, don’t need use draw() directly legend\nobjects, might useful use legend objects places.want configure legends generated heatmaps \nannotations, don’t need construct Legends object .\nparameters introduced later can directly used customize \nlegends heatmap_legend_param argument Heatmap() \nannotation_legend_param argument HeatmapAnnotation() (introduced \nSection\n5.4). still nice see parameters change \nstyles legend following examples. Following simple example\nshowing configure legends heatmap heatmap annotation.following examples, show construct legend object, \nshow code draws legends. remember can use draw()\nfunction Legends object draw single legend plot.continuous legend, can manually adjust break values legend\nsetting . Note height automatically adjusted.labels corresponding break values set labels.height vertical continous legend set legend_height.\nlegend_height can set veritcal continous legend \nvalue height legend body (excluding legend title).vertical legend, grid_width controls widths legend\nbody. grid_width originally designed discrete legends \nlevel legend grid, use name \nparameter controls width legend.graphic parameters labels controlled labels_gp.border legend well ticks break values \ncontrolled border. value border can logical string \ncolor.title_position controls position titles. vertical legends, \nvalue one topleft, topcenter, lefttop-rot \nleftcenter-rot. Following two plots show effect lefttop-rot title\nleftcenter-rot title.Legend titles labels can set mathematical formulas.complicated texts can added using gridtext package (Section 10.3.5).Settings horizontal continuous legends almost vertical\nlegends, except now legend_width controls width legend, \ntitle position can one topcenter, topleft, lefttop \nleftcenter.default style horizontal legend:Manually set :Manually set labels:Set legend_width:Set graphic parameters labels:Set rotations labels.Title can set topleft, topcenter lefttop leftcenter.examples showed , intervals every two break values \nequal. Actually can also set break values uneuqal intervals.\nscenario, ticks legend still original places\ncorresponding texts shifted get rid overlapping. ,\nlines connecting ticks labels.labels need adjusted, still original places.similar horizontal legends:Set rotations labels 90 degree.position title set lefttop, area title \nalso taken account calculating adjusted positions labels.set decreasing order, legend reversed, .e. smallest value\ntop legend.continuous legends legend breaks equal distance, mean,\ne.g. distance first second breaks \ndistance second third breaks. However, still special\ncases users want set legend breaks unequal distances.following example, color mapping function col_fun_prop visualizes\nproportion values breaks c(0, 0.05, 0.1, 0.5, 1). legend breaks\nunequal distance might reflect different importance values c(0, 1).\nexample, maybe want see details interval c(0, 0.1).Following default style legend breaks selected 0 1\nequal distance.cann’t see details interval c(0, 0.1), right? also reminds us \nbreaks set colorRamp2() defines color mapping determine\nbreaks legend.manually select break values, color bar keeps . labels\nshifted lines connect original positions. case, distance\ncolor bar still proportional real difference break values, .e.,\ndistance 0.5 1 five times longer 0 0.1.version 2.7.1, Legend() function new argument break_dist \ncontrols distance two neighbouring break values legend.\nmight confusing, , mention “break distance,” \nalways means visual distance legend.value break_dist length either one means break\nvalues equal distance legend, length() - 1.following example, top two break intervals three times longer \nbottom two intervals.increase legend height legend_height argument, enough space\nlabels positions adjusted .Imaging following user case, want use one color scheme values \nc(0, 0.1) second color schema values c(0.1, 1), maybe \nreason want emphasize two intervals different. \ncolor mapping can defined :just added tiny shift (1e-6) 0.1 set lower bound \nsecond color scheme. legend looks like:Now can see colors changed smoothly 0 1 two disticnt\ncolor schemes.","code":"\nlibrary(circlize)\ncol_fun = colorRamp2(c(0, 0.5, 1), c(\"blue\", \"white\", \"red\"))\nlgd = Legend(col_fun = col_fun, title = \"foo\")\nComplexHeatmap:::width(lgd)## [1] 9.90361111111111mm\nComplexHeatmap:::height(lgd)## [1] 30.2744052165491mm\npushViewport(viewport(width = 0.9, height = 0.9))\ngrid.rect()  # border\ndraw(lgd, x = unit(1, \"cm\"), y = unit(1, \"cm\"), just = c(\"left\", \"bottom\"))\ndraw(lgd, x = unit(0.5, \"npc\"), y = unit(0.5, \"npc\"))\ndraw(lgd, x = unit(1, \"npc\"), y = unit(1, \"npc\"), just = c(\"right\", \"top\"))\npopViewport()\nHeatmap(matrix(rnorm(100), 10), \n    heatmap_legend_param = list(\n        title = \"rnorm\", at = c(-2, 0, 2), \n        labels = c(\"neg_two\", \"zero\", \"pos_two\")\n    ),\n    top_annotation = HeatmapAnnotation(\n        foo = 1:10,\n        annotation_legend_param = list(foo = list(title = \"foo_top_anno\"))\n    ))\nlgd = Legend(col_fun = col_fun, title = \"foo\", at = c(0, 0.25, 0.5, 0.75, 1))\nlgd = Legend(col_fun = col_fun, title = \"foo\", at = c(0, 0.5, 1), \n    labels = c(\"low\", \"median\", \"high\"))\nlgd = Legend(col_fun = col_fun, title = \"foo\", legend_height = unit(6, \"cm\"))\nlgd = Legend(col_fun = col_fun, title = \"foo\", grid_width = unit(1, \"cm\"))\nlgd = Legend(col_fun = col_fun, title = \"foo\", labels_gp = gpar(col = \"red\", font = 3))\nlgd = Legend(col_fun = col_fun, title = \"foo\", border = \"red\")\nlgd = Legend(col_fun = col_fun, title = \"foooooooo\", title_position = \"lefttop-rot\",\n    legend_height = unit(4, \"cm\"))\nlgd = Legend(col_fun = col_fun, title = \"foooooooo\", title_position = \"leftcenter-rot\",\n    legend_height = unit(4, \"cm\"))\nlgd = Legend(col_fun = col_fun, title = expression(hat(beta) == (X^t * X)^{-1} * X^t * y), \n    at = c(0, 0.25, 0.5, 0.75, 1), labels = expression(alpha, beta, gamma, delta, epsilon))\nlgd = Legend(col_fun = col_fun, \n    title = gt_render(\"<span style='color:orange'>**Legend title**<\/span>\"), \n    title_gp = gpar(box_fill = \"grey\"),\n    at = c(-3, 0, 3), \n    labels = gt_render(c(\"<span style='color:blue'>*negative*<\/span> three\", \"zero\", \n                         \"<span style='color:red'>*positive*<\/span> three\"))\n)\nlgd = Legend(col_fun = col_fun, title = \"foo\", direction = \"horizontal\")\nlgd = Legend(col_fun = col_fun, title = \"foo\", at = c(0, 0.25, 0.5, 0.75, 1), \n    direction = \"horizontal\")\nlgd = Legend(col_fun = col_fun, title = \"foo\", at = c(0, 0.5, 1), \n    labels = c(\"low\", \"median\", \"high\"), direction = \"horizontal\")\nlgd = Legend(col_fun = col_fun, title = \"foo\", legend_width = unit(6, \"cm\"), \n    direction = \"horizontal\")\nlgd = Legend(col_fun = col_fun, title = \"foo\", labels_gp = gpar(col = \"red\", font = 3), \n    direction = \"horizontal\")\nlgd = Legend(col_fun = col_fun, title = \"foo\", labels_rot = 45, \n    direction = \"horizontal\")\nlgd = Legend(col_fun = col_fun, title = \"foooooooo\", direction = \"horizontal\", \n    title_position = \"topcenter\")\nlgd = Legend(col_fun = col_fun, title = \"foooooooo\", direction = \"horizontal\", \n    title_position = \"lefttop\")\nlgd = Legend(col_fun = col_fun, title = \"foo\", at = c(0, 0.1, 0.15, 0.5, 0.9, 0.95, 1))\nlgd = Legend(col_fun = col_fun, title = \"foo\", at = c(0, 0.3, 1), \n    legend_height = unit(4, \"cm\"))\nlgd = Legend(col_fun = col_fun, title = \"foo\", at = c(0, 0.1, 0.15, 0.5, 0.9, 0.95, 1),\n    direction = \"horizontal\")\nlgd = Legend(col_fun = col_fun, title = \"foo\", at = c(0, 0.1, 0.15, 0.5, 0.9, 0.95, 1),\n    direction = \"horizontal\", title_position = \"lefttop\", labels_rot = 90)\nlgd = Legend(col_fun = col_fun, title = \"foo\", at = c(0, 0.1, 0.5, 0.75, 1),\n    labels = c(\"mininal\", \"q10\", \"median\", \"q75\", \"maximal\"),\n    direction = \"horizontal\", title_position = \"lefttop\")\nlgd = Legend(col_fun = col_fun, title = \"foo\", at = c(1, 0.8, 0.6, 0.4, 0.2, 0))\ncol_fun_prop = colorRamp2(c(0, 0.05, 0.1, 0.5, 1), \n    c(\"green\", \"white\", \"red\", \"black\", \"blue\"))\nlgd = Legend(col_fun = col_fun_prop, title = \"Prop\")\ncol_fun_prop = colorRamp2(c(0, 0.05, 0.1, 0.5, 1), \n    c(\"green\", \"white\", \"red\", \"black\", \"blue\"))\nlgd = Legend(col_fun = col_fun_prop, title = \"Prop\",\n    at = c(0, 0.05, 0.1, 0.5, 1))\nlgd = Legend(col_fun = col_fun_prop, title = \"Prop\", break_dist = 1)\nlgd = Legend(col_fun = col_fun_prop, title = \"Prop\", break_dist = c(1, 1, 3, 3))\nlgd = Legend(col_fun = col_fun_prop, title = \"Prop\", break_dist = c(1, 1, 3, 3),\n    legend_height = unit(4, \"cm\"))\ncol_fun2 = colorRamp2(c(0, 0.1, 0.1+1e-6, 1), c(\"white\", \"red\", \"yellow\", \"blue\"))\nlgd = Legend(col_fun = col_fun2, title = \"Prop\", at = c(0, 0.05, 0.1, 0.5, 1),\n    break_dist = c(1, 1, 3, 3), legend_height = unit(4, \"cm\"))"},{"path":"legends.html","id":"discrete-legends","chapter":"5 Legends","heading":"5.2 Discrete legends","text":"Discrete legends used discrete color mappings. continuous color\nmapping can also degenerated discrete color mapping providing\ncolors break values.can either specify labels, probably specify\nlabels. colors specified legend_gp.discrete legend continuous color mapping:position title:size grids controlled grid_width grid_height.graphic parameters labels controlled labels_gp.graphic parameters title controlled title_gp.Title labels complicated texts integrating gridtext package (Section 10.3.5):Borders grids controlled border.One important thing discrete legend can arrange grids \nmultiple rows /columns. ncol set number, grids \narranged ncol columns.Still title position calculated based multiplt-column legend.can choose list legend levels rows setting by_row = TRUE.gaps two columns controlled gap column_gap. two arguments\ntreated .gaps rows controlled row_gap.Instead ncol, can also specify layout nrow. Note \nuse ncol nrow time.One extreme case levels put one row title \nrotated 90 degree. height legend height \nrotated title.Following style lot people might like:Legend() also supports use simple graphics (e.g. points, lines, boxplots) \nlegends. type argument can specified points p can use number\npch single-letter pch.set type = \"lines\"/type = \"l\" use lines legend:set type = \"boxplot\"/type = \"box\" use boxes legends:pch integer number, numbers 26:28 correspond following symbols:examples showed , labels single lines. Multiple-line labels also\nsupported. shown following example, legend grids multiple-line labels \nautomatically enlongated.legend arranged multiple rows columns, sizes legend grids adjusted\nlabel number lines.last useful argument graphics can used self-define legend\ngraphics. value graphics list functions four\narguments: x y: center legend grid, w h: width\nheight legend grid. Length graphics \nlabels. graphics named list names correspond \nlabels, order list graphics automatically adjusted.","code":"\nlgd = Legend(at = 1:6, title = \"foo\", legend_gp = gpar(fill = 1:6))\nlgd = Legend(labels = month.name[1:6], title = \"foo\", legend_gp = gpar(fill = 1:6))\nat = seq(0, 1, by = 0.2)\nlgd = Legend(at = at, title = \"foo\", legend_gp = gpar(fill = col_fun(at)))\nlgd = Legend(labels = month.name[1:6], title = \"foo\", legend_gp = gpar(fill = 1:6),\n    title_position = \"lefttop\")\nlgd = Legend(labels = month.name[1:6], title = \"foo\", legend_gp = gpar(fill = 1:6),\n    title_position = \"leftcenter-rot\")\nlgd = Legend(at = 1:6, legend_gp = gpar(fill = 1:6), title = \"foo\", \n    grid_height = unit(1, \"cm\"), grid_width = unit(5, \"mm\"))\nlgd = Legend(labels = month.name[1:6], legend_gp = gpar(fill = 1:6), title = \"foo\", \n    labels_gp = gpar(col = \"red\", fontsize = 14))\nlgd = Legend(labels = month.name[1:6], legend_gp = gpar(fill = 1:6), title = \"foo\", \n    title_gp = gpar(col = \"red\", fontsize = 14))\nlgd = Legend(\n    title = gt_render(\"<span style='color:orange'>**Legend title**<\/span>\"), \n    title_gp = gpar(box_fill = \"grey\"),\n    at = c(-3, 0, 3), \n    labels = gt_render(c(\"**negative** three\", \"*zero*\", \"**positive** three\")),\n    legend_gp = gpar(fill = 1:3)\n)\nlgd = Legend(labels = month.name[1:6], legend_gp = gpar(fill = 1:6), title = \"foo\", \n    border = \"red\")\nlgd = Legend(labels = month.name[1:10], legend_gp = gpar(fill = 1:10), \n    title = \"foo\", ncol = 3)\nlgd = Legend(labels = month.name[1:10], legend_gp = gpar(fill = 1:10), title = \"foo\", \n    ncol = 3, title_position = \"topcenter\")\nlgd = Legend(labels = month.name[1:10], legend_gp = gpar(fill = 1:10), title = \"foo\", \n    ncol = 3, by_row = TRUE)\nlgd = Legend(labels = month.name[1:10], legend_gp = gpar(fill = 1:10), title = \"foo\", \n    ncol = 3, gap = unit(1, \"cm\"))\nlgd = Legend(labels = month.name[1:10], legend_gp = gpar(fill = 1:10), title = \"foo\", \n    ncol = 3, row_gap = unit(5, \"mm\"))\nlgd = Legend(labels = month.name[1:10], legend_gp = gpar(fill = 1:10), \n    title = \"foo\", nrow = 3)\nlgd = Legend(labels = month.name[1:6], legend_gp = gpar(fill = 1:6), title = \"foooooo\", \n    nrow = 1, title_position = \"lefttop-rot\")\nlgd = Legend(labels = month.name[1:6], legend_gp = gpar(fill = 1:6), title = \"foooooo\", \n    nrow = 1, title_position = \"leftcenter\")\nlgd = Legend(labels = month.name[1:6], title = \"foo\", type = \"points\", \n    pch = 1:6, legend_gp = gpar(col = 1:6), background = \"#FF8080\")\nlgd = Legend(labels = month.name[1:6], title = \"foo\", type = \"points\", \n    pch = letters[1:6], legend_gp = gpar(col = 1:6), background = \"white\")\nlgd = Legend(labels = month.name[1:6], title = \"foo\", type = \"lines\", \n    legend_gp = gpar(col = 1:6, lty = 1:6), grid_width = unit(1, \"cm\"))\nlgd = Legend(labels = month.name[1:6], title = \"foo\", type = \"boxplot\",\n    legend_gp = gpar(fill = 1:6))\nlgd = Legend(labels = paste0(\"pch = \", 26:28), type = \"points\", pch = 26:28)\nlgd = Legend(labels = c(\"aaaaa\\naaaaa\", \"bbbbb\\nbbbbb\", \"c\", \"d\"),\n    legend_gp = gpar(fill = 1:4))\nlgd = Legend(labels = c(\"aaaaa\\naaaaa\", \"c\", \"d\", \"bbbbb\\nbbbbb\"),\n    legend_gp = gpar(fill = 1:4), nrow = 2)\nlgd = Legend(labels = letters[1:4],\n    graphics = list(\n        function(x, y, w, h) grid.rect(x, y, w*0.33, h, gp = gpar(fill = \"red\")),\n        function(x, y, w, h) grid.rect(x, y, w, h*0.33, gp = gpar(fill = \"blue\")),\n        function(x, y, w, h) grid.text(\"A\", x, y, gp = gpar(col = \"darkgreen\")),\n        function(x, y, w, h) grid.points(x, y, gp = gpar(col = \"orange\"), pch = 16)\n    ))"},{"path":"legends.html","id":"a-list-of-legends","chapter":"5 Legends","heading":"5.3 A list of legends","text":"list legends can constructed packed Legends object \nindividual legends arranged within certain layout. legend list can\nsent packLegend() separatedly list. legend can arranged\neither vertically horizontally. ComplexHeatmap uses packLegend()\ninternally arrange multiple legends. Normally don’t need manually\ncontrol arrangement multiple legends, following section \nuseful want manually construct list legends apply \nplots.Simillar single legend, can draw packed legends draw()\nfunction. Also can get size pd ComplexHeatmap:::width() \nComplexHeatmap:::height().Horizontally arranging legends simply setting direction = \"horizontal\".One feature packLegend() , e.g. packing vertically \nsum packed legends exceeds height specified max_height, \nrearragned mutliple column layout. following example, \nmaximum height 10cm.legends put multiple columns, column_gap controls \nspace two columns.Similar horizontal packing:packed legends pd also Legends object, means can use\ndraw() draw specifying positions.mentioned , packLegend() used internally manage list\nheatmap annotation legends.","code":"\nlgd1 = Legend(at = 1:6, legend_gp = gpar(fill = 1:6), title = \"legend1\")\nlgd2 = Legend(col_fun = col_fun, title = \"legend2\", at = c(0, 0.25, 0.5, 0.75, 1))\nlgd3 = Legend(labels = month.name[1:3], legend_gp = gpar(fill = 7:9), title = \"legend3\")\n\npd = packLegend(lgd1, lgd2, lgd3)\n# which is same as \npd = packLegend(list = list(lgd1, lgd2, lgd3))\nComplexHeatmap:::width(pd)## [1] 19.1675555555556mm\nComplexHeatmap:::height(pd)## [1] 78.6988333333334mm\npd = packLegend(lgd1, lgd2, lgd3, direction = \"horizontal\")\npd = packLegend(lgd1, lgd3, lgd2, lgd3, lgd2, lgd1, max_height = unit(10, \"cm\"), \n    column_gap = unit(1, \"cm\"))\nlgd1 = Legend(at = 1:6, legend_gp = gpar(fill = 1:6), title = \"legend1\",\n    nr = 1)\nlgd2 = Legend(col_fun = col_fun, title = \"legend2\", at = c(0, 0.25, 0.5, 0.75, 1),\n    direction = \"horizontal\")\n\npd = packLegend(lgd1, lgd2, lgd3, lgd1, lgd2, lgd3, max_width = unit(10, \"cm\"), \n    direction = \"horizontal\", column_gap = unit(5, \"mm\"), row_gap = unit(1, \"cm\"))\npd = packLegend(lgd1, lgd2, lgd3, direction = \"horizontal\")\npushViewport(viewport(width = 0.8, height = 0.8))\ngrid.rect()\ndraw(pd, x = unit(1, \"cm\"), y = unit(1, \"cm\"), just = c(\"left\", \"bottom\"))\ndraw(pd, x = unit(1, \"npc\"), y = unit(1, \"npc\"), just = c(\"right\", \"top\"))\npopViewport()"},{"path":"legends.html","id":"heatmap-and-annotation-legends","chapter":"5 Legends","heading":"5.4 Heatmap and annotation legends","text":"Settings heatmap legend controlled heatmap_legend_param argument\nHeatmap(). value heatmap_legend_param list parameters\nsupported Legend().annotation_legend_param controls legends annotations. Since \nHeatmapAnnotation may contain multiple annotations, value \nannotation_legend_param list configurations annotation.heatmaps concatenated horizontally, heatmap row annotation\nlegends grouped column annotation legends ae grouped. reason\nassume horizontal direction passes main message plot, \nvertical direction provides secondary information.Similarlly, heatmaps concatenated vertically, heatmaps/column\nannotations grouped legends row annotations grouped.show_legend HeatmapAnnotation() show_heatmap_legend \nHeatmap() controls whether show legends. Note show_legend can \nsingle logical value, logical vector, named vector controls\nsubset annotations.merge_legend draw() function controlls whether merge legends\nsingle group. Normally, many annotations heatmaps,\nnumber legends always large. case, legends \nautomatically arranged multiple columns (multiple rows put\nbottom heatmaps) get rid figure page. \nheatmap heatmap annotations, order putting legends : legends\nleft annotations, legends top annotations, legend \nheatmap, legends bottom annotations legends right\nannotations.want heatmap legends “pure heatmap legends,” can set\nlegend_grouping = \"original\" enforce annotation legends put together,\nmatter whether row annotation legends column annotation legends.continuous color mapping can \ndiscrete legend setting color_bar = \"discrete\", work heatmap\nlegends annotation legends.value character vector, matter annotation one-row/one-column\nmatrix heatmap, default order legend labels sort(unique(value)) value\nfactor, order legend labels levels(value). Always remember order can \nfine-tuned setting labels parameters heatmap_legend_param/annotation_legend_param\nHeatmap()/HeamtapAnnotation() functions respectively.","code":"\nm = matrix(rnorm(100), 10)\nHeatmap(m, name = \"mat\", heatmap_legend_param = list(\n    at = c(-2, 0, 2),\n    labels = c(\"low\", \"zero\", \"high\"),\n    title = \"Some values\",\n    legend_height = unit(4, \"cm\"),\n    title_position = \"lefttop-rot\"\n))\nha = HeatmapAnnotation(foo = runif(10), bar = sample(c(\"f\", \"m\"), 10, replace = TRUE),\n    annotation_legend_param = list(\n        foo = list(\n                title = \"Fooooooh\",\n                at = c(0, 0.5, 1),\n                labels = c(\"zero\", \"median\", \"one\")\n            ),\n        bar = list(\n                title = \"Baaaaaaar\",\n                at = c(\"f\", \"m\"),\n                labels = c(\"Female\", \"Male\")\n            )\n))\nHeatmap(m, name = \"mat\", top_annotation = ha)\nha1 = HeatmapAnnotation(foo1 = runif(10), bar1 = sample(c(\"f\", \"m\"), 10, replace = TRUE))\nha2 = HeatmapAnnotation(foo2 = runif(10), bar2 = sample(c(\"f\", \"m\"), 10, replace = TRUE))\nHeatmap(m, name = \"mat1\", top_annotation = ha1) +\nrowAnnotation(sth = runif(10)) +\nHeatmap(m, name = \"mat2\", top_annotation = ha2)\nha1 = HeatmapAnnotation(foo1 = runif(10), bar1 = sample(c(\"f\", \"m\"), 10, replace = TRUE), \n    annotation_name_side = \"left\")\nha2 = HeatmapAnnotation(foo2 = runif(10), bar2 = sample(c(\"f\", \"m\"), 10, replace = TRUE))\nHeatmap(m, name = \"mat1\", top_annotation = ha1) %v%\nHeatmap(m, name = \"mat2\", top_annotation = ha2, \n    right_annotation = rowAnnotation(sth = 1:10))\nha = HeatmapAnnotation(foo = runif(10), \n    bar = sample(c(\"f\", \"m\"), 10, replace = TRUE),\n    show_legend = c(TRUE, FALSE), # it can also be show_legend = c(bar = FALSE)\n    annotation_name_side = \"left\")\nHeatmap(m, name = \"mat1\", top_annotation = ha) +\nHeatmap(m, name = \"mat2\", show_heatmap_legend = FALSE)\nha1 = HeatmapAnnotation(foo1 = runif(10), \n    bar1 = sample(c(\"f\", \"m\"), 10, replace = TRUE))\nha2 = rowAnnotation(foo2 = runif(10), \n    bar2 = sample(letters[1:3], 10, replace = TRUE))\nha3 = rowAnnotation(foo3 = runif(10), \n    bar3 = sample(month.name[1:3], 10, replace = TRUE))\nht_list = Heatmap(m, name = \"mat1\", top_annotation = ha1) + \n    Heatmap(m, name = \"mat2\", left_annotation = ha2) + \n    ha3\ndraw(ht_list, merge_legend = TRUE)\ndraw(ht_list, legend_grouping = \"original\")\nHeatmap(m, name = \"mat\", heatmap_legend_param = list(color_bar = \"discrete\"),\n    top_annotation = HeatmapAnnotation(foo = 1:10,\n        annotation_legend_param = list(\n            foo = list(color_bar = \"discrete\"))))\nchr = sample(letters[1:3], 10, replace = TRUE)\nchr##  [1] \"a\" \"c\" \"b\" \"c\" \"b\" \"a\" \"a\" \"a\" \"b\" \"c\"\nfa1 = factor(chr)\nfa2 = factor(chr, levels = c(\"c\", \"a\", \"b\"))\nHeatmap(m, top_annotation = HeatmapAnnotation(chr = chr, fa1 = fa1, fa2 = fa2, fa3 = fa2,\n    annotation_legend_param = list(fa3 = list(at = c(\"b\", \"c\", \"a\")))))"},{"path":"legends.html","id":"add-customized-legends","chapter":"5 Legends","heading":"5.5 Add customized legends","text":"self-defined legends (constructed Legend()) can added \nheatmap legend list heatmap_legend_list argument draw() \nlegends annotations can added annotation legend list \nannotation_legend_list argument.nice example adding self-defined legends Section\n11.2, show simple example.mentioned , heatmap simple annotations can generate\nlegends plot. ComplexHeatmap provides many annotation functions,\nnone supports generating legends. following code, add \npoint annotation, line annotation summary annotation heatmaps.Next construct legends points, lines boxplots.","code":"\nha1 = HeatmapAnnotation(pt = anno_points(1:10, gp = gpar(col = rep(2:3, each = 5)), \n    height = unit(2, \"cm\")), show_annotation_name = FALSE)\nha2 = HeatmapAnnotation(ln = anno_lines(cbind(1:10, 10:1), gp = gpar(col = 4:5, lty = 1:2),\n    height = unit(2, \"cm\")), show_annotation_name = FALSE)\nm = matrix(rnorm(100), 10)\nht_list = Heatmap(m, name = \"mat1\", top_annotation = ha1) + \n          Heatmap(m, name = \"mat2\", top_annotation = ha2) +\n          Heatmap(m[, 1], name = \"mat3\", \n            top_annotation = HeatmapAnnotation(\n                summary = anno_summary(gp = gpar(fill = 2:3))\n          ), width = unit(1, \"cm\"))\ndraw(ht_list, ht_gap = unit(7, \"mm\"), row_km = 2)\nlgd_list = list(\n    Legend(labels = c(\"red\", \"green\"), title = \"pt\", type = \"points\", pch = 16, \n        legend_gp = gpar(col = 2:3)),\n    Legend(labels = c(\"darkblue\", \"lightblue\"), title = \"ln\", type = \"lines\", \n        legend_gp = gpar(col = 4:5, lty = 1:2)),\n    Legend(labels = c(\"group1\", \"group2\"), title = \"km\", type = \"boxplot\",\n        legend_gp = gpar(fill = 2:3))\n)\ndraw(ht_list, ht_gap = unit(7, \"mm\"), row_km = 2, annotation_legend_list = lgd_list)"},{"path":"legends.html","id":"the-side-of-legends","chapter":"5 Legends","heading":"5.6 The side of legends","text":"default, heatmap legends annotation legends put right \nplot. side relative heatmaps two types legends can \ncontrolled heatmap_legend_side annotation_legend_side arguments \ndraw() function. values can set two arguments \nleft, right, bottom top.legends put bottom top, legends arranged\nhorizontally. might also want set every single legend horizontal\nlegend, needs set via heatmap_legend_param \nannotation_legend_param arguments Heatmap() HeatmapAnnotation()\nfunctions:","code":"\nm = matrix(rnorm(100), 10)\nha1 = HeatmapAnnotation(foo1 = runif(10), bar1 = sample(c(\"f\", \"m\"), 10, replace = TRUE))\nha2 = HeatmapAnnotation(foo2 = runif(10), bar2 = sample(c(\"f\", \"m\"), 10, replace = TRUE))\nht_list = Heatmap(m, name = \"mat1\", top_annotation = ha1) +\n    rowAnnotation(sth = runif(10)) +\n    Heatmap(m, name = \"mat2\", top_annotation = ha2)\ndraw(ht_list, heatmap_legend_side = \"left\", annotation_legend_side = \"bottom\")\nha1 = HeatmapAnnotation(foo1 = runif(10), bar1 = sample(c(\"f\", \"m\"), 10, replace = TRUE),\n    annotation_legend_param = list(\n        foo1 = list(direction = \"horizontal\"),\n        bar1 = list(nrow = 1)))\nha2 = HeatmapAnnotation(foo2 = runif(10), bar2 = sample(c(\"f\", \"m\"), 10, replace = TRUE),\n    annotation_legend_param = list(\n        foo2 = list(direction = \"horizontal\"),\n        bar2 = list(nrow = 1)))\nht_list = Heatmap(m, name = \"mat1\", top_annotation = ha1, \n        heatmap_legend_param = list(direction = \"horizontal\")) +\n    rowAnnotation(sth = runif(10), \n        annotation_legend_param = list(sth = list(direction = \"horizontal\"))) +\n    Heatmap(m, name = \"mat2\", top_annotation = ha2,\n        heatmap_legend_param = list(direction = \"horizontal\"))\ndraw(ht_list, merge_legend = TRUE, heatmap_legend_side = \"bottom\", \n    annotation_legend_side = \"bottom\")"},{"path":"heatmap-decoration.html","id":"heatmap-decoration","chapter":"6 Heatmap Decoration","heading":"6 Heatmap Decoration","text":"plotting region heatmap component still kept \nheatmaps made, possible go back original places add\ngraphics . First let’s generate figure almost contains \ntypes heatmap components. list_components() lists names \nheatmap/annotation components (name viewport).Basically red regions plot can revisited decorate_*()\nfunctions.","code":"\nset.seed(123)\nmat = matrix(rnorm(80, 2), 8, 10)\nmat = rbind(mat, matrix(rnorm(40, -2), 4, 10))\nrownames(mat) = paste0(\"R\", 1:12)\ncolnames(mat) = paste0(\"C\", 1:10)\n\nha_column1 = HeatmapAnnotation(points = anno_points(rnorm(10)), \n    annotation_name_side = \"left\")\nht1 = Heatmap(mat, name = \"ht1\", km = 2, column_title = \"Heatmap 1\", \n    top_annotation = ha_column1, row_names_side = \"left\")\n\nha_column2 = HeatmapAnnotation(type = c(rep(\"a\", 5), rep(\"b\", 5)),\n    col = list(type = c(\"a\" = \"red\", \"b\" = \"blue\")))\nht2 = Heatmap(mat, name = \"ht2\", row_title = \"Heatmap 2\", column_title = \"Heatmap 2\",\n    bottom_annotation = ha_column2, column_km = 2)\n\nht_list = ht1 + ht2 + \n    rowAnnotation(bar = anno_barplot(rowMeans(mat), width = unit(2, \"cm\")))\ndraw(ht_list, row_title = \"Heatmap list\", column_title = \"Heatmap list\")\nlist_components()##  [1] \"ROOT\"                           \"global\"                        \n##  [3] \"global_layout\"                  \"global-heatmaplist\"            \n##  [5] \"main_heatmap_list\"              \"heatmap_ht1\"                   \n##  [7] \"ht1_heatmap_body_wrap\"          \"ht1_heatmap_body_1_1\"          \n##  [9] \"ht1_heatmap_body_2_1\"           \"ht1_column_title_1\"            \n## [11] \"ht1_row_title_1\"                \"ht1_row_title_2\"               \n## [13] \"ht1_dend_row_1\"                 \"ht1_dend_row_2\"                \n## [15] \"ht1_dend_column_1\"              \"ht1_row_names_1\"               \n## [17] \"ht1_row_names_2\"                \"ht1_column_names_1\"            \n## [19] \"annotation_points_1\"            \"heatmap_ht2\"                   \n## [21] \"ht2_heatmap_body_wrap\"          \"ht2_heatmap_body_1_1\"          \n## [23] \"ht2_heatmap_body_1_2\"           \"ht2_heatmap_body_2_1\"          \n## [25] \"ht2_heatmap_body_2_2\"           \"ht2_column_title_1\"            \n## [27] \"ht2_dend_column_1\"              \"ht2_dend_column_2\"             \n## [29] \"ht2_column_names_1\"             \"ht2_column_names_2\"            \n## [31] \"annotation_type_1\"              \"annotation_type_2\"             \n## [33] \"heatmap_heatmap_annotation_2\"   \"annotation_bar_1\"              \n## [35] \"annotation_bar_2\"               \"global-column_title_top\"       \n## [37] \"global_column_title\"            \"global-row_title_left\"         \n## [39] \"global_row_title\"               \"global-heatmap_legend_right\"   \n## [41] \"heatmap_legend\"                 \"global-annotation_legend_right\"\n## [43] \"annotation_legend\""},{"path":"heatmap-decoration.html","id":"decoration-functions","chapter":"6 Heatmap Decoration","heading":"6.1 Decoration functions","text":"Since can get viewport name list_components(), actually can\ndirectly go viewport seekViewport(). get rid complicated\nviewport names, decorate_*() functions provide friendly way \n.following decoration functions ComplexHeatmap package:decorate_heatmap_body()decorate_annotation()decorate_dend()decorate_title()decorate_dimnames()decorate_row_names(), identical decorate_dimnames(..., = \"row\").decorate_column_names(), identical decorate_dimnames(..., = \"column\").decorate_row_dend(), identical decorate_dend(..., = \"row\").decorate_column_dend(), identical decorate_dend(..., = \"column\").decorate_row_title(), identical decorate_title(..., = \"row\").decorate_column_title(), identical decorate_title(..., = \"column\").Among , decorate_heatmap_body() decorate_annotation() often used.functions, need heatmap annotation name, index \nrow/column slices heatmap split code block defines \nadd graphics. Check following example.annotations created anno_points(), anno_barplot() \nanno_boxplot(), “native” unit can used decoration code.","code":"\nht_list = draw(ht_list, row_title = \"Heatmap list\", column_title = \"Heatmap list\", \n    heatmap_legend_side = \"right\", annotation_legend_side = \"left\")\n\ndecorate_heatmap_body(\"ht1\", {\n    grid.text(\"outlier\", 1.5/10, 2.5/4, default.units = \"npc\")\n    grid.lines(c(0.5, 0.5), c(0, 1), gp = gpar(lty = 2, lwd = 2))\n}, slice = 2)\n\ndecorate_column_dend(\"ht1\", {\n    tree = column_dend(ht_list)$ht1[[1]]\n    ind = cutree(as.hclust(tree), k = 2)[order.dendrogram(tree)]\n\n    first_index = function(l) which(l)[1]\n    last_index = function(l) { x = which(l); x[length(x)] }\n    x1 = c(first_index(ind == 1), first_index(ind == 2)) - 1\n    x2 = c(last_index(ind == 1), last_index(ind == 2))\n    grid.rect(x = x1/length(ind), width = (x2 - x1)/length(ind), just = \"left\",\n        default.units = \"npc\", gp = gpar(fill = c(\"#FF000040\", \"#00FF0040\"), col = NA))\n})\n\ndecorate_row_names(\"ht1\", {\n    grid.rect(gp = gpar(fill = \"#FF000040\"))\n}, slice = 2)\n\ndecorate_row_title(\"ht1\", {\n    grid.rect(gp = gpar(fill = \"#00FF0040\"))\n}, slice = 1)\n\ndecorate_annotation(\"points\", {\n    grid.lines(c(0, 1), unit(c(0, 0), \"native\"), gp = gpar(col = \"red\"))\n})"},{"path":"heatmap-decoration.html","id":"decoration-examples","chapter":"6 Heatmap Decoration","heading":"6.2 Examples","text":"","code":""},{"path":"heatmap-decoration.html","id":"barplot-for-single-column-heatmap","chapter":"6 Heatmap Decoration","heading":"6.2.1 Barplot for single-column heatmap","text":"Section 3.20, introduced adding barplots \nannotations single-column heatmap. case heatmap contains\ndiscrete values barplots show frequency level. \nfollowing example, show another scenario using barplot annotation \ncontinuous heatmap.Imagining analyzing set genomic regions (e.g. differentially\nmethylated regions, DMRs) single-column heatmap shows \noverlap e.g. genes (measured fraction DMR covered genes,\nvalue 0 1, e.g. value 0.5 means 50% DMR overlaps \ngenes). denote width DMRs \\(w\\) fraction \\(p\\), \ntop fraction heatmap, want add barplots show, average, \nmuch DMRs covered genes. case, need calcualte \nmean fraction weighted width DMRs (\\(\\sum{(w \\cdot p)}/\\sum{w}\\)).following code, randomly generated fraction vector split \ntwo groups. first use anno_empty() allocate empty plotting region \ntop heatmap later use decorate_annotation() add \nbarplots .","code":"\nlibrary(circlize)\n# DMRs\nbed = generateRandomBed(nr = 1000)\n# fractions\nfrac = c(runif(400, min = 0.4, max = 1), runif(nrow(bed) - 400, min = 0.2, max = 0.6))\ncol_fun = colorRamp2(c(0, 1), c(\"white\", \"orange\"))\n# two groups\nsplit = c(rep(\"group1\", 400), rep(\"group2\", nrow(bed) - 400))\n# draw the fraction heatmap with an empty annotation\nht = Heatmap(frac, name = \"fraction\", col = col_fun, width = unit(2, \"cm\"),\n    top_annotation = HeatmapAnnotation(barplot = anno_empty(height = unit(4, \"cm\"))))\nht = draw(ht, row_split = split)\n# get the row indices in the two row-groups\nro = row_order(ht)\nw = bed[, 3] - bed[, 2]\n# the mean weighted fraction in the two groups\np = sapply(ro, function(index) {\n    sum(w[index]*frac[index])/sum(w[index])\n})\n# add two bars of `p`\ndecorate_annotation(\"barplot\", {\n    pushViewport(viewport(xscale = c(0.5, 2.5), yscale = c(0, max(p)*1.1)))\n    grid.rect(x = 1:2, y = 0, width = 0.8, height = p, just = \"bottom\",\n        gp = gpar(fill = \"orange\"), default.units = \"native\")\n    grid.yaxis()\n    grid.text(\"mean fraction\", x = unit(-1.5, \"cm\"),rot = 90, just = \"bottom\")\n    popViewport()\n})"},{"path":"heatmap-decoration.html","id":"add-titles-for-row-annotations","chapter":"6 Heatmap Decoration","heading":"6.2.2 Add titles for row annotations","text":"Row annotations can concatenated heatmap list. Sometimes need \ntitle row annotation. easy implement decorations.basically way use Section 11.2.","code":"\nht_list = Heatmap(matrix(rnorm(100), 10), name = \"mat\", show_column_dend = FALSE) +\n    rowAnnotation(foo = anno_barplot(1:10, width = unit(4, \"cm\"))) +\n    rowAnnotation(bar = anno_boxplot(matrix(rnorm(100), 10)), width = unit(4, \"cm\"))\ndraw(ht_list, padding = unit(c(2, 2, 10, 2), \"mm\")) # add space for titles\ndecorate_annotation(\"foo\", { \n    grid.text(\"title for barplot\", y = unit(1, \"npc\") + unit(2, \"mm\"), just = \"bottom\") \n})\ndecorate_annotation(\"bar\", { \n    grid.text(\"title for boxplot\", y = unit(1, \"npc\") + unit(2, \"mm\"), just = \"bottom\") \n})\ndecorate_heatmap_body(\"mat\", {\n    grid.text(\"title for the heatmap\", y = unit(1, \"npc\") + unit(2, \"mm\"), just = \"bottom\")\n})"},{"path":"heatmap-decoration.html","id":"other-possible-use-of-decorations","chapter":"6 Heatmap Decoration","heading":"6.2.3 Other possible use of decorations","text":"examples decoration helpful:quantile lines added densityHeatmap(), Section 11.1.Heatmap annotations grouped lines, Section 14.5.Texts added heatmaps, Section 14.2.","code":""},{"path":"oncoprint.html","id":"oncoprint","chapter":"7 OncoPrint","heading":"7 OncoPrint","text":"OncoPrint \nway visualize multiple genomic alteration events heatmap. \nComplexHeatmap package provides oncoPrint() function makes\noncoPrints. Besides default style provided cBioPortal, additional\nbarplots sides heatmap show numbers different\nalterations sample gene. Also functionality \nComplexHeatmap, can concatenate oncoPrints additional heatmaps\nannotations correspond types information.","code":""},{"path":"oncoprint.html","id":"oncoprint-general-settings","chapter":"7 OncoPrint","heading":"7.1 General settings","text":"","code":""},{"path":"oncoprint.html","id":"input-data-format","chapter":"7 OncoPrint","heading":"7.1.1 Input data format","text":"two different formats input data. first represented \nmatrix value can include multiple alterations form \ncomplicated string. follow example, ‘g1’ ‘s1’ two types \nalterations ‘snv’ ‘indel.’case, need define function extract different alteration\ntypes long strings. definition function always\nsimple, accepts complicated string returns vector alteration\ntypes.mat, can define function :, alterations encoded snv|indel, can define function\nfunction(x) strsplit(x, \"|\")[[1]]. self-defined function assigned\nget_type argument oncoPrint().Since cases, separators single characters, \nseparators ;:,|, oncoPrint() automatically spit alteration\nstrings don’t need explicitely specify get_type \noncoPrint() function.one gene one sample, since different alteration types may drawn \none grid heatmap, need define add graphics \nproviding list self-defined functions alter_fun argument. \ngraphics transparency, order adding graphics matters. \nfollowing example, snv first drawn indel. can see\nrectangles indels actually smaller (0.4*h) snvs\n(0.9*h) can visualize snvs indels \ngrid. Names function list correspond alteration types\n(, snv indel).self-defined graphic function (functions alter_fun, \nfour arguments positions grids oncoPrint\n(x y), widths heights grids (w h, \nmeasured npc unit). Proper values four arguments sent \nfunctions automatically oncoPrint().Colors different alterations defined col. named\nvector names correspond alteration types. used generate\nbarplots.can see order barplots also correspond order defined \nalter_fun. grahpics legend based functions defined alter_fun.confused generated matrix, second way. \nsecond type input data list matrix matrix contains\nbinary value representing whether alteration absent present. \nlist names correspond alteration types.oncoPrint() expects matrices mat_list row names \ncolumn names.Pass mat_list oncoPrint():following parts chapter, still use single matrix form mat\nspecify input data.","code":"\nmat = read.table(textConnection(\n\"s1,s2,s3\ng1,snv;indel,snv,indel\ng2,,snv;indel,snv\ng3,snv,,indel;snv\"), row.names = 1, header = TRUE, sep = \",\", stringsAsFactors = FALSE)\nmat = as.matrix(mat)\nmat##    s1          s2          s3         \n## g1 \"snv;indel\" \"snv\"       \"indel\"    \n## g2 \"\"          \"snv;indel\" \"snv\"      \n## g3 \"snv\"       \"\"          \"indel;snv\"\nget_type_fun = function(x) strsplit(x, \";\")[[1]]\nget_type_fun(mat[1, 1])## [1] \"snv\"   \"indel\"\nget_type_fun(mat[1, 2])## [1] \"snv\"\ncol = c(snv = \"red\", indel = \"blue\")\noncoPrint(mat,\n    alter_fun = list(\n        snv = function(x, y, w, h) grid.rect(x, y, w*0.9, h*0.9, \n            gp = gpar(fill = col[\"snv\"], col = NA)),\n        indel = function(x, y, w, h) grid.rect(x, y, w*0.9, h*0.4, \n            gp = gpar(fill = col[\"indel\"], col = NA))\n    ), col = col)\nmat_list = list(snv = matrix(c(1, 0, 1, 1, 1, 0, 0, 1, 1), nrow = 3),\n                indel = matrix(c(1, 0, 0, 0, 1, 0, 1, 0, 0), nrow = 3))\nrownames(mat_list$snv) = rownames(mat_list$indel) = c(\"g1\", \"g2\", \"g3\")\ncolnames(mat_list$snv) = colnames(mat_list$indel) = c(\"s1\", \"s2\", \"s3\")\nmat_list## $snv\n##    s1 s2 s3\n## g1  1  1  0\n## g2  0  1  1\n## g3  1  0  1\n## \n## $indel\n##    s1 s2 s3\n## g1  1  0  1\n## g2  0  1  0\n## g3  0  0  0\n# now you don't need `get_type`\noncoPrint(mat_list,\n    alter_fun = list(\n        snv = function(x, y, w, h) grid.rect(x, y, w*0.9, h*0.9, \n            gp = gpar(fill = col[\"snv\"], col = NA)),\n        indel = function(x, y, w, h) grid.rect(x, y, w*0.9, h*0.4, \n            gp = gpar(fill = col[\"indel\"], col = NA))\n    ), col = col)"},{"path":"oncoprint.html","id":"define-the-alter-fun","chapter":"7 OncoPrint","heading":"7.1.2 Define the alter_fun()","text":"alter_fun list functons add graphics layer layer (.e.\nfirst draw snv, indel). Graphics can also added \ngrid--grid style specifying alter_fun single function. \ndifference function list now alter_fun accept fifth\nargument logical vector. logical vector shows whether\ndifferent alterations exist current gene current sample.Let’s assume grid snv event, v grid :alter_fun set single function, customization can \nflexible. following example, blue rectangles can different height\ndifferent grid.Following complicated example alter_fun triangles used:cases, might need define alter_fun many alteration types.\nsure visual effect alter_fun, can use\ntest_alter_fun() test alter_fun. following example, defined\nseven alteration functions:combination alteration types, test_alter_fun() randomly samples\n.test_alter_fun() works alter_fun list single\nfunction.","code":"##   snv indel \n##  TRUE FALSE\noncoPrint(mat,\n    alter_fun = function(x, y, w, h, v) {\n        if(v[\"snv\"]) grid.rect(x, y, w*0.9, h*0.9, # v[\"snv\"] is a logical value\n            gp = gpar(fill = col[\"snv\"], col = NA))\n        if(v[\"indel\"]) grid.rect(x, y, w*0.9, h*0.4, # v[\"indel\"] is a logical value\n            gp = gpar(fill = col[\"indel\"], col = NA))\n    }, col = col)\noncoPrint(mat,\n    alter_fun = function(x, y, w, h, v) {\n        n = sum(v)  # how many alterations for current gene in current sample\n        h = h*0.9\n        # use `names(which(v))` to correctly map between `v` and `col`\n        if(n) grid.rect(x, y - h*0.5 + 1:n/n*h, w*0.9, 1/n*h, \n            gp = gpar(fill = col[names(which(v))], col = NA), just = \"top\")\n    }, col = col)\noncoPrint(mat,\n    alter_fun = list(\n        background = function(x, y, w, h) {\n            grid.polygon(\n                unit.c(x - 0.5*w, x - 0.5*w, x + 0.5*w), \n                unit.c(y - 0.5*h, y + 0.5*h, y - 0.5*h),\n                gp = gpar(fill = \"grey\", col = \"white\"))\n            grid.polygon(\n                unit.c(x + 0.5*w, x + 0.5*w, x - 0.5*w), \n                unit.c(y + 0.5*h, y - 0.5*h, y + 0.5*h),\n                gp = gpar(fill = \"grey\", col = \"white\"))\n        },\n        snv = function(x, y, w, h) {\n            grid.polygon(\n                unit.c(x - 0.5*w, x - 0.5*w, x + 0.5*w), \n                unit.c(y - 0.5*h, y + 0.5*h, y - 0.5*h),\n                gp = gpar(fill = col[\"snv\"], col = \"white\"))\n        },\n        indel = function(x, y, w, h) {\n            grid.polygon(\n                unit.c(x + 0.5*w, x + 0.5*w, x - 0.5*w), \n                unit.c(y + 0.5*h, y - 0.5*h, y + 0.5*h),\n                gp = gpar(fill = col[\"indel\"], col = \"white\"))\n        }\n    ), col = col)\nalter_fun = list(\n    mut1 = function(x, y, w, h) \n        grid.rect(x, y, w, h, gp = gpar(fill = \"red\", col = NA)),\n    mut2 = function(x, y, w, h) \n        grid.rect(x, y, w, h, gp = gpar(fill = \"blue\", col = NA)),\n    mut3 = function(x, y, w, h) \n        grid.rect(x, y, w, h, gp = gpar(fill = \"yellow\", col = NA)),\n    mut4 = function(x, y, w, h) \n        grid.rect(x, y, w, h, gp = gpar(fill = \"purple\", col = NA)),\n    mut5 = function(x, y, w, h) \n        grid.rect(x, y, w, h, gp = gpar(fill = NA, lwd = 2)),\n    mut6 = function(x, y, w, h) \n        grid.points(x, y, pch = 16),\n    mut7 = function(x, y, w, h) \n        grid.segments(x - w*0.5, y - h*0.5, x + w*0.5, y + h*0.5, gp = gpar(lwd = 2))\n)\ntest_alter_fun(alter_fun)## `alter_fun` is defined as a list of functions.\n## Functions are defined for following alteration types:\n##   mut1, mut2, mut3, mut4, mut5, mut6, mut7"},{"path":"oncoprint.html","id":"oncoprint-background","chapter":"7 OncoPrint","heading":"7.1.3 Background","text":"alter_fun specified list, order elements controls \norder adding graphics. special element called background \ndefines draw background always put first\nelement alter_fun list. following example, backgrond color \nchanged light green borders.just remove background (don’t set NULL. Setting background\ndirectly NULL means use default style background whch \ngrey):","code":"\noncoPrint(mat,\n    alter_fun = list(\n        background = function(x, y, w, h) grid.rect(x, y, w, h, \n            gp = gpar(fill = \"#00FF0020\")),\n        snv = function(x, y, w, h) grid.rect(x, y, w*0.9, h*0.9, \n            gp = gpar(fill = col[\"snv\"], col = NA)),\n        indel = function(x, y, w, h) grid.rect(x, y, w*0.9, h*0.4, \n            gp = gpar(fill = col[\"indel\"], col = NA))\n    ), col = col)\noncoPrint(mat,\n    alter_fun = list(\n        background = function(...) NULL,\n        snv = function(x, y, w, h) grid.rect(x, y, w*0.9, h*0.9, \n            gp = gpar(fill = col[\"snv\"], col = NA)),\n        indel = function(x, y, w, h) grid.rect(x, y, w*0.9, h*0.4, \n            gp = gpar(fill = col[\"indel\"], col = NA))\n    ), col = col)"},{"path":"oncoprint.html","id":"complex-alteration-types","chapter":"7 OncoPrint","heading":"7.1.4 Complex alteration types","text":"easy many different alteration types integrating\ninformation multiple analysis results. sometimes difficult \ndesign graphics assign different colors (e.g. see plot \nlink.\nhand, alteration types, primary classes \nalteration types important distinguish, \nsecondary classes less important. example, may alteration\ntypes “intronic snv,” “exonic snv,” “intronic indel” “exonic indel.”\nActually can classify two classes “snv/indel” \nimportant belong primary class, “intronic/exonic” less\nimportant belong secondary class. Reflecting oncoPrint,\n“intronic snv” “exonic snv,” want use similar graphics\nsnvs want visually similar, add slightly\ndifferent symbols represent “intronic” “exonic,” E.g. can use red\nrectangle snv red rectangles, use dots represent\n“intronic” cross lines represent “exonic.” barplot annotations\nsummarize number different alteration types, don’t want \nseparate “intronic snv” “exonic snv” prefer simply get \ntotal number snv get rid many categories barplots.Let’s demonstrate scenario following simulated data. simplify \nexample, assume single gene single sample, either\nsnv indel can either intronic exonic. \n“intronic” “exonic” attached gene, basically means don’t \ngene-related information (maybe intergenic snv/indel).Now m, four different alteration types: snv, indel,\nintronic exonic. Next define alter_fun four alterations.alteration types primary class (snv indel), use\ncolorred rectangles represent rectangles visually\nobvious, alteration types secondary class (intronic \nexonic), use simple symbols (dots intronic crossed\ndiagonal lines exonic). Since color corresponding \nintronic exonic, don’t need define colors two types,\nbarplot annotation genes samples, snv indel\nvisualized (height snv barplot corresponds number\nintronic snv plus exonic snv).","code":"\nset.seed(123)\nx1 = sample(c(\"\", \"snv\"), 100, replace = TRUE, prob = c(8, 2))\nx2 = sample(c(\"\", \"indel\"), 100, replace = TRUE, prob = c(8, 2))\nx2[x1 == \"snv\"] = \"\"\nx3 = sample(c(\"\", \"intronic\"), 100, replace = TRUE, prob = c(5, 5))\nx4 = sample(c(\"\", \"exonic\"), 100, replace = TRUE, prob = c(5, 5))\nx3[x1 == \"\" & x2 == \"\"] = \"\"\nx4[x1 == \"\" & x2 == \"\"] = \"\"\nx4[x3 == \"intronic\"] = \"\"\nx = apply(cbind(x1, x2, x3, x4), 1, function(x) {\n    x = x[x != \"\"]\n    paste(x, collapse = \";\")\n})\nm = matrix(x, nrow = 10, ncol = 10, dimnames = list(paste0(\"g\", 1:10), paste0(\"s\", 1:10)))\nm[1:4, 1:4]##    s1    s2             s3             s4            \n## g1 \"\"    \"snv;intronic\" \"snv;intronic\" \"snv\"         \n## g2 \"\"    \"\"             \"\"             \"snv;intronic\"\n## g3 \"\"    \"\"             \"\"             \"\"            \n## g4 \"snv\" \"indel;exonic\" \"snv\"          \"\"\nalter_fun = list(\n    background = function(x, y, w, h) \n        grid.rect(x, y, w*0.9, h*0.9, gp = gpar(fill = \"#CCCCCC\", col = NA)),\n    # red rectangles\n    snv = function(x, y, w, h) \n        grid.rect(x, y, w*0.9, h*0.9, gp = gpar(fill = \"red\", col = NA)),\n    # blue rectangles\n    indel = function(x, y, w, h) \n        grid.rect(x, y, w*0.9, h*0.9, gp = gpar(fill = \"blue\", col = NA)),\n    # dots\n    intronic = function(x, y, w, h) \n        grid.points(x, y, pch = 16),\n    # crossed lines\n    exonic = function(x, y, w, h) {\n        grid.segments(x - w*0.4, y - h*0.4, x + w*0.4, y + h*0.4, gp = gpar(lwd = 2))\n        grid.segments(x + w*0.4, y - h*0.4, x - w*0.4, y + h*0.4, gp = gpar(lwd = 2))\n    }\n)\n# we only define color for snv and indel, so barplot annotations only show snv and indel\noncoPrint(m, alter_fun = alter_fun, col = c(snv = \"red\", indel = \"blue\"))"},{"path":"oncoprint.html","id":"simplify-alter_fun","chapter":"7 OncoPrint","heading":"7.1.5 Simplify alter_fun","text":"graphics simple graphics, e.g., rectangles, points, graphic\nfunctions can automatically generated alter_graphic() function. One previous example\ncan simplied :","code":"\noncoPrint(mat,\n    alter_fun = list(\n        snv = alter_graphic(\"rect\", width = 0.9, height = 0.9, fill = col[\"snv\"]),\n        indel = alter_graphic(\"rect\", width = 0.9, height = 0.4, fill = col[\"indel\"])\n    ), col = col)"},{"path":"oncoprint.html","id":"other-heatmap-related-settings","chapter":"7 OncoPrint","heading":"7.1.6 Other heatmap-related settings","text":"Column names default drawn plot. can turned \nsetting show_column_names = TRUE.Row names percent texts can turned /setting show_pct\nshow_row_names. side according oncoPrint controlled\npct_side row_names_side. Digits percent values controlled\npct_digits.barplot annotations side controlled \nanno_oncoprint_barplot() annotation function. Customization size\naxes can set directly anno_oncoprint_barplot(). examples\nsetting anno_oncoprint_barplot() can found Section 7.2.3.people might want move right barplots left oncoPrint:OncoPrints essentially heatmaps, thus, many arguments set \nHeatmap() can also set oncoPrint(). following section, use \nreal-world dataset demonstrate use oncoPrint() function.","code":"\nalter_fun = list(\n    snv = function(x, y, w, h) grid.rect(x, y, w*0.9, h*0.9, \n        gp = gpar(fill = col[\"snv\"], col = NA)),\n    indel = function(x, y, w, h) grid.rect(x, y, w*0.9, h*0.4, \n        gp = gpar(fill = col[\"indel\"], col = NA))\n)\noncoPrint(mat, alter_fun = alter_fun, col = col, show_column_names = TRUE)\noncoPrint(mat, alter_fun = alter_fun, col = col, \n    row_names_side = \"left\", pct_side = \"right\", pct_digits = 2)\noncoPrint(mat, alter_fun = alter_fun, col = col, \n    top_annotation = HeatmapAnnotation(\n        cbar = anno_oncoprint_barplot(height = unit(1, \"cm\"))),\n    right_annotation = rowAnnotation(\n        rbar = anno_oncoprint_barplot(\n            width = unit(4, \"cm\"),\n            axis_param = list(at = c(0, 2, 4), \n                labels = c(\"zero\", \"two\", \"four\"),\n                side = \"top\",\n                labels_rot = 0))),\n    )\noncoPrint(mat, alter_fun = alter_fun, col = col, \n    left_annotation =  rowAnnotation(\n        rbar = anno_oncoprint_barplot(\n            axis_param = list(direction = \"reverse\")\n    )),\n    right_annotation = NULL)"},{"path":"oncoprint.html","id":"apply-to-cbioportal-dataset","chapter":"7 OncoPrint","heading":"7.2 Apply to cBioPortal dataset","text":"use real-world dataset demonstrate advanced usage oncoPrint().\ndata retrieved cBioPortal.\nSteps getting data follows:go http://www.cbioportal.org,search Cancer Study: “Lung Adenocarcinoma Carcinoma” select: “Lung\nAdenocarcinoma Carcinoma (TCGA, Provisinal),”“Enter Gene Set” field, select: “General: Ras-Raf-MEK-Erk/JNK\nsignaling (26 genes),”submit form.result page,go “Download” tab, download text “Type Genetic alterations\nacross cases.”order samples can also downloaded results page,go “OncoPrint” tab, move mouse plot, click “download”\nicon click “Sample order.”data already ComplexHeatmap package. First read data \nmake pre-processing.three different alterations mat: HOMDEL, AMP MUT. first\ndefine add graphics different alterations.Just note, since graphics rectangles, can simplied generating alter_graphic():Now make oncoPrint. save column_title heatmap_legend_param\nvaraibles used multiple times following code chunks.see, genes samples reordered automatically. Rows sorted\nbased frequency alterations samples columns \nreordered visualize mutual exclusivity samples. column\nreordering based “memo sort” method, adapted \nhttps://gist.github.com/armish/564a65ab874a770e2c26.","code":"\nmat = read.table(system.file(\"extdata\", package = \"ComplexHeatmap\", \n    \"tcga_lung_adenocarcinoma_provisional_ras_raf_mek_jnk_signalling.txt\"), \n    header = TRUE, stringsAsFactors = FALSE, sep = \"\\t\")\nmat[is.na(mat)] = \"\"\nrownames(mat) = mat[, 1]\nmat = mat[, -1]\nmat=  mat[, -ncol(mat)]\nmat = t(as.matrix(mat))\nmat[1:3, 1:3]##      TCGA-05-4384-01 TCGA-05-4390-01 TCGA-05-4425-01\n## KRAS \"  \"            \"MUT;\"          \"  \"           \n## HRAS \"  \"            \"  \"            \"  \"           \n## BRAF \"  \"            \"  \"            \"  \"\ncol = c(\"HOMDEL\" = \"blue\", \"AMP\" = \"red\", \"MUT\" = \"#008000\")\nalter_fun = list(\n    background = function(x, y, w, h) {\n        grid.rect(x, y, w-unit(2, \"pt\"), h-unit(2, \"pt\"), \n            gp = gpar(fill = \"#CCCCCC\", col = NA))\n    },\n    # big blue\n    HOMDEL = function(x, y, w, h) {\n        grid.rect(x, y, w-unit(2, \"pt\"), h-unit(2, \"pt\"), \n            gp = gpar(fill = col[\"HOMDEL\"], col = NA))\n    },\n    # big red\n    AMP = function(x, y, w, h) {\n        grid.rect(x, y, w-unit(2, \"pt\"), h-unit(2, \"pt\"), \n            gp = gpar(fill = col[\"AMP\"], col = NA))\n    },\n    # small green\n    MUT = function(x, y, w, h) {\n        grid.rect(x, y, w-unit(2, \"pt\"), h*0.33, \n            gp = gpar(fill = col[\"MUT\"], col = NA))\n    }\n)\n# just for demonstration\nalter_fun = list(\n    background = alter_graphic(\"rect\", fill = \"#CCCCCC\"),   \n    HOMDEL = alter_graphic(\"rect\", fill = col[\"HOMDEL\"]),\n    AMP = alter_graphic(\"rect\", fill = col[\"AMP\"]),\n    MUT = alter_graphic(\"rect\", height = 0.33, fill = col[\"MUT\"])\n)\ncolumn_title = \"OncoPrint for TCGA Lung Adenocarcinoma, genes in Ras Raf MEK JNK signalling\"\nheatmap_legend_param = list(title = \"Alternations\", at = c(\"HOMDEL\", \"AMP\", \"MUT\"), \n        labels = c(\"Deep deletion\", \"Amplification\", \"Mutation\"))\noncoPrint(mat,\n    alter_fun = alter_fun, col = col, \n    column_title = column_title, heatmap_legend_param = heatmap_legend_param)"},{"path":"oncoprint.html","id":"remove-empty-rows-and-columns","chapter":"7 OncoPrint","heading":"7.2.1 Remove empty rows and columns","text":"default, samples genes alterations, still remain \nheatmap, can set remove_empty_columns remove_empty_rows \nTRUE remove :number rows columns may reduced empty rows columns \nremoved. components oncoPrint adjusted accordingly. \noncoPrint concatenated heatmaps annotations, may\ncause problem number rows columns identical \nheatmap list. , put oncoPrint heatmap list don’t\nwant see empty rows columns, need remove manually \nsending oncoPrint() function (preprocess easy \n!).","code":"\noncoPrint(mat,\n    alter_fun = alter_fun, col = col, \n    remove_empty_columns = TRUE, remove_empty_rows = TRUE,\n    column_title = column_title, heatmap_legend_param = heatmap_legend_param)"},{"path":"oncoprint.html","id":"reorder-the-oncoprint","chapter":"7 OncoPrint","heading":"7.2.2 Reorder the oncoPrint","text":"normal Heatmap() function, row_order column_order can \nassigned vector orders (either numeric character). following\nexample, order samples gathered cBio well. can see \ndifference sample order ‘memo sort’ method used \ncBio., row_order column_order automatically adjusted \nremove_empty_rows remove_empty_columns set TRUE.","code":"\nsample_order = scan(paste0(system.file(\"extdata\", package = \"ComplexHeatmap\"), \n    \"/sample_order.txt\"), what = \"character\")\noncoPrint(mat,\n    alter_fun = alter_fun, col = col, \n    row_order = 1:nrow(mat), column_order = sample_order,\n    remove_empty_columns = TRUE, remove_empty_rows = TRUE,\n    column_title = column_title, heatmap_legend_param = heatmap_legend_param)"},{"path":"oncoprint.html","id":"oncoprint-annotations","chapter":"7 OncoPrint","heading":"7.2.3 OncoPrint annotations","text":"oncoPrint several pre-defined annotations.top right oncoPrint, barplots showing number \ndifferent alterations gene sample, left \noncoPrint text annotation showing percent samples \nalterations every gene.barplot annotation implemented anno_oncoprint_barplot() \ncan set annotation . Barplots default draw alteration\ntypes, can also select subset alterations put barplots \nsetting anno_oncoprint_barplot(). anno_oncoprint_barplot() simple\nwrapper around anno_barplot() frequency matrix just interanlly\ncalculated. See following example:default barplot annotation shows frequencies. values can changed\nfraction setting show_fraction = TRUE anno_oncoprint_barplot():percent values row names internally constructed text\nannotations. can set show_pct show_row_names turn \n. pct_side row_names_side controls sides put.barplot annotation oncoPrint essentially normal annotations, \ncan add annotations HeatmapAnnotation() rowAnnotation() \nnormal way:see, percent annotation, row name annotation oncoPrint\nannotation appended user-specified annotation default. Also\nannotations automatically adjusted remove_empty_columns \nremove_empty_rows set TRUE.","code":"\noncoPrint(mat,\n    alter_fun = alter_fun, col = col, \n    top_annotation = HeatmapAnnotation(\n        column_barplot = anno_oncoprint_barplot(\"MUT\", border = TRUE, # only MUT\n            height = unit(4, \"cm\"))\n    ),\n    right_annotation = rowAnnotation(\n        row_barplot = anno_oncoprint_barplot(c(\"AMP\", \"HOMDEL\"),  # only AMP and HOMDEL\n            border = TRUE, height = unit(4, \"cm\"), \n            axis_param = list(side = \"bottom\", labels_rot = 90))\n    ),\n    remove_empty_columns = TRUE, remove_empty_rows = TRUE,\n    column_title = column_title, heatmap_legend_param = heatmap_legend_param)\noncoPrint(mat,\n    alter_fun = alter_fun, col = col, \n    top_annotation = HeatmapAnnotation(\n        column_barplot = anno_oncoprint_barplot(show_fraction = TRUE)\n    ),\n    right_annotation = rowAnnotation(\n        row_barplot = anno_oncoprint_barplot(show_fraction = TRUE)\n    ),\n    remove_empty_columns = TRUE, remove_empty_rows = TRUE,\n    column_title = column_title, heatmap_legend_param = heatmap_legend_param)\noncoPrint(mat,\n    alter_fun = alter_fun, col = col, \n    remove_empty_columns = TRUE, remove_empty_rows = TRUE,\n    pct_side = \"right\", row_names_side = \"left\",\n    column_title = column_title, heatmap_legend_param = heatmap_legend_param)\noncoPrint(mat,\n    alter_fun = alter_fun, col = col, \n    remove_empty_columns = TRUE, remove_empty_rows = TRUE,\n    top_annotation = HeatmapAnnotation(cbar = anno_oncoprint_barplot(),\n        foo1 = 1:172,\n        bar1 = anno_points(1:172)\n    ),\n    left_annotation = rowAnnotation(foo2 = 1:26),\n    right_annotation = rowAnnotation(bar2 = anno_barplot(1:26)),\n    column_title = column_title, heatmap_legend_param = heatmap_legend_param)"},{"path":"oncoprint.html","id":"oncoprint-as-a-heatmap","chapter":"7 OncoPrint","heading":"7.2.4 oncoPrint as a Heatmap","text":"oncoPrint() actually returns Heatmap object, can add \nheatmaps annotations horizontally vertically visualize \ncomplicated associations.Following example adds heatmap horizontally. Remember can always add row\nannotations heatmap list.add vertically:Similar normal heatmap list, can split heatmap list:remove_empty_columns remove_empty_rows set TRUE, \nnumber genes samples may original number. original\nmatrix row names column names. subset rows columns can \nget follows:","code":"\nht_list = oncoPrint(mat,\n    alter_fun = alter_fun, col = col, \n    column_title = column_title, heatmap_legend_param = heatmap_legend_param) +\nHeatmap(matrix(rnorm(nrow(mat)*10), ncol = 10), name = \"expr\", width = unit(4, \"cm\"))\ndraw(ht_list)\nht_list = oncoPrint(mat,\n    alter_fun = alter_fun, col = col, \n    column_title = column_title, heatmap_legend_param = heatmap_legend_param) %v%\nHeatmap(matrix(rnorm(ncol(mat)*10), nrow = 10), name = \"expr\", height = unit(4, \"cm\"))\ndraw(ht_list)\nht_list = oncoPrint(mat,\n    alter_fun = alter_fun, col = col, \n    column_title = column_title, heatmap_legend_param = heatmap_legend_param) +\nHeatmap(matrix(rnorm(nrow(mat)*10), ncol = 10), name = \"expr\", width = unit(4, \"cm\"))\ndraw(ht_list, row_split = sample(c(\"a\", \"b\"), nrow(mat), replace = TRUE))\nht = oncoPrint(mat,\n    alter_fun = alter_fun, col = col, \n    remove_empty_columns = TRUE, remove_empty_rows = TRUE,\n    column_title = column_title, heatmap_legend_param = heatmap_legend_param)\nrownames(ht@matrix)##  [1] \"KRAS\"   \"HRAS\"   \"BRAF\"   \"RAF1\"   \"MAP3K1\" \"MAP3K2\" \"MAP3K3\" \"MAP3K4\"\n##  [9] \"MAP3K5\" \"MAP2K1\" \"MAP2K2\" \"MAP2K3\" \"MAP2K4\" \"MAPK3\"  \"MAPK4\"  \"MAPK7\" \n## [17] \"MAPK8\"  \"MAPK9\"  \"MAPK12\" \"MAPK14\" \"DAB2\"   \"RAB25\"\ncolnames(ht@matrix)##   [1] \"TCGA-05-4390-01\" \"TCGA-38-4631-01\" \"TCGA-44-6144-01\" \"TCGA-44-6145-01\"\n##   [5] \"TCGA-44-6146-01\" \"TCGA-49-4488-01\" \"TCGA-50-5930-01\" \"TCGA-50-5931-01\"\n##   [9] \"TCGA-50-5932-01\" \"TCGA-50-5933-01\" \"TCGA-50-5941-01\" \"TCGA-50-5942-01\"\n##  [13] \"TCGA-50-5944-01\" \"TCGA-50-5946-01\" \"TCGA-50-6591-01\" \"TCGA-50-6592-01\"\n##  [17] \"TCGA-50-6594-01\" \"TCGA-67-4679-01\" \"TCGA-67-6215-01\" \"TCGA-73-4658-01\"\n##  [21] \"TCGA-73-4676-01\" \"TCGA-75-5122-01\" \"TCGA-75-5125-01\" \"TCGA-75-5126-01\"\n##  [25] \"TCGA-75-6206-01\" \"TCGA-75-6211-01\" \"TCGA-86-6562-01\" \"TCGA-05-4396-01\"\n##  [29] \"TCGA-05-4405-01\" \"TCGA-05-4410-01\" \"TCGA-05-4415-01\" \"TCGA-05-4417-01\"\n##  [33] \"TCGA-05-4424-01\" \"TCGA-05-4427-01\" \"TCGA-05-4433-01\" \"TCGA-44-6774-01\"\n##  [37] \"TCGA-44-6775-01\" \"TCGA-44-6776-01\" \"TCGA-44-6777-01\" \"TCGA-44-6778-01\"\n##  [41] \"TCGA-49-4487-01\" \"TCGA-49-4490-01\" \"TCGA-49-6744-01\" \"TCGA-49-6745-01\"\n##  [45] \"TCGA-49-6767-01\" \"TCGA-50-5044-01\" \"TCGA-50-5051-01\" \"TCGA-50-5072-01\"\n##  [49] \"TCGA-50-6590-01\" \"TCGA-55-6642-01\" \"TCGA-55-6712-01\" \"TCGA-71-6725-01\"\n##  [53] \"TCGA-91-6828-01\" \"TCGA-91-6829-01\" \"TCGA-91-6835-01\" \"TCGA-91-6836-01\"\n##  [57] \"TCGA-35-3615-01\" \"TCGA-44-2655-01\" \"TCGA-44-2656-01\" \"TCGA-44-2662-01\"\n##  [61] \"TCGA-44-2666-01\" \"TCGA-44-2668-01\" \"TCGA-55-1592-01\" \"TCGA-55-1594-01\"\n##  [65] \"TCGA-55-1595-01\" \"TCGA-64-1676-01\" \"TCGA-64-1677-01\" \"TCGA-64-1678-01\"\n##  [69] \"TCGA-64-1680-01\" \"TCGA-67-3771-01\" \"TCGA-67-3773-01\" \"TCGA-67-3774-01\"\n##  [73] \"TCGA-05-4244-01\" \"TCGA-05-4249-01\" \"TCGA-05-4250-01\" \"TCGA-35-4122-01\"\n##  [77] \"TCGA-35-4123-01\" \"TCGA-44-2657-01\" \"TCGA-44-3398-01\" \"TCGA-44-3918-01\"\n##  [81] \"TCGA-05-4382-01\" \"TCGA-05-4389-01\" \"TCGA-05-4395-01\" \"TCGA-05-4397-01\"\n##  [85] \"TCGA-05-4398-01\" \"TCGA-05-4402-01\" \"TCGA-05-4403-01\" \"TCGA-05-4418-01\"\n##  [89] \"TCGA-05-4420-01\" \"TCGA-05-4422-01\" \"TCGA-05-4426-01\" \"TCGA-05-4430-01\"\n##  [93] \"TCGA-05-4434-01\" \"TCGA-38-4625-01\" \"TCGA-38-4626-01\" \"TCGA-38-4628-01\"\n##  [97] \"TCGA-38-4630-01\" \"TCGA-44-3396-01\" \"TCGA-49-4486-01\" \"TCGA-49-4505-01\"\n## [101] \"TCGA-49-4506-01\" \"TCGA-49-4507-01\" \"TCGA-49-4510-01\" \"TCGA-73-4659-01\"\n## [105] \"TCGA-73-4662-01\" \"TCGA-73-4668-01\" \"TCGA-73-4670-01\" \"TCGA-73-4677-01\"\n## [109] \"TCGA-05-5428-01\" \"TCGA-05-5715-01\" \"TCGA-50-5045-01\" \"TCGA-50-5049-01\"\n## [113] \"TCGA-50-5936-01\" \"TCGA-55-5899-01\" \"TCGA-64-5774-01\" \"TCGA-64-5775-01\"\n## [117] \"TCGA-64-5778-01\" \"TCGA-64-5815-01\" \"TCGA-75-5146-01\" \"TCGA-75-5147-01\"\n## [121] \"TCGA-80-5611-01\""},{"path":"upset-plot.html","id":"upset-plot","chapter":"8 UpSet plot","heading":"8 UpSet plot","text":"UpSet plot provides efficient way \nvisualize intersections multiple sets compared traditional\napproaches, .e. Venn Diagram. implemented UpSetR\npackage R. re-implemented\nUpSet plots ComplexHeatmap package improvements.","code":""},{"path":"upset-plot.html","id":"input-data","chapter":"8 UpSet plot","heading":"8.1 Input data","text":"represent multiple sets, variable can represented :list sets set vector, e.g.:binary matrix/data frame rows elements columns sets,\ne.g.:matrix, e.g., row t, means, t set set1, set set2, \nset set3. Note matrix also valid logical matrix.variable data frame, binary columns (contain 0 1) \nlogical columns used.formats can used making UpSet plots, users can still use\nlist_to_matrix() convert list binary matrix.can also set universal set list_to_matrix():universal set completely cover input sets,\nelements universal set removed:set can genomic intervals, can represented list\nGRanges/IRanges objects.","code":"\nlist(set1 = c(\"a\", \"b\", \"c\"),\n     set2 = c(\"b\", \"c\", \"d\", \"e\"),\n     ...)  set1 set2 set3\nh    1    1    1\nt    1    0    1\nj    1    0    0\nu    1    0    1\nw    1    0    0\n...\nlt = list(set1 = c(\"a\", \"b\", \"c\"),\n          set2 = c(\"b\", \"c\", \"d\", \"e\"))\nlist_to_matrix(lt)##   set1 set2\n## a    1    0\n## b    1    1\n## c    1    1\n## d    0    1\n## e    0    1\nlist_to_matrix(lt, universal = letters[1:10])##   set1 set2\n## a    1    0\n## b    1    1\n## c    1    1\n## d    0    1\n## e    0    1\n## f    0    0\n## g    0    0\n## h    0    0\n## i    0    0\n## j    0    0\nlist_to_matrix(lt, universal = letters[1:4])##   set1 set2\n## a    1    0\n## b    1    1\n## c    1    1\n## d    0    1\nlist(set1 = GRanges(...),\n     set2 = GRanges(...),\n     ...)"},{"path":"upset-plot.html","id":"upset-mode","chapter":"8 UpSet plot","heading":"8.2 Mode","text":"E.g. three sets (, B, C), combinations selecting\nelements set set encoded following:value 1 means select set 0 means select set.\nE.g., 1 1 0 means select set , B set C. Note 0 0 0, background set interest . following part \nsection, refer , B C sets combination\ncombination set. whole binary matrix called combination\nmatrix.UpSet plot visualizes size combination set. \nbinary code combination set, next need define calculate\nsize combination set. three modes:distinct mode: 1 means set 0 means set, 1 1    0 means set elements set B, C\n(setdiff(intersect(, B), C)). mode, seven combination\nsets seven partitions Venn diagram mutually\nexclusive.distinct mode: 1 means set 0 means set, 1 1    0 means set elements set B, C\n(setdiff(intersect(, B), C)). mode, seven combination\nsets seven partitions Venn diagram mutually\nexclusive.intersect mode: 1 means set 0 taken account,\n, 1 1 0 means set elements set B, can\nalso C C (intersect(, B)). mode, \nseven combination sets can overlap.intersect mode: 1 means set 0 taken account,\n, 1 1 0 means set elements set B, can\nalso C C (intersect(, B)). mode, \nseven combination sets can overlap.union mode: 1 means set 0 taken account. \nmultiple 1, relationship . , 1 1 0 means set\nelements set B, can also C \nC (union(, B)). mode, seven combination sets can\noverlap.union mode: 1 means set 0 taken account. \nmultiple 1, relationship . , 1 1 0 means set\nelements set B, can also C \nC (union(, B)). mode, seven combination sets can\noverlap.three modes illustrated following figure:","code":"A B C\n1 1 1\n1 1 0\n1 0 1\n0 1 1\n1 0 0\n0 1 0\n0 0 1"},{"path":"upset-plot.html","id":"make-the-combination-matrix","chapter":"8 UpSet plot","heading":"8.3 Make the combination matrix","text":"function make_comb_mat() generates combination matrix well \ncalculates size sets combination sets. input can one\nsingle variable name-value pairs:m1, m2 m3 identical.mode controlled mode argument:UpSet plots different modes demonstrated later sections.many sets, sets can pre-filtered set sizes.\nmin_set_size top_n_sets purpose. min_set_size\ncontrols minimal size sets top_n_sets controls number \ntop sets largest sizes.subsetting sets affects calculation sizes \ncombination sets, needs controlled combination\nmatrix generation step. subsetting combination sets can directly\nperformed subsetting matrix:make_comb_mat() also allows specify universal set complement\nset contains elements belonging set also considered.universal set can smaller union sets, \nset, intersection universal set considered.already know size complement size, can directly set\ncomplement_size argument.input matrix contains elements belong \nset, elements treated complement set.Next demonstrate second example, sets genomic regions.\nsets genomic regions, size calculated sum \nwidth regions set (words, total number base\npairs).don’t recommend use number regions intersection two\nsets genomic regions. two reasons: 1. value symmetric, .e.\nnumber intersected regions measured set1 always identical number\nintersected regions measured set2, thus, difficult assign value\nintersection set1 set2; 2. one long region set1 overlaps \nanother long region set2, base pairs, make sense say\ntwo regions common two sets?universal set also works sets genomic regions.","code":"\nset.seed(123)\nlt = list(a = sample(letters, 5),\n          b = sample(letters, 10),\n          c = sample(letters, 15))\nm1 = make_comb_mat(lt)\nm1## A combination matrix with 3 sets and 7 combinations.\n##   ranges of combination set size: c(1, 8).\n##   mode for the combination size: distinct.\n##   sets are on rows.\n## \n## Combination sets are:\n##   a b c code size\n##   x x x  111    2\n##   x x    110    1\n##   x   x  101    1\n##     x x  011    4\n##   x      100    1\n##     x    010    3\n##       x  001    8\n## \n## Sets are:\n##   set size\n##     a    5\n##     b   10\n##     c   15\nm2 = make_comb_mat(a = lt$a, b = lt$b, c = lt$c)\nm3 = make_comb_mat(list_to_matrix(lt))\nm1 = make_comb_mat(lt) # the default mode is `distinct`\nm2 = make_comb_mat(lt, mode = \"intersect\")\nm3 = make_comb_mat(lt, mode = \"union\")\nm1 = make_comb_mat(lt, min_set_size = 6)\nm2 = make_comb_mat(lt, top_n_sets = 2)\nm = make_comb_mat(lt)\nm[1:4]## A combination matrix with 3 sets and 4 combinations.\n##   ranges of combination set size: c(1, 4).\n##   mode for the combination size: distinct.\n##   sets are on rows.\n## \n## Combination sets are:\n##   a b c code size\n##   x x x  111    2\n##   x x    110    1\n##   x   x  101    1\n##     x x  011    4\n## \n## Sets are:\n##   set size\n##     a    5\n##     b   10\n##     c   15\nm = make_comb_mat(lt, universal_set = letters)\nm## A combination matrix with 3 sets and 8 combinations.\n##   ranges of combination set size: c(1, 8).\n##   mode for the combination size: distinct.\n##   sets are on rows.\n## \n## Combination sets are:\n##   a b c code size\n##   x x x  111    2\n##   x x    110    1\n##   x   x  101    1\n##     x x  011    4\n##   x      100    1\n##     x    010    3\n##       x  001    8\n##          000    6\n## \n## Sets are:\n##          set size\n##            a    5\n##            b   10\n##            c   15\n##   complement    6\nm = make_comb_mat(lt, universal_set = letters[1:10])\nm## A combination matrix with 3 sets and 5 combinations.\n##   ranges of combination set size: c(1, 3).\n##   mode for the combination size: distinct.\n##   sets are on rows.\n## \n## Combination sets are:\n##   a b c code size\n##   x x    110    1\n##   x   x  101    1\n##     x x  011    2\n##       x  001    3\n##          000    3\n## \n## Sets are:\n##          set size\n##            a    2\n##            b    3\n##            c    6\n##   complement    3\nm = make_comb_mat(lt, complement_size = 5)\nm## A combination matrix with 3 sets and 8 combinations.\n##   ranges of combination set size: c(1, 8).\n##   mode for the combination size: distinct.\n##   sets are on rows.\n## \n## Combination sets are:\n##   a b c code size\n##   x x x  111    2\n##   x x    110    1\n##   x   x  101    1\n##     x x  011    4\n##   x      100    1\n##     x    010    3\n##       x  001    8\n##          000    5\n## \n## Sets are:\n##          set size\n##            a    5\n##            b   10\n##            c   15\n##   complement    5\nx = list_to_matrix(lt, universal_set = letters)\nm = make_comb_mat(x)\nm## A combination matrix with 3 sets and 8 combinations.\n##   ranges of combination set size: c(1, 8).\n##   mode for the combination size: distinct.\n##   sets are on rows.\n## \n## Combination sets are:\n##   a b c code size\n##   x x x  111    2\n##   x x    110    1\n##   x   x  101    1\n##     x x  011    4\n##   x      100    1\n##     x    010    3\n##       x  001    8\n##          000    6\n## \n## Sets are:\n##          set size\n##            a    5\n##            b   10\n##            c   15\n##   complement    6\nlibrary(circlize)\nlibrary(GenomicRanges)\nlt2 = lapply(1:4, function(i) generateRandomBed())\nlt2 = lapply(lt2, function(df) GRanges(seqnames = df[, 1], \n    ranges = IRanges(df[, 2], df[, 3])))\nnames(lt2) = letters[1:4]\nm2 = make_comb_mat(lt2)\nm2## A combination matrix with 4 sets and 15 combinations.\n##   ranges of combination set size: c(184941701, 199900416).\n##   mode for the combination size: distinct.\n##   sets are on rows.\n## \n## Top 8 combination sets are:\n##   a b c d code      size\n##       x x 0011 199900416\n##   x       1000 199756519\n##   x   x x 1011 198735008\n##   x x x x 1111 197341532\n##   x x x   1110 197137160\n##   x x   x 1101 194569926\n##   x     x 1001 194462988\n##   x   x   1010 192670258\n## \n## Sets are:\n##   set       size\n##     a 1566783009\n##     b 1535968265\n##     c 1560549760\n##     d 1552480645"},{"path":"upset-plot.html","id":"upset-utility-functions","chapter":"8 UpSet plot","heading":"8.4 Utility functions","text":"make_comb_mat() returns matrix, also comb_mat class. \nutility functions can applied comb_mat object:set_name(): set names.comb_name(): combination set names. names combination sets\nformatted string binary bits. E.g. three sets ,\nB, C, combination set name “101” corresponds selecting set\n, selecting set B selecting set C.set_size(): set sizes.comb_size(): combination set sizes.comb_degree(): degree combination set number sets \nselected.t(): Transpose combination matrix. default make_comb_mat()\ngenerates matrix sets rows combination sets \ncolumns, UpSet plots. transposing combination\nmatrix, position sets combination sets can swtiched \nUpSet plot.extract_comb(): Extract elements specified combination set. \nusage explained later.Functions subsetting matrix.Quick examples :using extract_comb(), valid combination set name \ncomb_name(). Note elements combination sets depends “mode”\nset make_comb_mat().example sets genomic regions:now extract_comb() returns genomic regions corresponding combination set.comb_size() comb_degree(), can filter combination matrix :complement set, name special combination set \ncomposed zeros.universal_set set make_comb_mat(), extract_comb() can \napplied complement set.universal_set set, extract_comb() also works genomic region sets.previous examples, demonstrated using “one-dimensional index” :Since combination matrix natually matrix, indices can also applied \ndimensions. default settings, sets rows combination\nsets columns, thus, indices first dimension matrix\ncorrespond sets indices second dimension correspond combination sets:New empty sets can added combination matrix :Note indices specified cover non-empty sets original\ncombination matrix, combination matrix re-calculated \naffects values combination sets:Similar subsetting second dimension correspond combination\nsets:New empty combination sets can also added setting character indices:Indices can set dimension simultaneously set indices\ncovers non-empty sets:combination matrix transposed, margin matrix \nset indices combination set indices switched.indices combination sets set one-dimensional,\nautomatically works matrices transposed :","code":"\nm = make_comb_mat(lt)\nset_name(m)## [1] \"a\" \"b\" \"c\"\ncomb_name(m)## [1] \"111\" \"110\" \"101\" \"011\" \"100\" \"010\" \"001\"\nset_size(m)##  a  b  c \n##  5 10 15\ncomb_size(m)## 111 110 101 011 100 010 001 \n##   2   1   1   4   1   3   8\ncomb_degree(m)## 111 110 101 011 100 010 001 \n##   3   2   2   2   1   1   1\nt(m)## A combination matrix with 3 sets and 7 combinations.\n##   ranges of combination set size: c(1, 8).\n##   mode for the combination size: distinct.\n##   sets are on columns\n## \n## Combination sets are:\n##   a b c code size\n##   x x x  111    2\n##   x x    110    1\n##   x   x  101    1\n##     x x  011    4\n##   x      100    1\n##     x    010    3\n##       x  001    8\n## \n## Sets are:\n##   set size\n##     a    5\n##     b   10\n##     c   15\nextract_comb(m, \"101\")## [1] \"j\"\n# `lt2` was generated in the previous section \nm2 = make_comb_mat(lt2)\nset_size(m2)##          a          b          c          d \n## 1566783009 1535968265 1560549760 1552480645\ncomb_size(m2)##      1111      1110      1101      1011      0111      1100      1010      1001 \n## 197341532 197137160 194569926 198735008 191312455 192109618 192670258 194462988 \n##      0110      0101      0011      1000      0100      0010      0001 \n## 191359036 184941701 199900416 199756519 187196837 192093895 191216619\nextract_comb(m2, \"1010\")## GRanges object with 5063 ranges and 0 metadata columns:\n##          seqnames            ranges strand\n##             <Rle>         <IRanges>  <Rle>\n##      [1]     chr1     255644-258083      *\n##      [2]     chr1     306114-308971      *\n##      [3]     chr1   1267493-1360170      *\n##      [4]     chr1   2661311-2665736      *\n##      [5]     chr1   3020553-3030645      *\n##      ...      ...               ...    ...\n##   [5059]     chrY 56286079-56286864      *\n##   [5060]     chrY 57049541-57078332      *\n##   [5061]     chrY 58691055-58699756      *\n##   [5062]     chrY 58705675-58716954      *\n##   [5063]     chrY 58765097-58776696      *\n##   -------\n##   seqinfo: 24 sequences from an unspecified genome; no seqlengths\nm = make_comb_mat(lt)\n# combination set size >= 4\nm[comb_size(m) >= 4]## A combination matrix with 3 sets and 2 combinations.\n##   ranges of combination set size: c(4, 8).\n##   mode for the combination size: distinct.\n##   sets are on rows.\n## \n## Combination sets are:\n##   a b c code size\n##     x x  011    4\n##       x  001    8\n## \n## Sets are:\n##   set size\n##     a    5\n##     b   10\n##     c   15\n# combination set degree == 2\nm[comb_degree(m) == 2]## A combination matrix with 3 sets and 3 combinations.\n##   ranges of combination set size: c(1, 4).\n##   mode for the combination size: distinct.\n##   sets are on rows.\n## \n## Combination sets are:\n##   a b c code size\n##   x x    110    1\n##   x   x  101    1\n##     x x  011    4\n## \n## Sets are:\n##   set size\n##     a    5\n##     b   10\n##     c   15\nm2 = make_comb_mat(lt, universal_set = letters)\ncomb_name(m2) # see the first element## [1] \"111\" \"110\" \"101\" \"011\" \"100\" \"010\" \"001\" \"000\"\ncomb_degree(m2)## 111 110 101 011 100 010 001 000 \n##   3   2   2   2   1   1   1   0\nm2 = make_comb_mat(lt, universal_set = letters)\nextract_comb(m2, \"000\")## [1] \"a\" \"b\" \"f\" \"p\" \"u\" \"z\"\nm2 = make_comb_mat(lt, universal_set = letters[1:10])\nextract_comb(m2, \"000\")## [1] \"a\" \"b\" \"f\"\nm[comb_degree(m) == 2]\n# by set names\nm[c(\"a\", \"b\", \"c\"), ]\n# by nummeric indicies\nm[3:1, ]\n# `d` is the new empty set\nm[c(\"a\", \"b\", \"c\", \"d\"), ]\n# if `c` is a non-empty set\nm[c(\"a\", \"b\"),]\n# reorder\nm[, 5:1]\n# take a subset\nm[, 1:3]\n# by charater indices\nm[, c(\"110\", \"101\", \"011\")]\nm[m, c(comb_name(m), \"100\")]\nm[3:1, 5:1]\n# this will throw an error because `c` is a non-empty set\nm[c(\"a\", \"b\"), 5:1]\ntm = t(m)\ntm[reverse(comb_name(tm)), reverse(set_name(tm))]\nm[1:5]\ntm[1:5]"},{"path":"upset-plot.html","id":"upset-making-the-plot","chapter":"8 UpSet plot","heading":"8.5 Make the plot","text":"Making UpSet plot straightforward users just send \ncombination matrix UpSet() function:default sets ordered size combination sets \nordered degree (number sets selected).order controlled set_order comb_order:Color dots, size dots line width segments controlled \npt_size, comb_col lwd. comb_col vector corresponding\ncombination sets. following code, since comb_degree(m) returns \nvector integers, just use index color vector.Colors background (rectangles dots representing set \nselected) controlled bg_col, bg_pt_col. length bg_col\ncan length one two.Transposing combination matrix swtiches sets columns \ncombination sets rows.introduced, subsetting combination sets, subset \nmatrix can visualized well:Following compares different mode make_comb_mat():plot containing complement set, one additional column showing\ncomplement set overlap sets (dots grey).Remember already know size complement set, can directly assign \ncomplement_size argument make_comb_mat().case universal set smaller union sets:cases may complement set don’t want show ,\nespecially input make_comb_mat() matrix already contains\ncomplement set, can filter combination degrees.","code":"\nm = make_comb_mat(lt)\nUpSet(m)\nUpSet(m, set_order = c(\"a\", \"b\", \"c\"), comb_order = order(comb_size(m)))\nUpSet(m, pt_size = unit(5, \"mm\"), lwd = 3,\n    comb_col = c(\"red\", \"blue\", \"black\")[comb_degree(m)])\nUpSet(m, comb_col = \"#0000FF\", bg_col = \"#F0F0FF\", bg_pt_col = \"#CCCCFF\")\nUpSet(m, comb_col = \"#0000FF\", bg_col = c(\"#F0F0FF\", \"#FFF0F0\"), bg_pt_col = \"#CCCCFF\")\nUpSet(t(m))\nUpSet(m[comb_size(m) >= 4])\nUpSet(m[comb_degree(m) == 2])\nm1 = make_comb_mat(lt) # the default mode is `distinct`\nm2 = make_comb_mat(lt, mode = \"intersect\")\nm3 = make_comb_mat(lt, mode = \"union\")\nUpSet(m1)\nUpSet(m2)\nUpSet(m3)\nm2 = make_comb_mat(lt, universal_set = letters)\nUpSet(m2)\nm2 = make_comb_mat(lt, complement_size = 10)\nUpSet(m2)\nm2 = make_comb_mat(lt, universal_set = letters[1:10])\nUpSet(m2)\nx = list_to_matrix(lt, universal_set = letters)\nm2 = make_comb_mat(x)\nm2 = m2[comb_degree(m2) > 0]\nUpSet(m2)"},{"path":"upset-plot.html","id":"upset-plots-as-heatmaps","chapter":"8 UpSet plot","heading":"8.6 UpSet plots as heatmaps","text":"UpSet plot, major component combination matrix, \ntwo sides barplots representing size sets combination\nsets, thus, quite straightforward implement “heatmap” \nheatmap self-defined dots segments, two barplots \ntwo barplot annotations constructed anno_barplot().default top annotation :top annotation wrapped upset_top_annotation() contais\nupset top barplot annotation. arguments \nupset_top_annotation() directly go anno_barplot(), e.g. set\ncolors bars:control data range axis:control annotation name:settings similar right annotation:upset_top_annotation() upset_right_annotation() can automatically\nrecognize whether sets rows columns.upset_top_annotation() upset_right_annotation() contain one\nbarplot annotation. users want add annotations, need \nmanually construct HeatmapAnnotation object multiple annotations.add annotations top:add annotation right:move right annotation left combination matrix, use upset_left_annotation():add numbers top bars:object returned UpSet() actually Heatmap class object, thus,\ncan add heatmaps annotations + %v%.Add multiple UpSet plots:first transpose combination matrices add horizontally:three combination matrices actually plotting three\ntimes redundant. functionality ComplexHeatmap package, \ncan directly add three barplot annotations.Similar combination matrix transposed:","code":"\nHeatmapAnnotation(\"Intersection\\nsize\" = anno_barplot(comb_size(m), \n        border = FALSE, gp = gpar(fill = \"black\"), height = unit(3, \"cm\")), \n    annotation_name_side = \"left\", annotation_name_rot = 0)\nUpSet(m, top_annotation = upset_top_annotation(m, \n    gp = gpar(col = comb_degree(m))))\nUpSet(m, top_annotation = upset_top_annotation(m, \n    ylim = c(0, 15),\n    bar_width = 1,\n    axis_param = list(side = \"right\", at = c(0, 5, 10, 15),\n        labels = c(\"zero\", \"five\", \"ten\", \"fifteen\"))))\nUpSet(m, top_annotation = upset_top_annotation(m, \n    annotation_name_rot = 90,\n    annotation_name_side = \"right\",\n    axis_param = list(side = \"right\")))\nUpSet(m, right_annotation = upset_right_annotation(m, \n    ylim = c(0, 30),\n    gp = gpar(fill = \"green\"),\n    annotation_name_side = \"top\",\n    axis_param = list(side = \"top\")))\nUpSet(m, top_annotation = HeatmapAnnotation(\n    degree = as.character(comb_degree(m)),\n    \"Intersection\\nsize\" = anno_barplot(comb_size(m), \n        border = FALSE, \n        gp = gpar(fill = \"black\"), \n        height = unit(2, \"cm\")\n    ), \n    annotation_name_side = \"left\", \n    annotation_name_rot = 0))\nUpSet(m, right_annotation = rowAnnotation(\n    \"Set size\" = anno_barplot(set_size(m), \n        border = FALSE, \n        gp = gpar(fill = \"black\"), \n        width = unit(2, \"cm\")\n    ),\n    group = c(\"group1\", \"group1\", \"group2\")))\nUpSet(m, left_annotation = upset_left_annotation(m))\nUpSet(m, top_annotation = upset_top_annotation(m, add_numbers = TRUE),\n    right_annotation = upset_right_annotation(m, add_numbers = TRUE))\nht = UpSet(m)\nclass(ht)## [1] \"Heatmap\"\n## attr(,\"package\")\n## [1] \"ComplexHeatmap\"\nht + Heatmap(1:3, name = \"foo\", width = unit(5, \"mm\")) + \n    rowAnnotation(bar = anno_points(1:3))\nht %v% Heatmap(rbind(1:7), name = \"foo\", row_names_side = \"left\", \n        height = unit(5, \"mm\")) %v% \n    HeatmapAnnotation(bar = anno_points(1:7),\n        annotation_name_side = \"left\")\nm1 = make_comb_mat(lt, mode = \"distinct\")\nm2 = make_comb_mat(lt, mode = \"intersect\")\nm3 = make_comb_mat(lt, mode = \"union\")\nUpSet(m1, row_title = \"distinct mode\") %v%\n    UpSet(m2, row_title = \"intersect mode\") %v%\n    UpSet(m3, row_title = \"union mode\")\nm1 = make_comb_mat(lt, mode = \"distinct\")\nm2 = make_comb_mat(lt, mode = \"intersect\")\nm3 = make_comb_mat(lt, mode = \"union\")\nUpSet(t(m1), column_title = \"distinct mode\") +\n    UpSet(t(m2), column_title = \"intersect mode\") +\n    UpSet(t(m3), column_title = \"union mode\")\ntop_ha = HeatmapAnnotation(\n    \"distict\" = anno_barplot(comb_size(m1), \n        gp = gpar(fill = \"black\"), height = unit(2, \"cm\")), \n    \"intersect\" = anno_barplot(comb_size(m2), \n        gp = gpar(fill = \"black\"), height = unit(2, \"cm\")), \n    \"union\" = anno_barplot(comb_size(m3), \n        gp = gpar(fill = \"black\"), height = unit(2, \"cm\")), \n    gap = unit(2, \"mm\"), annotation_name_side = \"left\", annotation_name_rot = 0)\n# the same for using m2 or m3\nUpSet(m1, top_annotation = top_ha)\nright_ha = rowAnnotation(\n    \"distict\" = anno_barplot(comb_size(m1), \n        gp = gpar(fill = \"black\"), width = unit(2, \"cm\")), \n    \"intersect\" = anno_barplot(comb_size(m2), \n        gp = gpar(fill = \"black\"), width = unit(2, \"cm\")), \n    \"union\" = anno_barplot(comb_size(m3), \n        gp = gpar(fill = \"black\"), width = unit(2, \"cm\")), \n    gap = unit(2, \"mm\"), annotation_name_side = \"bottom\")\n# the same for using m2 or m3\nUpSet(t(m1), right_annotation = right_ha)"},{"path":"upset-plot.html","id":"example-with-the-movies-dataset","chapter":"8 UpSet plot","heading":"8.7 Example with the movies dataset","text":"UpsetR package also provides movies\ndataset, contains 17 genres 3883 movies. First load dataset.make UpSet plot vignette:Following code makes look similar orignal plot. code \nlittle bit long, code mainly customize annotations \nrow/column orders.movies dataset, also one column AvgRating gives \nrating movie, next split movies five groups based \nratings.combination matrices m_list might different combination sets:compare multiple groups UpSet plots, need normalize \nmatrices make sets combination sets.\nnormalize_comb_mat() basically adds zero new combination sets \n.calculate range two barplots:finally add five UpSet plots vertically:comparing five UpSet plots, can see movies rated\n2 4. Horror movies tend lower ratings romance movies\ntend higher ratings.Instead directly comparing size combination sets, can also\ncompare relative fraction full sets. following code, remove\ngroup c(0, 1] number movies .Now trend clear horror movies rated low documentaries\nrated high.Next split movies years:Now can see movies produces 1990s two major\ngenres actions romance.Similarly, change top annotation relative fraction \nfull sets (code shown):Finally can add statistics years, ratings number watches \ncombination set boxplot annotations right UpSet plot.can see movies genre “Scifi + Children” produced quite old\nratings bad. movies genre “Action + Children” \nlowest ratings.","code":"\nmovies = read.csv(system.file(\"extdata\", \"movies.csv\", package = \"UpSetR\"), \n    header = TRUE, sep = \";\")\nhead(movies) # `make_comb_mat()` automatically ignores the first two columns##                                 Name ReleaseDate Action Adventure Children\n## 1                   Toy Story (1995)        1995      0         0        1\n## 2                     Jumanji (1995)        1995      0         1        1\n## 3            Grumpier Old Men (1995)        1995      0         0        0\n## 4           Waiting to Exhale (1995)        1995      0         0        0\n## 5 Father of the Bride Part II (1995)        1995      0         0        0\n## 6                        Heat (1995)        1995      1         0        0\n##   Comedy Crime Documentary Drama Fantasy Noir Horror Musical Mystery Romance\n## 1      1     0           0     0       0    0      0       0       0       0\n## 2      0     0           0     0       1    0      0       0       0       0\n## 3      1     0           0     0       0    0      0       0       0       1\n## 4      1     0           0     1       0    0      0       0       0       0\n## 5      1     0           0     0       0    0      0       0       0       0\n## 6      0     1           0     0       0    0      0       0       0       0\n##   SciFi Thriller War Western AvgRating Watches\n## 1     0        0   0       0      4.15    2077\n## 2     0        0   0       0      3.20     701\n## 3     0        0   0       0      3.02     478\n## 4     0        0   0       0      2.73     170\n## 5     0        0   0       0      3.01     296\n## 6     0        1   0       0      3.88     940\nm = make_comb_mat(movies, top_n_sets = 6)\nm## A combination matrix with 6 sets and 39 combinations.\n##   ranges of combination set size: c(1, 1028).\n##   mode for the combination size: distinct.\n##   sets are on rows.\n## \n## Top 8 combination sets are:\n##   Action Comedy Drama Horror Romance Thriller   code size\n##                     x                         001000 1028\n##               x                               010000  698\n##                            x                  000100  216\n##        x                                      100000  206\n##                                             x 000001  183\n##               x     x                         011000  180\n##               x                    x          010010  160\n##                     x              x          001010  158\n## \n## Sets are:\n##          set size\n##       Action  503\n##       Comedy 1200\n##        Drama 1603\n##       Horror  343\n##      Romance  471\n##     Thriller  492\n##   complement    2\nm = m[comb_degree(m) > 0]\nUpSet(m)\nss = set_size(m)\ncs = comb_size(m)\nht = UpSet(m, \n    set_order = order(ss),\n    comb_order = order(comb_degree(m), -cs),\n    top_annotation = HeatmapAnnotation(\n        \"Genre Intersections\" = anno_barplot(cs, \n            ylim = c(0, max(cs)*1.1),\n            border = FALSE, \n            gp = gpar(fill = \"black\"), \n            height = unit(4, \"cm\")\n        ), \n        annotation_name_side = \"left\", \n        annotation_name_rot = 90),\n    left_annotation = rowAnnotation(\n        \"Movies Per Genre\" = anno_barplot(-ss, \n            baseline = 0,\n            axis_param = list(\n                at = c(0, -500, -1000, -1500),\n                labels = c(0, 500, 1000, 1500),\n                labels_rot = 0),\n            border = FALSE, \n            gp = gpar(fill = \"black\"), \n            width = unit(4, \"cm\")\n        ),\n        set_name = anno_text(set_name(m), \n            location = 0.5, \n            just = \"center\",\n            width = max_text_width(set_name(m)) + unit(4, \"mm\"))\n    ), \n    right_annotation = NULL,\n    show_row_names = FALSE)\nht = draw(ht)\nod = column_order(ht)\ndecorate_annotation(\"Genre Intersections\", {\n    grid.text(cs[od], x = seq_along(cs), y = unit(cs[od], \"native\") + unit(2, \"pt\"), \n        default.units = \"native\", just = c(\"left\", \"bottom\"), \n        gp = gpar(fontsize = 6, col = \"#404040\"), rot = 45)\n})\ngenre = c(\"Action\", \"Romance\", \"Horror\", \"Children\", \"SciFi\", \"Documentary\")\nrating = cut(movies$AvgRating, c(0, 1, 2, 3, 4, 5))\nm_list = tapply(seq_len(nrow(movies)), rating, function(ind) {\n    m = make_comb_mat(movies[ind, genre, drop = FALSE])\n    m[comb_degree(m) > 0]\n})\nsapply(m_list, comb_size)## $`(0,1]`\n## 010000 001000 000100 000001 \n##      1      2      1      1 \n## \n## $`(1,2]`\n## 101010 100110 110000 101000 100100 100010 001010 100000 010000 001000 000100 \n##      1      1      1      4      5      5      8     14      7     38     14 \n## 000010 000001 \n##      3      2 \n## \n## $`(2,3]`\n## 101010 110000 101000 100100 100010 010100 010010 001010 000110 100000 010000 \n##      4      8      2      6     35      3      1     27      7    126     99 \n## 001000 000100 000010 000001 \n##    142     77     27      9 \n## \n## $`(3,4]`\n## 110010 101010 100110 110000 101000 100010 011000 010100 010010 001100 001010 \n##      1      6      1     20      6     45      3      4      4      1     11 \n## 000110 100000 010000 001000 000100 000010 000001 \n##      5    176    276     82    122     66     87 \n## \n## $`(4,5]`\n## 110010 101010 110000 101000 100010 100000 010000 001000 000100 000010 000001 \n##      1      1      4      1      6     23     38      4      4     10     28\nm_list = normalize_comb_mat(m_list)\nsapply(m_list, comb_size)##        (0,1] (1,2] (2,3] (3,4] (4,5]\n## 110001     0     1     0     1     0\n## 100101     0     1     4     6     1\n## 100011     0     0     0     1     1\n## 110000     0     5     6     0     0\n## 100100     0     4     2     6     1\n## 100010     0     1     8    20     4\n## 100001     0     5    35    45     6\n## 010100     0     0     0     1     0\n## 010010     0     0     3     4     0\n## 010001     0     0     7     5     0\n## 000110     0     0     0     3     0\n## 000101     0     8    27    11     0\n## 000011     0     0     1     4     0\n## 100000     0    14   126   176    23\n## 010000     1    14    77   122     4\n## 001000     1     2     9    87    28\n## 000100     2    38   142    82     4\n## 000010     1     7    99   276    38\n## 000001     0     3    27    66    10\nmax_set_size = max(sapply(m_list, set_size))\nmax_comb_size = max(sapply(m_list, comb_size))\nht_list = NULL\nfor(i in seq_along(m_list)) {\n    ht_list = ht_list %v%\n        UpSet(m_list[[i]], row_title = paste0(\"rating in\", names(m_list)[i]),\n            set_order = NULL, comb_order = NULL,\n            top_annotation = upset_top_annotation(m_list[[i]], ylim = c(0, max_comb_size)),\n            right_annotation = upset_right_annotation(m_list[[i]], ylim = c(0, max_set_size)))\n}\nht_list\nm_list = m_list[-1]\nmax_set_size = max(sapply(m_list, set_size))\nrel_comb_size = sapply(m_list, function(m) {\n    s = comb_size(m)\n    # because the combination matrix is generated under \"distinct\" mode\n    # the sum of `s` is the size of the full set\n    s/sum(s)\n})\nht_list = NULL\nfor(i in seq_along(m_list)) {\n    ht_list = ht_list %v%\n        UpSet(m_list[[i]], row_title = paste0(\"rating in\", names(m_list)[i]),\n            set_order = NULL, comb_order = NULL,\n            top_annotation = HeatmapAnnotation(\n                \"Relative\\nfraction\" = anno_barplot(\n                    rel_comb_size[, i],\n                    ylim = c(0, 0.5),\n                    gp = gpar(fill = \"black\"),\n                    border = FALSE,\n                    height = unit(2, \"cm\"),\n                ), \n                annotation_name_side = \"left\",\n                annotation_name_rot = 0),\n            right_annotation = upset_right_annotation(m_list[[i]], \n                ylim = c(0, max_set_size))\n        )\n}\nht_list\nyear = floor(movies$ReleaseDate/10)*10\nm_list = tapply(seq_len(nrow(movies)), year, function(ind) {\n    m = make_comb_mat(movies[ind, genre, drop = FALSE])\n    m[comb_degree(m) > 0]\n})\nm_list = normalize_comb_mat(m_list)\nmax_set_size = max(sapply(m_list, set_size))\nmax_comb_size = max(sapply(m_list, comb_size))\nht_list1 = NULL\nfor(i in 1:5) {\n    ht_list1 = ht_list1 %v%\n        UpSet(m_list[[i]], row_title = paste0(names(m_list)[i], \"s\"),\n            set_order = NULL, comb_order = NULL,\n            top_annotation = upset_top_annotation(m_list[[i]], ylim = c(0, max_comb_size),\n                height = unit(2, \"cm\")),\n            right_annotation = upset_right_annotation(m_list[[i]], ylim = c(0, max_set_size)))\n}\n\nht_list2 = NULL\nfor(i in 6:10) {\n    ht_list2 = ht_list2 %v%\n        UpSet(m_list[[i]], row_title = paste0(names(m_list)[i], \"s\"),\n            set_order = NULL, comb_order = NULL,\n            top_annotation = upset_top_annotation(m_list[[i]], ylim = c(0, max_comb_size),\n                height = unit(2, \"cm\")),\n            right_annotation = upset_right_annotation(m_list[[i]], ylim = c(0, max_set_size)))\n}\ngrid.newpage()\npushViewport(viewport(x = 0, width = 0.5, just = \"left\"))\ndraw(ht_list1, newpage = FALSE)\npopViewport()\npushViewport(viewport(x = 0.5, width = 0.5, just = \"left\"))\ndraw(ht_list2, newpage = FALSE)\npopViewport()\nm = make_comb_mat(movies[, genre])\nm = m[comb_degree(m) > 0]\ncomb_elements = lapply(comb_name(m), function(nm) extract_comb(m, nm))\nyears = lapply(comb_elements, function(ind) movies$ReleaseDate[ind])\nrating = lapply(comb_elements, function(ind) movies$AvgRating[ind])\nwatches = lapply(comb_elements, function(ind) movies$Watches[ind])\n\nUpSet(t(m)) + rowAnnotation(years = anno_boxplot(years),\n    rating = anno_boxplot(rating),\n    watches = anno_boxplot(watches),\n    gap = unit(2, \"mm\"))"},{"path":"upset-plot.html","id":"example-with-the-genomic-regions","chapter":"8 UpSet plot","heading":"8.8 Example with the genomic regions","text":"H3K4me3 ChIP-seq peaks six Roadmap samples \nvisualized UpSet plot. six samples :ESC, E016ES-derived, E004ES-derived, E006Brain, E071Muscle, E100Heart, E104First read files convert GRanges objects.Make combination matrix. Note now size sets combination\nsets total base pairs sum width regions. keep\ncombination sets 500kb.can nicely format axis labels setting axis_param:set genomic regions, can associate information ,\nmean methylation distance nearest TSS.","code":"\nfile_list = c(\n    \"ESC\" = \"data/E016-H3K4me3.narrowPeak.gz\",\n    \"ES-deriv1\" = \"data/E004-H3K4me3.narrowPeak.gz\",\n    \"ES-deriv2\" = \"data/E006-H3K4me3.narrowPeak.gz\",\n    \"Brain\" = \"data/E071-H3K4me3.narrowPeak.gz\",\n    \"Muscle\" = \"data/E100-H3K4me3.narrowPeak.gz\",\n    \"Heart\" = \"data/E104-H3K4me3.narrowPeak.gz\"\n)\nlibrary(GenomicRanges)\npeak_list = lapply(file_list, function(f) {\n    df = read.table(f)\n    GRanges(seqnames = df[, 1], ranges = IRanges(df[, 2], df [, 3]))\n})\nm = make_comb_mat(peak_list)\nm = m[comb_size(m) > 500000]\nUpSet(m)\nUpSet(m, \n    top_annotation = upset_top_annotation(\n        m,\n        axis_param = list(at = c(0, 1e7, 2e7),\n            labels = c(\"0Mb\", \"10Mb\", \"20Mb\")),\n        height = unit(4, \"cm\")\n    ),\n    right_annotation = upset_right_annotation(\n        m,\n        axis_param = list(at = c(0, 2e7, 4e7, 6e7),\n            labels = c(\"0Mb\", \"20Mb\", \"40Mb\", \"60Mb\"),\n            labels_rot = 0),\n        width = unit(4, \"cm\")\n    ))\nsubgroup = c(\"ESC\" = \"group1\",\n    \"ES-deriv1\" = \"group1\",\n    \"ES-deriv2\" = \"group1\",\n    \"Brain\" = \"group2\",\n    \"Muscle\" = \"group2\",\n    \"Heart\" = \"group2\"\n)\ncomb_sets = lapply(comb_name(m), function(nm) extract_comb(m, nm))\ncomb_sets = lapply(comb_sets, function(gr) {\n    # we just randomly generate dist_to_tss and mean_meth\n    gr$dist_to_tss = abs(rnorm(length(gr), mean = runif(1, min = 500, max = 2000), sd = 1000))\n    gr$mean_meth = abs(rnorm(length(gr), mean = 0.1, sd = 0.1))\n    gr\n})\nUpSet(m, \n    top_annotation = upset_top_annotation(\n        m,\n        axis_param = list(at = c(0, 1e7, 2e7),\n            labels = c(\"0Mb\", \"10Mb\", \"20Mb\")),\n        height = unit(4, \"cm\")\n    ),\n    right_annotation = upset_right_annotation(\n        m,\n        axis_param = list(at = c(0, 2e7, 4e7, 6e7),\n            labels = c(\"0Mb\", \"20Mb\", \"40Mb\", \"60Mb\"),\n            labels_rot = 0),\n        width = unit(4, \"cm\")\n    ),\n    left_annotation = rowAnnotation(group = subgroup[set_name(m)], show_annotation_name = FALSE),\n    bottom_annotation = HeatmapAnnotation(\n        dist_to_tss = anno_boxplot(lapply(comb_sets, function(gr) gr$dist_to_tss), outline = FALSE),\n        mean_meth = sapply(comb_sets, function(gr) mean(gr$mean_meth)),\n        annotation_name_side = \"left\"\n    )\n)"},{"path":"interactive.html","id":"interactive","chapter":"9 Interactive ComplexHeatmap","heading":"9 Interactive ComplexHeatmap","text":"Please check InteractiveComplexHeatmap package.","code":""},{"path":"integrate-with-other-packages.html","id":"integrate-with-other-packages","chapter":"10 Integrate with other packages","heading":"10 Integrate with other packages","text":"","code":""},{"path":"integrate-with-other-packages.html","id":"pheatmap","chapter":"10 Integrate with other packages","heading":"10.1 pheatmap","text":"pheatmap great R package making heatmaps, inspiring lot \nheatmap packages ComplexHeatmap. version 2.5.2 \nComplexHeatmap, implemented new ComplexHeatmap::pheatmap() function\nactually maps parameters pheatmap::pheatmap() proper\nparameters ComplexHeatmap::Heatmap(), means, converts pheatmap\ncomplex heatmap. , significant improvement now \ncan add multiple pheatmaps annotations (defined \nComplexHeatmap::rowAnnotation()).ComplexHeatmap::pheatmap() includes arguments pheatmap::pheatmap(),\nmeans, don’t need adaptation pheatmap code, just\nrerun pheatmap code automatically nicely convert \ncomplex heatmap.arguments pheatmap::pheatmap() disabled ignored translation,\nlisted follows:kmeans_kfilenamewidthheightsilentThe usage remaining arguments exactly pheatmap::pheatmap().pheatmap::pheatmap(), color argument specified long color vector,\ne.g. :can use setting color ComplexHeatmap::pheatmap(), \ncan also simplify :colors individual values automatically interpolated.","code":"\npheatmap::pheatmap(mat, \n    color = colorRampPalette(rev(brewer.pal(n = 7, name = \"RdYlBu\")))(100)\n)\nComplexHeatmap::pheatmap(mat, \n    color = rev(brewer.pal(n = 7, name = \"RdYlBu\"))\n)"},{"path":"integrate-with-other-packages.html","id":"examples","chapter":"10 Integrate with other packages","heading":"10.1.1 Examples","text":"First load example dataset “Examples” section \ndocumentation pheatmap::pheatmap() function .Calling pheatmap() (now actually ComplexHeatmap::pheatmap()) generates\nsimilar heatmap pheatmap::pheatmap().Everything looks except style heatmap legend. also\nvisual difference can find “Comparisons” section post.next one example setting annotations (familiar \nset data frames color list pheatmap user).ComplexHeatmap::pheatmap() returns Heatmap object, can added \nheatmaps annotations. words, can add multiple pheatmaps\nannotations. Cool!Nevertheless, really want add multiple pheatmaps, still suggest \ndirectly use Heatmap() function. can find migrate \npheatmap::pheatmap() ComplexHeatmap::Heatmap() next section.previous examples, legend row annotation grouped heatmap legend.\ncan modified setting legend_grouping argument draw() function:One last thing since ComplexHeatmap::pheatmap() returns Heatmap object,\npheatmap() called interactive environment, e.g. R script,\ninside function loop, need explicitly use draw() function:","code":"\nlibrary(ComplexHeatmap)\ntest = matrix(rnorm(200), 20, 10)\ntest[1:10, seq(1, 10, 2)] = test[1:10, seq(1, 10, 2)] + 3\ntest[11:20, seq(2, 10, 2)] = test[11:20, seq(2, 10, 2)] + 2\ntest[15:20, seq(2, 10, 2)] = test[15:20, seq(2, 10, 2)] + 4\ncolnames(test) = paste(\"Test\", 1:10, sep = \"\")\nrownames(test) = paste(\"Gene\", 1:20, sep = \"\")\npheatmap(test)  # this is ComplexHeatmap::pheatmap\nannotation_col = data.frame(\n    CellType = factor(rep(c(\"CT1\", \"CT2\"), 5)), \n    Time = 1:5\n)\nrownames(annotation_col) = paste(\"Test\", 1:10, sep = \"\")\n\nannotation_row = data.frame(\n    GeneClass = factor(rep(c(\"Path1\", \"Path2\", \"Path3\"), c(10, 4, 6)))\n)\nrownames(annotation_row) = paste(\"Gene\", 1:20, sep = \"\")\n\nann_colors = list(\n    Time = c(\"white\", \"firebrick\"),\n    CellType = c(CT1 = \"#1B9E77\", CT2 = \"#D95F02\"),\n    GeneClass = c(Path1 = \"#7570B3\", Path2 = \"#E7298A\", Path3 = \"#66A61E\")\n)\npheatmap(test, annotation_col = annotation_col, annotation_row = annotation_row, \n    annotation_colors = ann_colors)\np1 = pheatmap(test, name = \"mat1\")\np2 = rowAnnotation(foo = anno_barplot(1:nrow(test)))\np3 = pheatmap(test, name = \"mat2\", \n    col = colorRampPalette(c(\"navy\", \"white\", \"firebrick3\"))(50))\n# or you can simply specify as\n# p3 = pheatmap(test, name = \"mat2\", col = c(\"navy\", \"white\", \"firebrick3\"))\np1 + p2 + p3\np = pheatmap(test, annotation_col = annotation_col, annotation_row = annotation_row, \n    annotation_colors = ann_colors)\ndraw(p, legend_grouping = \"original\")for(...) {\n    p = pheatmap(...)\n    draw(p)\n}"},{"path":"integrate-with-other-packages.html","id":"translation","chapter":"10 Integrate with other packages","heading":"10.1.2 Translation","text":"Following table lists map parameters pheatmap::pheatmap() ComplexHeatmap::Heatmap().","code":""},{"path":"integrate-with-other-packages.html","id":"comparisons","chapter":"10 Integrate with other packages","heading":"10.1.3 Comparisons","text":"ran example code “Examples” section documentation \npheatmap::pheatmap() function .\nalso implemented wrapper function ComplexHeatmap::compare_pheatmap() basically uses \nset arguments pheatmap::pheatmap() ComplexHeatmap::pheatmap() \ndraws two heatmaps, can directly see similarity difference\ntwo heatmap implementations.","code":"\ncompare_pheatmap(test)\ncompare_pheatmap(test, scale = \"row\", clustering_distance_rows = \"correlation\")\ncompare_pheatmap(test, \n    color = colorRampPalette(c(\"navy\", \"white\", \"firebrick3\"))(50))\ncompare_pheatmap(test, cluster_row = FALSE)\ncompare_pheatmap(test, legend = FALSE)\ncompare_pheatmap(test, display_numbers = TRUE)\ncompare_pheatmap(test, display_numbers = TRUE, number_format = \"%.1e\")\ncompare_pheatmap(test, \n    display_numbers = matrix(ifelse(test > 5, \"*\", \"\"), nrow(test)))\ncompare_pheatmap(test, cluster_row = FALSE, legend_breaks = -1:4, \n    legend_labels = c(\"0\", \"1e-4\", \"1e-3\", \"1e-2\", \"1e-1\", \"1\"))\ncompare_pheatmap(test, cellwidth = 15, cellheight = 12, main = \"Example heatmap\")\nannotation_col = data.frame(\n    CellType = factor(rep(c(\"CT1\", \"CT2\"), 5)), \n    Time = 1:5\n)\nrownames(annotation_col) = paste(\"Test\", 1:10, sep = \"\")\n\nannotation_row = data.frame(\n    GeneClass = factor(rep(c(\"Path1\", \"Path2\", \"Path3\"), c(10, 4, 6)))\n)\nrownames(annotation_row) = paste(\"Gene\", 1:20, sep = \"\")\n\ncompare_pheatmap(test, annotation_col = annotation_col)\ncompare_pheatmap(test, annotation_col = annotation_col, annotation_legend = FALSE)\ncompare_pheatmap(test, annotation_col = annotation_col, \n    annotation_row = annotation_row)\ncompare_pheatmap(test, annotation_col = annotation_col, \n    annotation_row = annotation_row, angle_col = \"45\")\ncompare_pheatmap(test, annotation_col = annotation_col, angle_col = \"0\")\nann_colors = list(\n    Time = c(\"white\", \"firebrick\"),\n    CellType = c(CT1 = \"#1B9E77\", CT2 = \"#D95F02\"),\n    GeneClass = c(Path1 = \"#7570B3\", Path2 = \"#E7298A\", Path3 = \"#66A61E\")\n)\n\ncompare_pheatmap(test, annotation_col = annotation_col, \n    annotation_colors = ann_colors, main = \"Title\")\ncompare_pheatmap(test, annotation_col = annotation_col, \n    annotation_row = annotation_row, annotation_colors = ann_colors)\ncompare_pheatmap(test, annotation_col = annotation_col, \n    annotation_colors = ann_colors[2]) \ncompare_pheatmap(test, annotation_col = annotation_col, cluster_rows = FALSE, \n    gaps_row = c(10, 14))\ncompare_pheatmap(test, annotation_col = annotation_col, cluster_rows = FALSE, \n    gaps_row = c(10, 14), cutree_col = 2)\nlabels_row = c(\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \n    \"\", \"\", \"Il10\", \"Il15\", \"Il1b\")\ncompare_pheatmap(test, annotation_col = annotation_col, labels_row = labels_row)\ndrows = dist(test, method = \"minkowski\")\ndcols = dist(t(test), method = \"minkowski\")\ncompare_pheatmap(test, clustering_distance_rows = drows, \n    clustering_distance_cols = dcols)\nlibrary(dendsort)\ncallback = function(hc, ...){dendsort(hc)}\ncompare_pheatmap(test, clustering_callback = callback)"},{"path":"integrate-with-other-packages.html","id":"cowplot","chapter":"10 Integrate with other packages","heading":"10.2 cowplot","text":"cowplot package used\ncombine multiple plots single figure. cases,\nComplexHeatmap works perfectly cowplot, cases need\nspecial attention.Also packages combine multiple plots, \nmultipanelfigure,\nthink mechanism behind .Following functionalities ComplexHeatmap cause problems using cowplot.anno_zoom()/anno_link(): adjusted positions two functions rely size graphics\ndevice.anno_mark(): reason anno_zoom(). adjusted positions also rely device size.many legends, legends wrapped multiple columns. calculation\nlegend positions rely device size.following demonstrate case using anno_zoom(). \nexample simplifyEnrichment\npackage plot shows \nGO similarity heatmap word cloud annotation showing major biological\nfunctions group.don’t need really understand following code. ht_clusters()\nfunction basically draws heatmap Heatmap() add word cloud\nannotation anno_zoom().Next put heatmap sub-figure cowplot. integrate \ncowplot, heatmap captured grid::grid.grabExpr() complex\ngrob object. Note need use draw() function draw heatmap\nexplicitly.Woooo! word cloud annotation badly aligned.details noted grid.grabExpr() function. actually\nopens invisible graphics device (pdf(NULL)) default size 7x7 inches. Thus,\nline:word cloud annotation p2 actually calculated region 7x7\ninches, written back figure plot_grid(), space\np2 changes, word cloud annotation wrongly aligned.hand, “simple heatmap” captured grid.grabExpr(), e.g.:p2 put back, everything work fine now heatmap\nelements dependent device size positions \nautomatically adjusted new space.effect can also observed plotting heatmap interactive\ngraphics device resizing window dragging .solution rather simple. Since reason inconsistency \ndifferent space captured drawn, \nneed capture heatmap device size \ngoing put.layout set plot_grid() function, heatmap occupies\n9/10 width 4/5 height figure. , width height space\nheatmap calculated follows assigned width \nheight arguments grid.grabExpr().Now everthing back normal!","code":"\nlibrary(simplifyEnrichment)\nset.seed(1234)\ngo_id = random_GO(500)\nmat = GO_similarity(go_id)\ncl = binary_cut(mat)\nht_clusters(mat, cl)\nlibrary(cowplot)\nlibrary(grid)\np1 = rectGrob(width = 0.9, height = 0.9)\np2 = grid.grabExpr(ht_clusters(mat, cl))\np3 = rectGrob(width = 0.9, height = 0.9)\n\nplot_grid(p1, \n    plot_grid(p2, p3, nrow = 2, rel_heights = c(4, 1)), \n    nrow = 1, rel_widths = c(1, 9)\n)\np2 = grid.grabExpr(ht_clusters(mat, cl))\np2 = grid.grabExpr(draw(Heatmap(mat)))\nw = convertWidth(unit(1, \"npc\")*(9/10), \"inch\", valueOnly = TRUE)\nh = convertHeight(unit(1, \"npc\")*(4/5), \"inch\", valueOnly = TRUE)\np2 = grid.grabExpr(ht_clusters(mat, cl), width = w, height = h)\n\nplot_grid(p1, \n    plot_grid(p2, p3, nrow = 2, rel_heights = c(4, 1)), \n    nrow = 1, rel_widths = c(1, 9)\n)"},{"path":"integrate-with-other-packages.html","id":"gridtext","chapter":"10 Integrate with other packages","heading":"10.3 gridtext","text":"gridtext package provides nice easy way\nrendering text grid system. version 2.3.3 ComplexHeatmap, text-related\nelements can rendered gridtext.text-related elements, text needs wrapped gt_render() function, marks\ntext adds related parameters going processed gridtext.Currently ComplexHeatmap supports gridtext::richtext_grob(), parameters \nrichtext_grob() can passed via gt_render().heatmap element, e.g. column title, graphic parameters can set companion argument,\ne.g. column_title_gp. make simpler, graphic parameters set box_gp merged *_gp\nadding box_ prefix, e.g.:Graphic parameters can also specified inside gt_render(). Following one :","code":"\ngt_render(\"foo\", r = unit(2, \"pt\"), padding = unit(c(2, 2, 2, 2), \"pt\"))## [1] \"foo\"\n## attr(,\"class\")\n## [1] \"gridtext\"\n## attr(,\"param\")\n## attr(,\"param\")$r\n## [1] 2points\n## \n## attr(,\"param\")$padding\n## [1] 2points 2points 2points 2points..., column_title = gt_render(\"foo\"), column_title_gp = gpar(col = \"red\", box_fill = \"blue\"), ......, column_title = gt_render(\"foo\", gp = gpar(col = \"red\", box_fill = \"blue\")), ..."},{"path":"integrate-with-other-packages.html","id":"gridtext-title","chapter":"10 Integrate with other packages","heading":"10.3.1 Titles","text":"heatmap split:","code":"\nset.seed(123)\nmat = matrix(rnorm(100), 10)\nrownames(mat) = letters[1:10]\nHeatmap(mat, \n    column_title = gt_render(\"Some <span style='color:blue'>blue text **in bold.**<\/span><br>And *italics text.*<br>And some <span style='font-size:18pt; color:black'>large<\/span> text.\", \n        r = unit(2, \"pt\"), \n        padding = unit(c(2, 2, 2, 2), \"pt\")),\n    column_title_gp = gpar(box_fill = \"orange\"))\nHeatmap(mat, \n    row_km = 2, \n    row_title = gt_render(c(\"**title1**\", \"_title2_\")), \n    row_title_gp = gpar(box_fill = c(\"yellow\", \"blue\")))"},{"path":"integrate-with-other-packages.html","id":"gridtext-dimnames","chapter":"10 Integrate with other packages","heading":"10.3.2 Row/column names","text":"Rendered row/column names explicitly specified row_labels/column_labels","code":"\nHeatmap(mat, \n    row_labels = gt_render(letters[1:10], padding = unit(c(2, 10, 2, 10), \"pt\")),\n    row_names_gp = gpar(box_col = rep(c(\"red\", \"green\"), times = 5)))"},{"path":"integrate-with-other-packages.html","id":"gridtext-annotations","chapter":"10 Integrate with other packages","heading":"10.3.3 Annotation labels","text":"annotation_label argument rendered text.","code":"\nha = HeatmapAnnotation(foo = letters[1:10],\n    annotation_label = gt_render(\"**Annotation** _one_\",\n        gp = gpar(box_col = \"black\")),\n    show_legend = FALSE)\nHeatmap(mat, top_annotation = ha)"},{"path":"integrate-with-other-packages.html","id":"gridtext-anno-text","chapter":"10 Integrate with other packages","heading":"10.3.4 Text annotation","text":"","code":"\nrowAnnotation(\n    foo = anno_text(gt_render(sapply(LETTERS[1:10], strrep, 10), align_widths = TRUE), \n                    gp = gpar(box_col = \"blue\", box_lwd = 2), \n                    just = \"right\", \n                    location = unit(1, \"npc\")\n    )) + Heatmap(mat)"},{"path":"integrate-with-other-packages.html","id":"gridtext-legends","chapter":"10 Integrate with other packages","heading":"10.3.5 Legend","text":"","code":"\nHeatmap(mat, \n    heatmap_legend_param = list(\n        title = gt_render(\"<span style='color:orange'>**Legend title**<\/span>\"), \n        title_gp = gpar(box_fill = \"grey\"),\n        at = c(-3, 0, 3), \n        labels = gt_render(c(\"*negative* three\", \"zero\", \"*positive* three\"))\n    ))"},{"path":"other-high-level-plots.html","id":"other-high-level-plots","chapter":"11 Other High-level Plots","heading":"11 Other High-level Plots","text":"","code":""},{"path":"other-high-level-plots.html","id":"density-heatmap","chapter":"11 Other High-level Plots","heading":"11.1 Density heatmap","text":"visualize data distribution matrix list, normally use\nboxplot violin plot. can also use colors map density values \nvisualize distribution heatmap. useful huge number\ncolumns data visualize.following examples, use matrix input data density \ncalculated columns. input data can also list.heatmap, also lines representing five quantiles mean\nvalues.Data range controlled ylim. Title controlled title \ncolumn_title. Title y-axis controlled ylab.Column order controlled column_order.color density values controlled col vector \ncolors.Internally, density columns stored matrix rows\ncorrespond bins. Since matrix, clustering can applied\n. special distance method ks measuring similarity\ndistributions Kolmogorov-Smirnov statistic two\ndistributions (ks distance default cluster_column = TRUE).many distributions calculate pairwise Kolmogorov-Smirnov distance,\nmc.cores argument can set make running parallelly.Column annotations can added top annotation bottom annotation.Heatmaps column annotations can concatenated density\nheatmap vertically.also function frequencyHeatmap() like histogram-version\ndensity heatmap. usage similar densityHeatmap():","code":"\nset.seed(123)\nm = cbind(matrix(rnorm(10*100), ncol = 10),\n          matrix(runif(10*100, min = -2, max = 2) + 0.5, ncol = 10))\ncolnames(m) = paste0(\"C\", 1:ncol(m))\ndensityHeatmap(m)\ndensityHeatmap(m, ylim = c(-2, 2), title = \"Distribution as heatmap\", ylab = \"some values\")\ndensityHeatmap(m, column_order = sample(20, 20))\ndensityHeatmap(m, col = topo.colors(10))\ndensityHeatmap(m, cluster_columns = TRUE, clustering_distance_columns = \"ks\")\ndensityHeatmap(m, cluster_columns = TRUE, mc.cores = ...)\nha1 = HeatmapAnnotation(dist = c(rep(\"rnorm\", 10), rep(\"runif\", 10)))\nha2 = HeatmapAnnotation(foo = anno_points(rnorm(20)))\ndensityHeatmap(m, top_annotation = ha1, bottom_annotation = ha2)\ndensityHeatmap(m) %v%\nHeatmapAnnotation(foo = anno_barplot(1:20)) %v%\nHeatmap(matrix(rnorm(20*20), ncol = 20), name = \"mat\", height = unit(6, \"cm\"))\nfrequencyHeatmap(m)"},{"path":"other-high-level-plots.html","id":"stacked-summary-plot","chapter":"11 Other High-level Plots","heading":"11.2 Stacked summary plot","text":"Multiple annotations heatmaps can used visualize multiple summary statistics \nset features. following example, multiple statistics differential methylated\nregions (DMRs) four different subgroups.statistics DMRs :label: labels sets DMRs. DMRs four subgroups\nsubgroup, DMRs separated hyper-methylated DMRs \nhypo-methylated DMRs.mean_meth: mean methylation DMRs tumor samples normal\nsamples.n_gr Number DMRs set.n_corr: Percent DMRs show significant correlation nearby genes.\npositive correlation negative correlation calculated\nseparatedly.dist_tss: Distance nearby gene TSS. value proportion DMRs \ncurrent set distance less 1kb, 1kb 5kb, \n5kb 10kb 10kb.gene_anno: proportion DMRs overlap genes intergenic\nregions.cgi_anno: proportion DMRs overlap CpG islands CGI\nshores.mat_enrich_gf: enrichment list genomic features. Positive\nvalues mean representation.mat_pct_st: proprotion DMRs overlap chromatin states.mat_enrich_st: enrichment chromatin states.Attach variables working environment.Since many statistics visualize, first define colors. \ndefine color mapping functions statistics want visualize\nheatmaps color vectors want visualize barplots.construction heatmap list straightforward. statistic \nconstructed heatmap row annotation.Since annotation barplots generate legends, manually construct legends\nLegend() function.drawing heatmap list, rows heatmaps annotations split two major\ngroups. Note first Heatmap() corresponds mean methylation matrix, set\nrow_title = NULL remove row titles row splitting.Since later add titles annotations, allocate white space top whole\nplotting region padding argument. Also concatenate self-defined legend list \nheatmap legend list put horizontally bottom heatmap list.Similarlly, multiple statistics can also arranged vertically.\nfollowing example, visualize several statistics list genomic regions 40 samples,\nfour subgroups. statistics :prop: proportion genome.median_length: median length regions sample.group: subgroup labels.Note following example, heatmap list.concatenation multiple annotations, individual annotations can also put one single\nHeatmapAnnotation(). E.g. previous code almost exactly following code:","code":"\nlt = readRDS(system.file(\"extdata\", package = \"ComplexHeatmap\", \"dmr_summary.rds\"))\nnames(lt)##  [1] \"label\"         \"mean_meth\"     \"n_gr\"          \"n_corr\"       \n##  [5] \"dist_tss\"      \"gene_anno\"     \"cgi_anno\"      \"mat_enrich_gf\"\n##  [9] \"mat_pct_st\"    \"mat_enrich_st\"\nattach(lt)\nlibrary(circlize)\nmeth_col_fun = colorRamp2(c(0, 0.5, 1), c(\"blue\", \"white\", \"red\"))\ncorr_col = c(\"green\", \"red\")\ndist_tss_col = c(\"#FF0000\", \"#FF7352\", \"#FFB299\", \"#FFD9CB\")\ngene_anno_col = c(\"green\", \"blue\")\ncgi_anno_col = c(\"#FFA500\", \"#FFD191\")\nz_score_col_fun = colorRamp2(c(-200, 0, 200), c(\"green\", \"white\", \"red\"))\nstate_col = c(\"#FF0000\", \"#008000\", \"#C2E105\", \"#8A91D0\", \"#CD5C5C\", \"#808080\", \"#000000\")\nanno_width = unit(3, \"cm\")\nht_list = rowAnnotation(text = anno_text(label, location = unit(1, \"npc\"), just = \"right\", \n    gp = gpar(fontsize = 12)))\n\nht_list = ht_list + Heatmap(mean_meth, name = \"mean_meth\", col = meth_col_fun, \n    cluster_rows = FALSE, row_title = NULL, cluster_columns = FALSE, show_row_names = FALSE,\n    heatmap_legend_param = list(title = \"Methylation\"), width = ncol(mean_meth)*unit(4, \"mm\")) +\nrowAnnotation(\"n_gr\" = anno_barplot(n_gr, bar_width = 1, width = anno_width), \n    show_annotation_name = FALSE) +\nrowAnnotation(\"n_corr\" = anno_barplot(n_corr, bar_width = 1, gp = gpar(fill = corr_col), \n    width = anno_width), show_annotation_name = FALSE) +\nrowAnnotation(\"dist_tss\" = anno_barplot(dist_tss, bar_width = 1, gp = gpar(fill = dist_tss_col), \n    width = anno_width), show_annotation_name = FALSE) +\nrowAnnotation(\"gene_anno\" = anno_barplot(gene_anno, bar_width = 1, gp = gpar(fill = gene_anno_col), \n    width = anno_width), show_annotation_name = FALSE) +\nrowAnnotation(\"cgi_anno\" = anno_barplot(cgi_anno, bar_width = 1, gp = gpar(fill = cgi_anno_col), \n    width = anno_width), show_annotation_name = FALSE) +\nHeatmap(mat_enrich_gf, name = \"enrich_gf\", col = z_score_col_fun, cluster_columns = FALSE,\n    width = unit(ncol(mat_enrich_gf)*4, \"mm\"), column_title = \"\",\n    heatmap_legend_param = list(title = \"Z-score\")) +\nrowAnnotation(\"pct_st\" = anno_barplot(mat_pct_st, bar_width = 1, gp = gpar(fill = state_col), \n    width = anno_width), show_annotation_name = FALSE) +\nHeatmap(mat_enrich_st, name = \"enrich_st\", col = z_score_col_fun, cluster_columns = FALSE, \n    width = unit(ncol(mat_enrich_st)*6, \"mm\"), column_title = \"\", show_heatmap_legend = FALSE,\n    column_names_gp = gpar(col = state_col), show_row_names = FALSE)\nlgd_list = list(\n    Legend(labels = c(\"gene\", \"intergenic\"), title = \"Gene annotation\", \n        legend_gp = gpar(fill = gene_anno_col)),\n    Legend(labels = c(\"<1kb\", \"1kb~5kb\", \"5kb~10kb\", \">10kb\"), title = \"Distance to TSS\", \n        legend_gp = gpar(fill = dist_tss_col)),\n    Legend(labels = c(\"CGI\", \"CGI shore\"), title = \"CGI annotation\", \n        legend_gp = gpar(fill = cgi_anno_col)),\n    Legend(labels = colnames(mat_enrich_st), title = \"Chromatin states\", \n        legend_gp = gpar(fill = state_col))\n)\ndraw(ht_list, padding = unit(c(2, 2, 20, 2), \"mm\"), row_split = gsub(\"\\\\d+$\", \"\", label), \n    heatmap_legend_list = lgd_list, heatmap_legend_side = \"bottom\")\nanno_title = c(\"n_gr\" = \"Number of\\nDMRs\", \"n_corr\" = \"Significantly\\ncorrelated genes\",\n    \"gene_anno\" = \"Gene annotation\", \"dist_tss\" = \"Distance to TSS\",\n    \"cgi_anno\" = \"CGI annotation\", \"pct_st\" = \"Overlap to\\nChromatin states\")\nfor(an in names(anno_title)) {\n    decorate_annotation(an, {\n        grid.text(anno_title[an], y = unit(1, \"npc\") + unit(3, \"mm\"), just = \"bottom\")\n    })\n}\nht_title = c(\"mean_meth\" = \"Mean\\nmethylation\", \"enrich_gf\" = \"Enrichment to\\ngenomic features\",\n    \"enrich_st\" = \"Enrichment to\\nchromatin states\")\nfor(an in names(ht_title)) {\n    decorate_heatmap_body(an, {\n        grid.text(ht_title[an], y = unit(1, \"npc\") + unit(3, \"mm\"), just = \"bottom\")\n    })\n}\nprop = c(\n    runif(10, min = 0.1, max = 0.5),\n    runif(10, min = 0.2, max = 0.4),\n    runif(10, min = 0.3, max = 0.6),\n    runif(10, min = 0.4, max = 0.8)\n)\nmedian_length = c(\n    runif(10, min = 5000, max = 10000),\n    runif(10, min = 6000, max = 20000),\n    runif(10, min = 7000, max = 15000),\n    runif(10, min = 6000, max = 30000)\n)\ngroup = rep(letters[1:4], each = 10)\nht_list = HeatmapAnnotation(prop = anno_barplot(prop, height = unit(4, \"cm\"),\n        axis_param = list(at = c(0, 0.2, 0.4, 0.6, 0.8), \n            labels = c(\"0%\", \"20%\", \"40%\", \"60%\", \"80%\"))),\n    annotation_name_rot = 90) %v%\nHeatmapAnnotation(median_length = anno_barplot(median_length, height = unit(4, \"cm\"),\n        axis_param = list(at = c(0, 10000, 20000), labels = c(\"0kb\", \"10kb\", \"20kb\"))),\n    annotation_name_rot = 90) %v%\nHeatmapAnnotation(group = group)\ndraw(ht_list, column_title = \"Statistics for a list of genomic regions\")\n# code only for demonstration\nHeatmapAnnotation(\n    prop = anno_barplot(prop, height = unit(4, \"cm\"),\n        axis_param = list(at = c(0, 0.2, 0.4, 0.6, 0.8), \n            labels = c(\"0%\", \"20%\", \"40%\", \"60%\", \"80%\"))),\n    median_length = anno_barplot(median_length, height = unit(4, \"cm\"),\n        axis_param = list(at = c(0, 10000, 20000), labels = c(\"0kb\", \"10kb\", \"20kb\"))),\n    group = group,\n    annotation_name_rot = c(90, 90, 0),\n    gap = unit(2, \"mm\")\n) %v% NULL # add NULL to convert single HeatmapAnnotation to HeatmapList"},{"path":"three-d-heatmap.html","id":"three-d-heatmap","chapter":"12 Three-dimensional ComplexHeatmap","heading":"12 Three-dimensional ComplexHeatmap","text":"","code":""},{"path":"three-d-heatmap.html","id":"motivation","chapter":"12 Three-dimensional ComplexHeatmap","heading":"12.1 Motivation","text":"ComplexHeatmap densityHeatmap() visualize list density\ndistributions, following example:basic R graphics, since distributions can also visualized histograms, ComplexHeatmap\nversion 2.7.9, added new function frequencyHeatmap() like histogram-version\ndensity heatmap. usage similar densityHeatmap():previous example, frequency matrix visualized heatmap. Note can use different statistic\nfrequencyHeatmap(), .e., \"count\", \"proportion\" \"density\".Well, frequency heatmap claims histogram-version density heatmap, \nlook like histograms . Maybe 3D heatmap 3D bars proper.\ncan done setting argument use_3d = TRUE frequencyHeatmap().looks nicer! next section explain 3D Heatmap implemented.","code":"\nlibrary(ComplexHeatmap)\nset.seed(123)\nmat = matrix(rnorm(500), ncol = 10)\ncolnames(mat) = letters[1:10]\ndensityHeatmap(mat)\nfrequencyHeatmap(mat)\nfrequencyHeatmap(mat, use_3d = TRUE)"},{"path":"three-d-heatmap.html","id":"implementation-of-3d-heatmap","chapter":"12 Three-dimensional ComplexHeatmap","heading":"12.2 Implementation of 3D heatmap","text":"First, need draw 3D bars. can done new function bar3D(). usage follows:arguments :x: x coordinate center point bottom face. Value unit object. numeric, default unit npc.y: y coordinate center point bottom face.w: Width bar (x direction). See following figure.h: Height bar (y direction). See following figure.l: Length bar (z direction). See following figure.theta: Angle projection. See following figure. Note theta can take value 0 90.fill argument sets color. enhance visual effect 3D visualization, three faces actually slighly different brightness.theta argument sets angle projection. Since right-hand\nperson, left hand free feels like ’s giving invisible\nforce push bars right, thus, theta can take value \n0 90. :)add bars heatmap cells, can simply implement bar3D() cell_fun\nlayer_fun add bar cell. new function\nHeatmap3D() simplifies . Heatmap3D() accepts almost arguments\nHeatmap() difference cell 3D bar \nheight corresponds value.Heatmap3D() allows non-negative matrix input. Also default values\nchanges arguments, row names put left side heatmap,\nclusterings still applied dendrograms drawn default.Following demonstration usage Heatmap3D():previous example, bars close top heatmap right \nheatmap large length, overlap heatmap title legend, \ncase, need manually adjust space , e.g., title \nheatmap body.ComplexHeatmap, several global options control \nspaces heatmap components. solve problem previous example,\ncan manually set proper value ht_opt$HEATMAP_LEGEND_PADDING \nht_opt$TITLE_PADDING.Reset global options ht_opt(RESET = TRUE):Next demonstrate another example applied well-known measles vaccine dataset. First show\n“normal 2D heatmap.” Code generating heatmap can found .change 3D visualization, simply replace Heatmap() \nHeatmap3D() original arguments Heatmap() can still \nput . simplicity, 3D heatmap, removed top annotation \nright annotation.way, also possible turn static 3D heatmap \ninteractive Shiny application package InteractiveComplexHeatmap. See \nfollowing figure:Heatmap3D() can lot things Heatmap(), adding\nannotations, splitting heatmap concatenating heatmaps +/%v%. since 3D\nvisualization general good idea actually won’t give \ninformation can get 2D visualization, thus, \nwant use Heatmap3D(), better keep simple possible. Also, please\napply small matrices, take long time generate large matrices.","code":"\nbar3D(x = 0.5, y = 0.5, w = 0.2, h = 0.2, l = unit(1, \"cm\"), theta = 60)\nbar3D(x = seq(0.2, 0.8, length = 4), y = 0.5, w = unit(5, \"mm\"), h = unit(5, \"mm\"), \n    l = unit(1, \"cm\"), fill = c(\"red\", \"green\", \"blue\", \"purple\"))\nbar3D(x = seq(0.2, 0.8, length = 4), y = 0.5, w = unit(5, \"mm\"), h = unit(5, \"mm\"), \n    l = unit(1, \"cm\"), theta = c(20, 40, 60, 80))\nset.seed(7)\nmat = matrix(runif(100), 10)\nrownames(mat) = LETTERS[1:10]\ncolnames(mat) = letters[1:10]\nHeatmap3D(mat, name = \"mat\", column_title = \"This is a 3D heatmap\")\nht_opt$HEATMAP_LEGEND_PADDING = unit(5, \"mm\")\nht_opt$TITLE_PADDING = unit(c(9, 2), \"mm\") # bottom and top padding\nHeatmap3D(mat, name = \"mat\", column_title = \"This is a 3D heatmap\")\nht_opt(RESET = TRUE)\nmat = readRDS(system.file(\"extdata\", \"measles.rds\", package = \"ComplexHeatmap\"))\nyear_text = as.numeric(colnames(mat))\nyear_text[year_text %% 10 != 0] = \"\"\nha_column = HeatmapAnnotation(\n    year = anno_text(year_text, rot = 0, location = unit(1, \"npc\"), just = \"top\")\n)\ncol_fun = circlize::colorRamp2(c(0, 800, 1000, 127000), c(\"white\", \"cornflowerblue\", \"yellow\", \"red\"))\nht_opt$TITLE_PADDING = unit(c(15, 2), \"mm\")\nHeatmap3D(mat, name = \"cases\", col = col_fun,\n    cluster_columns = FALSE, show_row_dend = FALSE, \n    show_column_names = FALSE,\n    row_names_side = \"left\", row_names_gp = gpar(fontsize = 8),\n    column_title = 'Measles cases in US states 1930-2001\\nVaccine introduced 1961',\n    bottom_annotation = ha_column,\n    heatmap_legend_param = list(at = c(0, 5e4, 1e5, 1.5e5), \n        labels = c(\"0\", \"50k\", \"100k\", \"150k\")),\n    # new arguments for Heatmap3D()\n    bar_rel_width = 1, bar_rel_height = 1, bar_max_length = unit(2, \"cm\")\n)"},{"path":"genome-level-heatmap.html","id":"genome-level-heatmap","chapter":"13 Genome-level heatmap","heading":"13 Genome-level heatmap","text":"Many people interested making genome-scale heatmap multiple\ntracks, like examples \n\n.\nchapter, demonstrate implement \nComplexHeatmap.make genome-scale plot, first need ranges chromosome-level. \nmany ways obtain information. following, use\ncirclize::read.chromInfo() function.final heatmap, row (genomic direction vertical) \ncolumn (genomic direction horizontal) actually represents genomic\nwindow, thus need split genome equal-width windows. use\nEnrichedHeatmap::makeWindows() function split genome 1MB window\n(two meta-columns chr_window can ignored ).visualize genome-scale signals heatmap well tracks, now\ntask calculate average signals 1MB windows overlapping\ngenomic windows genomic signals. implement function\naverage_in_window(). function adapted HilbertCurve\npackage since \nsimilar task .average_in_window() function, following arguments:window: GRanges object genomic windows.gr: GRanges object genomic signals.v: vector matrix. value associated gr \nlength nrow gr. v can numeric character. \nmissing NULL, value one assign every region gr. v numeric,\ncan vector matrix, v character, can vector.method: Method summarize signals every genomic window.empty_v: default value window region gr overlaps .function returns matrix row length order window.overlapping model illustrated following plot. red line \nbottom represents certain genomic window. Black lines top regions\ngenomic signals overlap window. thick lines indicate \nintersected part signal regions window.given window, \\(n\\) number signal regions overlap \nwindow (5 plot), \\(w_i\\) width intersected\nsegments (black thick lines), \\(x_i\\) signal value associated \noriginal regions.signals numeric, either vector matrix, three pre-defined methods:\n“absolute” method denoted \\(v_a\\) simply calculated mean\nsignal regions regardless width.\n\\[ v_a = \\frac{\\sum_i^n{x_i}}{n} \\]\n“weighted” method denoted \\(v_w\\) calculated mean \nsignal regions weighted width intersections. default\nmethod numeric signals.\n\\[ v_w = \\frac{\\sum_i^n{x_iw_i}}{\\sum_i^n{w_i}} \\]\n“Absolute” “weighted” methods applied background values\ntaken consideration. example, summarizing mean\nmethylation small window, non-CpG background ignored, \nmethylation associated CpG sites positions.\n“w0” method weighted mean intersected parts \nun-intersected parts.\n\\[ v_{w0} = \\frac{v_wW}{W+W'} \\]\n\\(W\\) sum width intersected parts (\\(\\sum_i^n{w_i}\\)) \\(W'\\) \nsum width non-intersected parts.signals numeric, either vector matrix, three pre-defined methods:“absolute” method denoted \\(v_a\\) simply calculated mean\nsignal regions regardless width.\\[ v_a = \\frac{\\sum_i^n{x_i}}{n} \\]“weighted” method denoted \\(v_w\\) calculated mean \nsignal regions weighted width intersections. default\nmethod numeric signals.\\[ v_w = \\frac{\\sum_i^n{x_iw_i}}{\\sum_i^n{w_i}} \\]“Absolute” “weighted” methods applied background values\ntaken consideration. example, summarizing mean\nmethylation small window, non-CpG background ignored, \nmethylation associated CpG sites positions.“w0” method weighted mean intersected parts \nun-intersected parts.\\[ v_{w0} = \\frac{v_wW}{W+W'} \\]\\(W\\) sum width intersected parts (\\(\\sum_i^n{w_i}\\)) \\(W'\\) \nsum width non-intersected parts.signals character vector, denote levels encoded \\(x_i\\)\n\\(\\) certain level \\(\\) denoted \\(\\), final value assigned \nwindow level corresponding segments maximal sum widths.\n\\[\\underset{\\}{\\operatorname{arg\\,max}}\\sum_{}^n (x_i=)\\cdot w_i\\]signals character vector, denote levels encoded \\(x_i\\)\n\\(\\) certain level \\(\\) denoted \\(\\), final value assigned \nwindow level corresponding segments maximal sum widths.\\[\\underset{\\}{\\operatorname{arg\\,max}}\\sum_{}^n (x_i=)\\cdot w_i\\]According rules, signal value v numeric, argumemt method\ncan one weighted (default), absolute w0, v character,\nvalue method ignored.Besides pre-defined values, method can also user-defined function works\nnumeric signals character signals. user-defined function accept\nthree arguments: x, w gw. function applied every genomic window.\nthree arguments :x: signal values fall genomic window (shown previous plot).w: associated segment widths.gw: width current genomic window.user-defined function return scalar variable.OK, now function average_in_window(), can convert genomic\nsignals window-based matrix. following example, generate\napproximately 1000 random genomic regions 10 columns random values (\nsimulate 10 samples).first five genomic windows value associated region \ngr1 overlaps , thus, take value empty_v \ndefault NA.second data visualize 10 lists genomic regions character\nsignals (let’s assume copy number variation results 10 samples).\nrandom regions, additionally sample 20 , just make \nsparse genome.third data visualize simply genomic regions two numeric columns columns\nvisualized point track first column visualized barplot track.fourth data visualize list gene symbols want mark \nplot. gr3 contains genomic positions genes well \nsymbols. variable contains row indice corresponding\nwindows chr_window labels contains gene names. shown \nfollowing code, simply use findOverlaps() associate gene regions \ngenomic windows.Now variables ready making heatmaps. ,\nbetter control heatmap, set chr factor control order chromosomes\nfinal plot create variable subgroup simulate 10 columns matrix\ntwo subgroups.following code makes heatmap additional tracks. plot combination\ntwo heatmaps three row annotations. Don’t scared massive number\narguments. using ComplexHeatmap week, believe\n’ve already get used :).easy make arrangement heatmaps vertical (use %v% concatenate\nheatmaps!). Just carefully switch row-related parameters \ncolumn-related parameters. additinally adjust legends make \nlook nicer plot.Note use trick arrange chromosome names. Since chromosome names \noverlap small chromosomes, simply add \\n neighbour chromosome names\n(see set column_title argument first heatmap).","code":"\nlibrary(circlize)\nlibrary(GenomicRanges)\nchr_df = read.chromInfo()$df\nchr_df = chr_df[chr_df$chr %in% paste0(\"chr\", 1:22), ]\nchr_gr = GRanges(seqnames = chr_df[, 1], ranges = IRanges(chr_df[, 2] + 1, chr_df[, 3]))\nchr_gr## GRanges object with 22 ranges and 0 metadata columns:\n##        seqnames      ranges strand\n##           <Rle>   <IRanges>  <Rle>\n##    [1]     chr1 1-249250621      *\n##    [2]     chr2 1-243199373      *\n##    [3]     chr3 1-198022430      *\n##    [4]     chr4 1-191154276      *\n##    [5]     chr5 1-180915260      *\n##    ...      ...         ...    ...\n##   [18]    chr18  1-78077248      *\n##   [19]    chr19  1-59128983      *\n##   [20]    chr20  1-63025520      *\n##   [21]    chr21  1-48129895      *\n##   [22]    chr22  1-51304566      *\n##   -------\n##   seqinfo: 22 sequences from an unspecified genome; no seqlengths\nlibrary(EnrichedHeatmap)\nchr_window = makeWindows(chr_gr, w = 1e6)\nchr_window## GRanges object with 2875 ranges and 2 metadata columns:\n##          seqnames            ranges strand |  .i_query .i_window\n##             <Rle>         <IRanges>  <Rle> | <integer> <integer>\n##      [1]     chr1         1-1000000      * |         1         1\n##      [2]     chr1   1000001-2000000      * |         1         2\n##      [3]     chr1   2000001-3000000      * |         1         3\n##      [4]     chr1   3000001-4000000      * |         1         4\n##      [5]     chr1   4000001-5000000      * |         1         5\n##      ...      ...               ...    ... .       ...       ...\n##   [2871]    chr22 46000001-47000000      * |        22        47\n##   [2872]    chr22 47000001-48000000      * |        22        48\n##   [2873]    chr22 48000001-49000000      * |        22        49\n##   [2874]    chr22 49000001-50000000      * |        22        50\n##   [2875]    chr22 50000001-51000000      * |        22        51\n##   -------\n##   seqinfo: 22 sequences from an unspecified genome; no seqlengths\naverage_in_window = function(window, gr, v, method = \"weighted\", empty_v = NA) {\n\n    if(missing(v)) v = rep(1, length(gr))\n    if(is.null(v)) v = rep(1, length(gr))\n    if(is.atomic(v) && is.vector(v)) v = cbind(v)\n\n    v = as.matrix(v)\n    if(is.character(v) && ncol(v) > 1) {\n        stop(\"`v` can only be a character vector.\")\n    }\n\n    if(length(empty_v) == 1) {\n        empty_v = rep(empty_v, ncol(v))\n    }\n\n    u = matrix(rep(empty_v, each = length(window)), nrow = length(window), ncol = ncol(v))\n\n    mtch = as.matrix(findOverlaps(window, gr))\n    intersect = pintersect(window[mtch[,1]], gr[mtch[,2]])\n    w = width(intersect)\n    v = v[mtch[,2], , drop = FALSE]\n    n = nrow(v)\n\n    ind_list = split(seq_len(n), mtch[, 1])\n    window_index = as.numeric(names(ind_list))\n    window_w = width(window)\n\n    if(is.character(v)) {\n        for(i in seq_along(ind_list)) {\n            ind = ind_list[[i]]\n            if(is.function(method)) {\n                u[window_index[i], ] = method(v[ind], w[ind], window_w[i])\n            } else {\n                tb = tapply(w[ind], v[ind], sum)\n                u[window_index[i], ] = names(tb[which.max(tb)])\n            }\n        }\n    } else {\n        if(method == \"w0\") {\n            gr2 = reduce(gr, min.gapwidth = 0)\n            mtch2 = as.matrix(findOverlaps(window, gr2))\n            intersect2 = pintersect(window[mtch2[, 1]], gr2[mtch2[, 2]])\n\n            width_intersect = tapply(width(intersect2), mtch2[, 1], sum)\n            ind = unique(mtch2[, 1])\n            width_setdiff = width(window[ind]) - width_intersect\n\n            w2 = width(window[ind])\n\n            for(i in seq_along(ind_list)) {\n                ind = ind_list[[i]]\n                x = colSums(v[ind, , drop = FALSE]*w[ind])/sum(w[ind])\n                u[window_index[i], ] = (x*width_intersect[i] + empty_v*width_setdiff[i])/w2[i]\n            }\n\n        } else if(method == \"absolute\") {\n            for(i in seq_along(ind_list)) {\n                u[window_index[i], ] = colMeans(v[ind_list[[i]], , drop = FALSE])\n            }\n            \n        } else if(method == \"weighted\") {\n            for(i in seq_along(ind_list)) {\n                ind = ind_list[[i]]\n                u[window_index[i], ] = colSums(v[ind, , drop = FALSE]*w[ind])/sum(w[ind])\n            }\n        } else {\n            if(is.function(method)) {\n                for(i in seq_along(ind_list)) {\n                    ind = ind_list[[i]]\n                    u[window_index[i], ] = method(v[ind], w[ind], window_w[i])\n                }\n            } else {\n                stop(\"wrong method.\")\n            }\n        }\n    }\n\n    return(u)\n}\nbed1 = generateRandomBed(nr = 1000, nc = 10) # generateRandomBed() is from circlize package\n# convert to a GRanes object\ngr1 = GRanges(seqnames = bed1[, 1], ranges = IRanges(bed1[, 2], bed1[, 3]))\n\nnum_mat = average_in_window(chr_window, gr1, bed1[, -(1:3)])\ndim(num_mat)## [1] 2875   10\nhead(num_mat)##            [,1]       [,2]      [,3]       [,4]       [,5]       [,6]\n## [1,] 0.41221587 -1.0284374 0.3001770 0.30235826 -0.1090057 -0.6867689\n## [2,] 0.41221587 -1.0284374 0.3001770 0.30235826 -0.1090057 -0.6867689\n## [3,] 0.41221587 -1.0284374 0.3001770 0.30235826 -0.1090057 -0.6867689\n## [4,]         NA         NA        NA         NA         NA         NA\n## [5,] 0.04940406 -0.2799608 0.1718526 0.05035123  0.4964346  0.3794261\n## [6,]         NA         NA        NA         NA         NA         NA\n##             [,7]       [,8]       [,9]      [,10]\n## [1,] -0.01084778 -0.2034531 -0.9144625 -0.5319540\n## [2,] -0.01084778 -0.2034531 -0.9144625 -0.5319540\n## [3,] -0.01084778 -0.2034531 -0.9144625 -0.5319540\n## [4,]          NA         NA         NA         NA\n## [5,]  0.22292755 -0.7848129  0.2489310 -0.3708738\n## [6,]          NA         NA         NA         NA\nbed_list = lapply(1:10, function(i) {\n    generateRandomBed(nr = 1000, nc = 1, \n        fun = function(n) sample(c(\"gain\", \"loss\"), n, replace = TRUE))\n})\nchar_mat = NULL\nfor(i in 1:10) {\n    bed = bed_list[[i]]\n    bed = bed[sample(nrow(bed), 20), , drop = FALSE]\n    gr_cnv = GRanges(seqnames = bed[, 1], ranges = IRanges(bed[, 2], bed[, 3]))\n\n    char_mat = cbind(char_mat, average_in_window(chr_window, gr_cnv, bed[, 4]))\n}\nbed2 = generateRandomBed(nr = 100, nc = 2)\ngr2 = GRanges(seqnames = bed2[, 1], ranges = IRanges(bed2[, 2], bed2[, 3]))\n\nv = average_in_window(chr_window, gr2, bed2[, 4:5])\nbed3 = generateRandomBed(nr = 40, nc = 0)\ngr3 = GRanges(seqnames = bed3[, 1], ranges = IRanges(bed3[, 2], bed3[, 2]))\ngr3$gene = paste0(\"gene_\", 1:length(gr3))\n\nmtch = as.matrix(findOverlaps(chr_window, gr3))\nat = mtch[, 1]\nlabels = mcols(gr3)[mtch[, 2], 1]\nchr = as.vector(seqnames(chr_window))\nchr_level = paste0(\"chr\", 1:22)\nchr = factor(chr, levels = chr_level)\n\nsubgroup = rep(c(\"A\", \"B\"), each = 5)\nlibrary(ComplexHeatmap)\nht_opt$TITLE_PADDING = unit(c(4, 4), \"points\")\nht_list = Heatmap(num_mat, name = \"mat\", col = colorRamp2(c(-1, 0, 1), c(\"green\", \"white\", \"red\")),\n    row_split = chr, cluster_rows = FALSE, show_column_dend = FALSE,\n    column_split = subgroup, cluster_column_slices = FALSE,\n    column_title = \"numeric matrix\",\n    top_annotation = HeatmapAnnotation(subgroup = subgroup, annotation_name_side = \"left\"),\n    row_title_rot = 0, row_title_gp = gpar(fontsize = 10), border = TRUE,\n    row_gap = unit(0, \"points\")) +\nHeatmap(char_mat, name = \"CNV\", col = c(\"gain\" = \"red\", \"loss\" = \"blue\"),\n    border = TRUE, column_title = \"character matrix\") +\nrowAnnotation(label = anno_mark(at = at, labels = labels)) +\nrowAnnotation(pt = anno_points(v, gp = gpar(col = 4:5), pch = c(1, 16)), \n    width = unit(2, \"cm\")) +\nrowAnnotation(bar = anno_barplot(v[, 1], gp = gpar(col = ifelse(v[ ,1] > 0, 2, 3))), \n    width = unit(2, \"cm\"))\ndraw(ht_list, merge_legend = TRUE)\nht_list = Heatmap(t(num_mat), name = \"mat\", col = colorRamp2(c(-1, 0, 1), c(\"green\", \"white\", \"red\")),\n    column_split = chr, cluster_columns = FALSE, show_row_dend = FALSE,\n    row_split = subgroup, cluster_row_slices = FALSE,\n    row_title = \"numeric matrix\",\n    left_annotation = rowAnnotation(subgroup = subgroup, show_annotation_name = FALSE,\n        annotation_legend_param = list(\n            subgroup = list(direction = \"horizontal\", title_position = \"lefttop\", nrow = 1))),\n    column_title_gp = gpar(fontsize = 10), border = TRUE,\n    column_gap = unit(0, \"points\"),\n    column_title = ifelse(1:22 %% 2 == 0, paste0(\"\\n\", chr_level), paste0(chr_level, \"\\n\")),\n    heatmap_legend_param = list(direction = \"horizontal\", title_position = \"lefttop\")) %v%\nHeatmap(t(char_mat), name = \"CNV\", col = c(\"gain\" = \"red\", \"loss\" = \"blue\"),\n    border = TRUE, row_title = \"character matrix\",\n    heatmap_legend_param = list(direction = \"horizontal\", title_position = \"lefttop\", nrow = 1)) %v%\nHeatmapAnnotation(label = anno_mark(at = at, labels = labels, side = \"bottom\")) %v%\nHeatmapAnnotation(pt = anno_points(v, gp = gpar(col = 4:5), pch = c(1, 16)),\n    annotation_name_side = \"left\", height = unit(2, \"cm\")) %v%\nHeatmapAnnotation(bar = anno_barplot(v[, 1], gp = gpar(col = ifelse(v[ ,1] > 0, 2, 3))), \n    annotation_name_side = \"left\", height = unit(2, \"cm\"))\ndraw(ht_list, heatmap_legend_side = \"bottom\", merge_legend = TRUE)"},{"path":"more-examples.html","id":"more-examples","chapter":"14 More Examples","heading":"14 More Examples","text":"","code":""},{"path":"more-examples.html","id":"add-more-information-for-gene-expression-matrix","chapter":"14 More Examples","heading":"14.1 Add more information for gene expression matrix","text":"Heatmaps popular visualize gene expression matrix. Rows \nmatrix correspond genes information genes can attached\nexpression heatmap.following example, big heatmap visualizes relative expression genes\n(expression gene scaled). right put absolute\nexpression level genes single-column heatmap. gene length gene\ntype (.e. protein coding lincRNA) also put heatmap annotations \nheatmaps.left heatmaps, colored rectangles drawn \nanno_block() identify five clusters k-means clustering. top\n“base mean” “gene type” heatmaps, summary plots (barplots\nboxplots) showing statistics distributions data points \nfive clusters.","code":"\nlibrary(ComplexHeatmap)\nlibrary(circlize)\n\nexpr = readRDS(system.file(package = \"ComplexHeatmap\", \"extdata\", \"gene_expression.rds\"))\nmat = as.matrix(expr[, grep(\"cell\", colnames(expr))])\nbase_mean = rowMeans(mat)\nmat_scaled = t(apply(mat, 1, scale))\n\ntype = gsub(\"s\\\\d+_\", \"\", colnames(mat))\nha = HeatmapAnnotation(type = type, annotation_name_side = \"left\")\n\nht_list = Heatmap(mat_scaled, name = \"expression\", row_km = 5, \n    col = colorRamp2(c(-2, 0, 2), c(\"green\", \"white\", \"red\")),\n    top_annotation = ha, \n    show_column_names = FALSE, row_title = NULL, show_row_dend = FALSE) +\nHeatmap(base_mean, name = \"base mean\", \n    top_annotation = HeatmapAnnotation(summary = anno_summary(gp = gpar(fill = 2:6), \n        height = unit(2, \"cm\"))),\n    width = unit(15, \"mm\")) +\nrowAnnotation(length = anno_points(expr$length, pch = 16, size = unit(1, \"mm\"), \n    axis_param = list(at = c(0, 2e5, 4e5, 6e5), \n        labels = c(\"0kb\", \"200kb\", \"400kb\", \"600kb\")),\n    width = unit(2, \"cm\"))) +\nHeatmap(expr$type, name = \"gene type\", \n    top_annotation = HeatmapAnnotation(summary = anno_summary(height = unit(2, \"cm\"))),\n    width = unit(15, \"mm\"))\n\nht_list = rowAnnotation(block = anno_block(gp = gpar(fill = 2:6, col = NA)), \n    width = unit(2, \"mm\")) + ht_list\n\ndraw(ht_list)"},{"path":"more-examples.html","id":"the-measles-vaccine-heatmap","chapter":"14 More Examples","heading":"14.2 The measles vaccine heatmap","text":"Following code reproduces heatmap introduced .","code":"\nmat = readRDS(system.file(\"extdata\", \"measles.rds\", package = \"ComplexHeatmap\"))\nha1 = HeatmapAnnotation(\n    dist1 = anno_barplot(\n        colSums(mat), \n        bar_width = 1, \n        gp = gpar(col = \"white\", fill = \"#FFE200\"), \n        border = FALSE,\n        axis_param = list(at = c(0, 2e5, 4e5, 6e5, 8e5),\n            labels = c(\"0\", \"200k\", \"400k\", \"600k\", \"800k\")),\n        height = unit(2, \"cm\")\n    ), show_annotation_name = FALSE)\nha2 = rowAnnotation(\n    dist2 = anno_barplot(\n        rowSums(mat), \n        bar_width = 1, \n        gp = gpar(col = \"white\", fill = \"#FFE200\"), \n        border = FALSE,\n        axis_param = list(at = c(0, 5e5, 1e6, 1.5e6),\n            labels = c(\"0\", \"500k\", \"1m\", \"1.5m\")),\n        width = unit(2, \"cm\")\n    ), show_annotation_name = FALSE)\nyear_text = as.numeric(colnames(mat))\nyear_text[year_text %% 10 != 0] = \"\"\nha_column = HeatmapAnnotation(\n    year = anno_text(year_text, rot = 0, location = unit(1, \"npc\"), just = \"top\")\n)\ncol_fun = colorRamp2(c(0, 800, 1000, 127000), c(\"white\", \"cornflowerblue\", \"yellow\", \"red\"))\nht_list = Heatmap(mat, name = \"cases\", col = col_fun,\n    cluster_columns = FALSE, show_row_dend = FALSE, rect_gp = gpar(col= \"white\"), \n    show_column_names = FALSE,\n    row_names_side = \"left\", row_names_gp = gpar(fontsize = 8),\n    column_title = 'Measles cases in US states 1930-2001\\nVaccine introduced 1961',\n    top_annotation = ha1, bottom_annotation = ha_column,\n    heatmap_legend_param = list(at = c(0, 5e4, 1e5, 1.5e5), \n        labels = c(\"0\", \"50k\", \"100k\", \"150k\"))) + ha2\ndraw(ht_list, ht_gap = unit(3, \"mm\"))\ndecorate_heatmap_body(\"cases\", {\n    i = which(colnames(mat) == \"1961\")\n    x = i/ncol(mat)\n    grid.lines(c(x, x), c(0, 1), gp = gpar(lwd = 2, lty = 2))\n    grid.text(\"Vaccine introduced\", x, unit(1, \"npc\") + unit(5, \"mm\"))\n})"},{"path":"more-examples.html","id":"visualize-cell-heterogeneity-from-single-cell-rnaseq","chapter":"14 More Examples","heading":"14.3 Visualize Cell Heterogeneity from Single Cell RNASeq","text":"example, single cell RNA-Seq data mouse T-cells visualized show heterogeneity\ncells. data (mouse_scRNAseq_corrected.txt) Buettner et al.,\n2015, supplementary data 1, sheet\n“Cell-cycle corrected gene expr.” can get mouse_scRNAseq_corrected.txt .following code, duplicated genes removed.Genes expressed half cells filtered .get_correlated_variable_rows() function defined . extracts signature genes \nvariably expressed cells correlate genes.Signature genes defined list genes gene correlates 20 genes \nabsolute correlation larger 0.5.mat2 contains expression values scaled per gene, means contains relative expression\nacross cells every gene. Since single cell RNASeq data highly variable outliers \nfrequent, gene expression scaled within 10th 90th quantiles.Load cell cycle genes ribonucleoprotein genes. cell cycle gene list Buettner et\nal., 2015, supplementary table 1,\nsheet “Union Cyclebase GO genes.” Ribonucleoprotein genes \nGO:0030529. Gene list stored \nmouse_cell_cycle_gene.rds mouse_ribonucleoprotein.rds. two files can found\n\n.Since scaling expression values per gene expression level gene relative \ngenes lost, calculate base mean mean expression gene throughout \nsamples. base mean can used compare expression levels genes.Now following information available:scaled expression, mat2,base mean, base_mean,whether genes ribonucleoprotein genes, rpl,whether genes cell cycle genes, ccl,symbols cell cycle genes, cc_gene,next step, can put information together visualize list heatmaps. \ngene-gene correlation heatmap added end defined main_heatmap, meaning \nrow order heatmaps/row annotations based clustering correlation\nmatrix.cell cycle genes relatively high expression levels (larger 25% quantile \ngenes), gene name indicated text labels. first heatmap, column dendrogram \nunderlaid two different colours based two main groups derived hierarchical clustering\nhighlight two subpopulations.heatmap clearly reveals cells separated two sub-populations. population \nleft first heatmap exhibits high expression subset cell cycle genes (cell cycle\ngenes indicated “cell_cycle” heatmap). However, overall expression level \ngenes relatively low (see “base_expr” heatmap). population right higher\nexpression signature genes. Interestingly, signature genes higher\nexpressed subpopulation enriched genes coding ribonucleoproteins (see\n“ribonucleoprotein” heatmap). subset ribonucleoprotein genes shows strong coexpression\n(see correlation heatmap) overall high expression levels (“base_expr” heatmap).","code":"\nexpr = read.table(\"data/mouse_scRNAseq_corrected.txt\", sep = \"\\t\", header = TRUE)\nexpr = expr[!duplicated(expr[[1]]), ]\nrownames(expr) = expr[[1]]\nexpr = expr[-1]\nexpr = as.matrix(expr)\nexpr = expr[apply(expr, 1, function(x) sum(x > 0)/length(x) > 0.5), , drop = FALSE]\nget_correlated_variable_genes = function(mat, n = nrow(mat), cor_cutoff = 0, n_cutoff = 0) {\n    ind = order(apply(mat, 1, function(x) {\n            q = quantile(x, c(0.1, 0.9))\n            x = x[x > q[1] & x < q[2]]\n            var(x)/mean(x)\n        }), decreasing = TRUE)[1:n]\n    mat2 = mat[ind, , drop = FALSE]\n    dt = cor(t(mat2), method = \"spearman\")\n    diag(dt) = 0\n    dt[abs(dt) < cor_cutoff] = 0\n    dt[dt < 0] = -1\n    dt[dt > 0] = 1\n\n    i = colSums(abs(dt)) > n_cutoff\n\n    mat3 = mat2[i, ,drop = FALSE]\n    return(mat3)\n}\nmat = get_correlated_variable_genes(expr, cor_cutoff = 0.5, n_cutoff = 20)\nmat2 = t(apply(mat, 1, function(x) {\n    q10 = quantile(x, 0.1)\n    q90 = quantile(x, 0.9)\n    x[x < q10] = q10\n    x[x > q90] = q90\n    scale(x)\n}))\ncolnames(mat2) = colnames(mat)\ncc = readRDS(\"data/mouse_cell_cycle_gene.rds\")\nccl = rownames(mat) %in% cc\ncc_gene = rownames(mat)[ccl]\n\nrp = readRDS(\"data/mouse_ribonucleoprotein.rds\")\nrpl = rownames(mat) %in% rp\nbase_mean = rowMeans(mat)\nlibrary(GetoptLong)\nht_list = Heatmap(mat2, col = colorRamp2(c(-1.5, 0, 1.5), c(\"blue\", \"white\", \"red\")), \n    name = \"scaled_expr\", column_title = qq(\"relative expression for @{nrow(mat)} genes\"),\n    show_column_names = FALSE, width = unit(8, \"cm\"),\n    heatmap_legend_param = list(title = \"Scaled expr\")) +\n    Heatmap(base_mean, name = \"base_expr\", width = unit(5, \"mm\"),\n        heatmap_legend_param = list(title = \"Base expr\")) +\n    Heatmap(rpl + 0, name = \"ribonucleoprotein\", col = c(\"0\" = \"white\", \"1\" = \"purple\"), \n        show_heatmap_legend = FALSE, width = unit(5, \"mm\")) +\n    Heatmap(ccl + 0, name = \"cell_cycle\", col = c(\"0\" = \"white\", \"1\" = \"red\"), \n        show_heatmap_legend = FALSE, width = unit(5, \"mm\")) +\n    rowAnnotation(link = anno_mark(at = which(ccl & base_mean > quantile(base_mean, 0.25)), \n        labels = rownames(mat)[ccl & base_mean > quantile(base_mean, 0.25)], \n        labels_gp = gpar(fontsize = 10), padding = unit(1, \"mm\"))) +\n    Heatmap(cor(t(mat2)), name = \"cor\", \n        col = colorRamp2(c(-1, 0, 1), c(\"green\", \"white\", \"red\")), \n        show_row_names = FALSE, show_column_names = FALSE, row_dend_side = \"right\", \n        show_column_dend = FALSE, column_title = \"pairwise correlation between genes\",\n        heatmap_legend_param = list(title = \"Correlation\"))\nht_list = draw(ht_list, main_heatmap = \"cor\")\ndecorate_column_dend(\"scaled_expr\", {\n    tree = column_dend(ht_list)$scaled_expr\n    ind = cutree(as.hclust(tree), k = 2)[order.dendrogram(tree)]\n\n    first_index = function(l) which(l)[1]\n    last_index = function(l) { x = which(l); x[length(x)] }\n    x1 = c(first_index(ind == 1), first_index(ind == 2)) - 1\n    x2 = c(last_index(ind == 1), last_index(ind == 2))\n    grid.rect(x = x1/length(ind), width = (x2 - x1)/length(ind), just = \"left\",\n        default.units = \"npc\", gp = gpar(fill = c(\"#FF000040\", \"#00FF0040\"), col = NA))\n})"},{"path":"more-examples.html","id":"correlations-between-methylation-expression-and-other-genomic-features","chapter":"14 More Examples","heading":"14.4 Correlations between methylation, expression and other genomic features","text":"following example, data randomly generated based patterns found unpublished analysis.\nFirst load data. meth.rds can found .different sources information corresponding variables :type: label shows whether sample tumor normal.mat_meth: matrix rows correspond differetially methylated regions (DMRs). \nvalue matrix mean methylation level DMR every sample.mat_expr: matrix rows correspond genes associated DMRs (.e. \nnearest gene DMR). value matrix expression level gene \nsample. Expression scaled every gene across samples.direction: direction methylation change (hyper meaning higher methylation tumor\nsamples, hypo means lower methylation tumor samples).cor_pvalue: p-value correlation test methylation expression \nassociated gene.gene_type: type genes (e.g. protein coding genes lincRNAs).anno_gene: annotation gene models (intergenic, intragenic TSS).dist: distance DMRs TSS assiciated genes.anno_enhancer: fraction DMR overlaps enhancers.data includes DMRs methylation expression associated gene \nnegatively correlated.clustering columns methylation matrix calculated first columns \nexpression matrix can adjusted column order methylation matrix.first define two column annotations make complex heatmaps.complex heatmaps reveal highly methylated DMRs enriched intergenic intragenic\nregions rarely overlap enhancers. contrast, lowly methylated DMRs enriched \ntranscription start sites (TSS) enhancers.","code":"\nres_list = readRDS(\"data/meth.rds\")\ntype = res_list$type\nmat_meth = res_list$mat_meth\nmat_expr = res_list$mat_expr\ndirection = res_list$direction\ncor_pvalue = res_list$cor_pvalue\ngene_type = res_list$gene_type\nanno_gene = res_list$anno_gene\ndist = res_list$dist\nanno_enhancer = res_list$anno_enhancer\ncolumn_tree = hclust(dist(t(mat_meth)))\ncolumn_order = column_tree$order\nlibrary(RColorBrewer)\nmeth_col_fun = colorRamp2(c(0, 0.5, 1), c(\"blue\", \"white\", \"red\"))\ndirection_col = c(\"hyper\" = \"red\", \"hypo\" = \"blue\")\nexpr_col_fun = colorRamp2(c(-2, 0, 2), c(\"green\", \"white\", \"red\"))\npvalue_col_fun = colorRamp2(c(0, 2, 4), c(\"white\", \"white\", \"red\"))\ngene_type_col = structure(brewer.pal(length(unique(gene_type)), \"Set3\"), \n    names = unique(gene_type))\nanno_gene_col = structure(brewer.pal(length(unique(anno_gene)), \"Set1\"), \n    names = unique(anno_gene))\ndist_col_fun = colorRamp2(c(0, 10000), c(\"black\", \"white\"))\nenhancer_col_fun = colorRamp2(c(0, 1), c(\"white\", \"orange\"))\nht_opt(\n    legend_title_gp = gpar(fontsize = 8, fontface = \"bold\"), \n    legend_labels_gp = gpar(fontsize = 8), \n    heatmap_column_names_gp = gpar(fontsize = 8),\n    heatmap_column_title_gp = gpar(fontsize = 10),\n    heatmap_row_title_gp = gpar(fontsize = 8)\n)\n\nha = HeatmapAnnotation(type = type, \n    col = list(type = c(\"Tumor\" = \"pink\", \"Control\" = \"royalblue\")),\n    annotation_name_side = \"left\")\nha2 = HeatmapAnnotation(type = type, \n    col = list(type = c(\"Tumor\" = \"pink\", \"Control\" = \"royalblue\")), \n    show_legend = FALSE)\n\nht_list = Heatmap(mat_meth, name = \"methylation\", col = meth_col_fun,\n    column_order= column_order,\n    top_annotation = ha, column_title = \"Methylation\") +\n    Heatmap(direction, name = \"direction\", col = direction_col) +\n    Heatmap(mat_expr[, column_tree$order], name = \"expression\", \n        col = expr_col_fun, \n        column_order = column_order, \n        top_annotation = ha2, column_title = \"Expression\") +\n    Heatmap(cor_pvalue, name = \"-log10(cor_p)\", col = pvalue_col_fun) +\n    Heatmap(gene_type, name = \"gene type\", col = gene_type_col) +\n    Heatmap(anno_gene, name = \"anno_gene\", col = anno_gene_col) +\n    Heatmap(dist, name = \"dist_tss\", col = dist_col_fun) +\n    Heatmap(anno_enhancer, name = \"anno_enhancer\", col = enhancer_col_fun, \n        cluster_columns = FALSE, column_title = \"Enhancer\")\n\ndraw(ht_list, row_km = 2, row_split = direction,\n    column_title = \"Comprehensive correspondence between methylation, expression and other genomic features\", \n    column_title_gp = gpar(fontsize = 12, fontface = \"bold\"), \n    merge_legends = TRUE, heatmap_legend_side = \"bottom\")\nht_opt(RESET = TRUE)"},{"path":"more-examples.html","id":"visualize-methylation-profile-with-complex-annotations","chapter":"14 More Examples","heading":"14.5 Visualize Methylation Profile with Complex Annotations","text":"example, Figure 1 Strum et al., 2012\nre-implemented adjustments.packages need loaded firstly.Methylation profiles can download GEO\ndatabase. GEOquery\npackage used retrieve\ndata GEO.methylation profiles measured Illumina HumanMethylation450 BeadChip arrays.\nload probe data via IlluminaHumanMethylation450kanno.ilmn12.hg19 package.Adjust row names matrix probes.probe contains locations probes also information whether CpG sites overlap\nSNPs. remove probes sex chromosomes probes overlap SNPs.Get subsets locations probes annotation CpG Islands accordingly.Separate matrix matrix tumor samples matrix normal samples. Also modify\ncolumn names tumor samples consistent phenotype data read\nlater.Phenotype data Sturm et al., 2012,\nsupplementary table S1 can found .rows phenotype data adjusted columns methylation matrix.Please note use 136 samples DKFZ, Sturm et al., 2012, additional 74 TCGA samples used.Extract top 8000 probes variable methylation tumor samples, also subset \ninformation correspondingly.probe, find distance closest TSS. pc_tx_tss.bed contains positions\nTSS protein coding genes.NA matrix (sum(.na(m1))/length(m1) = 0.0011967)\nbreak cor() function, replace NA intermediate methylation (0.5).\nNote although ComplexHeatmap allows NA matrix, removal NA speed clustering.following annotations added columns methylation matrix:agesubtype classification DKFZsubtype classification TCGAsubtype classification TCGA, based expression profileIDH1 mutationH3F3A mutationTP53 mutationchr7 gainchr10 lossCDKN2A deletionEGFR amplificationPDGFRA amplificationIn following code define column annotation ha variable. Also customize colors, legends height annotations.final plot, four heatmaps added. left right, areheatmap methylation tumor samplesmethylation normal samplesdistance nearest TSSCpG Island (CGI) annotation.heatmaps split rows according CGI annotations.heatmaps plotted, additional graphics labels annotations added \ndecorate_*() functions.","code":"\nlibrary(matrixStats)\nlibrary(GenomicRanges)\nlibrary(GEOquery)\ngset = getGEO(\"GSE36278\")\nlibrary(IlluminaHumanMethylation450kanno.ilmn12.hg19)\ndata(Locations)\n\nmat = exprs(gset[[1]])\ncolnames(mat) = phenoData(gset[[1]])@data$title\nmat = mat[rownames(Locations), ] \ndata(SNPs.137CommonSingle)\ndata(Islands.UCSC)\nl = Locations$chr %in% paste0(\"chr\", 1:22) & is.na(SNPs.137CommonSingle$Probe_rs)\nmat = mat[l, ]\ncgi = Islands.UCSC$Relation_to_Island[l]\nloc = Locations[l, ]\nmat1 = as.matrix(mat[, grep(\"GBM\", colnames(mat))])   # tumor samples\nmat2 = as.matrix(mat[, grep(\"CTRL\", colnames(mat))])  # normal samples\ncolnames(mat1) = gsub(\"GBM\", \"dkfz\", colnames(mat1))\nphenotype = read.table(\"data/450K_annotation.txt\", header = TRUE, sep = \"\\t\", \n    row.names = 1, check.names = FALSE, comment.char = \"\", stringsAsFactors = FALSE)\nphenotype = phenotype[colnames(mat1), ]\nind = order(rowVars(mat1, na.rm = TRUE), decreasing = TRUE)[1:8000]\nm1 = mat1[ind, ]\nm2 = mat2[ind, ]\ncgi2 = cgi[ind]\ncgi2 = ifelse(grepl(\"Shore\", cgi2), \"Shore\", cgi2)\ncgi2 = ifelse(grepl(\"Shelf\", cgi2), \"Shelf\", cgi2)\nloc = loc[ind, ]\ngr = GRanges(loc[, 1], ranges = IRanges(loc[, 2], loc[, 2]+1))\ntss = read.table(\"data/pc_tx_tss.bed\", stringsAsFactors = FALSE)\ntss = GRanges(tss[[1]], ranges = IRanges(tss[, 2], tss[, 3]))\n\ntss_dist = distanceToNearest(gr, tss)\ntss_dist = tss_dist@elementMetadata$distance\nm1[is.na(m1)] = 0.5\nm2[is.na(m2)] = 0.5\nmutation_col = structure(names = c(\"MUT\", \"WT\", \"G34R\", \"G34V\", \"K27M\"), \n    c(\"black\", \"white\", \"#4DAF4A\", \"#4DAF4A\", \"#377EB8\"))\ncnv_col = c(\"gain\" = \"#E41A1C\", \"loss\" = \"#377EB8\", \"amp\" = \"#E41A1C\", \n    \"del\" = \"#377EB8\", \"normal\" = \"white\")\nha = HeatmapAnnotation(\n    age = anno_points(phenotype[[13]], \n        gp = gpar(col = ifelse(phenotype[[13]] > 20, \"black\", \"red\")), \n        height = unit(3, \"cm\")),\n    dkfz_cluster = phenotype[[1]],\n    tcga_cluster = phenotype[[2]],\n    tcga_expr = phenotype[[3]],\n    IDH1 = phenotype[[5]],\n    H3F3A = phenotype[[4]],\n    TP53 = phenotype[[6]],\n    chr7_gain = ifelse(phenotype[[7]] == 1, \"gain\", \"normal\"),\n    chr10_loss = ifelse(phenotype[[8]] == 1, \"loss\", \"normal\"),\n    CDKN2A_del = ifelse(phenotype[[9]] == 1, \"del\", \"normal\"),\n    EGFR_amp = ifelse(phenotype[[10]] == 1, \"amp\", \"normal\"),\n    PDGFRA_amp = ifelse(phenotype[[11]] == 1, \"amp\", \"normal\"),\n    col = list(dkfz_cluster = structure(names = c(\"IDH\", \"K27\", \"G34\", \"RTK I PDGFRA\", \n            \"Mesenchymal\", \"RTK II Classic\"), brewer.pal(6, \"Set1\")),\n        tcga_cluster = structure(names = c(\"G-CIMP+\", \"Cluster #2\", \"Cluster #3\"), \n            brewer.pal(3, \"Set1\")),\n        tcga_expr = structure(names = c(\"Proneural\", \"Classical\", \"Mesenchymal\"), \n            c(\"#377EB8\", \"#FFFF33\", \"#FF7F00\")),\n        IDH1 = mutation_col,\n        H3F3A = mutation_col,\n        TP53 = mutation_col,\n        chr7_gain = cnv_col,\n        chr10_loss = cnv_col,\n        CDKN2A_del = cnv_col,\n        EGFR_amp = cnv_col,\n        PDGFRA_amp = cnv_col),\n    na_col = \"grey\", border = TRUE,\n    show_legend = c(TRUE, TRUE, TRUE, FALSE, TRUE, FALSE, TRUE, FALSE, FALSE, FALSE, FALSE),\n    show_annotation_name = FALSE,\n    annotation_legend_param = list(\n        dkfz_cluster = list(title = \"DKFZ Methylation\"),\n        tcga_cluster = list(title = \"TCGA Methylation\"),\n        tcga_expr = list(title = \"TCGA Expression\"),\n        H3F3A = list(title = \"Mutations\"),\n        chr7_gain = list(title = \"CNV\"))\n)\ncol_fun = colorRamp2(c(0, 0.5, 1), c(\"#377EB8\", \"white\", \"#E41A1C\"))\nht_list = Heatmap(m1, col = col_fun, name = \"Methylation\",\n    clustering_distance_columns = \"spearman\",\n    show_row_dend = FALSE, show_column_dend = FALSE,\n    show_column_names = FALSE,\n    bottom_annotation = ha, column_title = qq(\"GBM samples (n = @{ncol(m1)})\"),\n    row_split = factor(cgi2, levels = c(\"Island\", \"Shore\", \"Shelf\", \"OpenSea\")), \n    row_title_gp = gpar(col = \"#FFFFFF00\")) + \nHeatmap(m2, col = col_fun, show_column_names = FALSE, \n    show_column_dend = FALSE, column_title = \"Controls\",\n    show_heatmap_legend = FALSE, width = unit(1, \"cm\")) +\nHeatmap(tss_dist, name = \"tss_dist\", col = colorRamp2(c(0, 2e5), c(\"white\", \"black\")), \n    width = unit(5, \"mm\"),\n    heatmap_legend_param = list(at = c(0, 1e5, 2e5), labels = c(\"0kb\", \"100kb\", \"200kb\"))) + \nHeatmap(cgi2, name = \"CGI\", show_row_names = FALSE, width = unit(5, \"mm\"),\n    col = structure(names = c(\"Island\", \"Shore\", \"Shelf\", \"OpenSea\"), c(\"red\", \"blue\", \"green\", \"#CCCCCC\")))\ndraw(ht_list, row_title = paste0(\"DNA methylation probes (n = \", nrow(m1), \")\"),\n    annotation_legend_side = \"left\", heatmap_legend_side = \"left\")\n\nannotation_titles = c(dkfz_cluster = \"DKFZ Methylation\",\n    tcga_cluster = \"TCGA Methylation\",\n    tcga_expr = \"TCGA Expression\",\n    IDH1 = \"IDH1\",\n    H3F3A = \"H3F3A\",\n    TP53 = \"TP53\",\n    chr7_gain = \"Chr7 gain\",\n    chr10_loss = \"Chr10 loss\",\n    CDKN2A_del = \"Chr10 loss\",\n    EGFR_amp = \"EGFR amp\",\n    PDGFRA_amp = \"PDGFRA amp\")\nfor(an in names(annotation_titles)) {\n    decorate_annotation(an, {\n        grid.text(annotation_titles[an], unit(-2, \"mm\"), just = \"right\")\n        grid.rect(gp = gpar(fill = NA, col = \"black\"))\n    })\n}\ndecorate_annotation(\"age\", {\n    grid.text(\"Age\", unit(8, \"mm\"), just = \"right\")\n    grid.rect(gp = gpar(fill = NA, col = \"black\"))\n    grid.lines(unit(c(0, 1), \"npc\"), unit(c(20, 20), \"native\"), gp = gpar(lty = 2))\n})\ndecorate_annotation(\"IDH1\", {\n    grid.lines(unit(c(-40, 0), \"mm\"), unit(c(1, 1), \"npc\"))\n})\ndecorate_annotation(\"chr7_gain\", {\n    grid.lines(unit(c(-40, 0), \"mm\"), unit(c(1, 1), \"npc\"))\n})"},{"path":"more-examples.html","id":"add-multiple-boxplots-for-single-row","chapter":"14 More Examples","heading":"14.6 Add multiple boxplots for single row","text":"annotation function anno_boxplot() draws one boxplot single row. multiple\nheatmaps concatenated, groups columns already defined, row, \nwant compare heatmaps column groups, thus, multiple boxplots need drawn \nsingle row.following example, demonstrate implement annotation function draws multiple\nboxplots single rows. grid.boxplot() function ComplexHeatmap package \nmakes easy draw boxplot grid system.","code":"\nm1 = matrix(sort(rnorm(100)), 10, byrow = TRUE)\nm2 = matrix(sort(rnorm(100), decreasing = TRUE), 10, byrow = TRUE)\n\nht_list = Heatmap(m1, name = \"m1\") + Heatmap(m2, name = \"m2\")\n\nrg = range(c(m1, m2))\nrg[1] = rg[1] - (rg[2] - rg[1])* 0.02\nrg[2] = rg[2] + (rg[2] - rg[1])* 0.02\nanno_multiple_boxplot = function(index) {\n    nr = length(index)\n    pushViewport(viewport(xscale = rg, yscale = c(0.5, nr + 0.5)))\n    for(i in seq_along(index)) {\n        grid.rect(y = nr-i+1, height = 1, default.units = \"native\")\n        grid.boxplot(m1[ index[i], ], pos = nr-i+1 + 0.2, box_width = 0.3, \n            gp = gpar(fill = \"red\"), direction = \"horizontal\")\n        grid.boxplot(m2[ index[i], ], pos = nr-i+1 - 0.2, box_width = 0.3, \n            gp = gpar(fill = \"green\"), direction = \"horizontal\")\n    }\n    grid.xaxis()\n    popViewport()\n}\n\nht_list = ht_list + rowAnnotation(boxplot = anno_multiple_boxplot, width = unit(4, \"cm\"), \n    show_annotation_name = FALSE)\nlgd = Legend(labels = c(\"m1\", \"m2\"), title = \"boxplots\",\n    legend_gp = gpar(fill = c(\"red\", \"green\")))\ndraw(ht_list, padding = unit(c(20, 2, 2, 2), \"mm\"), heatmap_legend_list = list(lgd))"},{"path":"other-tricks.html","id":"other-tricks","chapter":"15 Other Tricks","heading":"15 Other Tricks","text":"","code":""},{"path":"other-tricks.html","id":"set-the-same-cell-size-for-different-heatmaps-with-different-dimensions","chapter":"15 Other Tricks","heading":"15.1 Set the same cell size for different heatmaps with different dimensions","text":"Assume list heatmaps/oncoPrints want save different e.g. png pdf files, one\nthing might want make size grid/cell heatmap identical across\nheatmaps, thus, need calculate size png/pdf file according number rows \ncolumns heatmap. heatmap generated ComplexHeatmap, heatmap components\nabsolute size size heatmap body (size cells) changable (\nwords, change size final graphic device, e.g. draging graphics\nwindow plot , size heatmap body adjusted), means, size \nwhole plot linearly related number rows columns heatmap. implies can\nactually fit linear model y = *x + b e.g. y height whole plot x \nnumber rows.following example, simply demonstrate establish relation plot height\nnumber rows heatmap. first define function generates \n10-column matrix specific number rows. Note values matrix importance\ndemonstration.Since relation absolutely linear, need test two heatmaps different number \nrows height single row unit(5, \"mm\"). heatmap, also column title,\ncolumn dendrogram, column annotation column names.several things needs noted following code:heatmap object returned draw() layout heatmap calculated \nexecution draw().component_height() returns vector units correspond height heatmap components\ntop bottom heatmap. (component_width() returns width heatmap components).calculating ht_height, add unit(4, \"mm\") top bottom final plot,\n2mm white borders.ht_height needs converted simple unit cm inch.following, y contains values measured inch unit.can fit linear relation y number rows:means relation number rows x height plot y : y = 0.1969*x + 1.3150.can test whether height single rows heatmaps different rows following code.\nNote heatmap configuations ones prepare y.","code":"\nrandom_mat = function(nr) {\n    m = matrix(rnorm(10*nr), nc = 10)\n    colnames(m) = letters[1:10]\n    return(m)\n}\ny = NULL\nfor(nr in c(10, 20)) {\n    ht = draw(Heatmap(random_mat(nr), height = unit(5, \"mm\")*nr, \n        column_title = \"foo\", # one line text\n        top_annotation = HeatmapAnnotation(bar = 1:10)))\n    ht_height = sum(component_height(ht)) + unit(4, \"mm\")\n    ht_height = convertHeight(ht_height, \"inch\", valueOnly = TRUE)\n    y = c(y, ht_height)\n}\nx = c(10, 20)\nlm(y ~ x)## \n## Call:\n## lm(formula = y ~ x)\n## \n## Coefficients:\n## (Intercept)            x  \n##      1.2222       0.1969\nfor(nr in c(10, 20)) {\n    png(paste0(\"test_heatmap_nr_\", nr, \".png\"), width = 5, height = 0.1969*nr + 1.3150, \n        units = \"in\", res = 100)\n    draw(Heatmap(random_mat(nr), height = unit(5, \"mm\")*nr, \n        column_title = \"foo\", # column title can be any one-line string\n        top_annotation = HeatmapAnnotation(bar = 1:10)))\n    dev.off()\n}"}]
